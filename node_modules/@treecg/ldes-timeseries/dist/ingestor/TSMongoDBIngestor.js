"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSMongoDBIngestor = void 0;
const ldes_snapshot_1 = require("@treecg/ldes-snapshot");
const types_1 = require("@treecg/types");
const n3_1 = require("n3");
const MongoDBIngestor_1 = require("./MongoDBIngestor");
const ldes_solid_server_1 = require("ldes-solid-server");
const { namedNode, literal } = n3_1.DataFactory;
/**
 * Implements {@link TSIngestor} to store an LDES TSin a Mongo database.
 */
class TSMongoDBIngestor extends MongoDBIngestor_1.MongoDBIngestor {
    constructor(config) {
        super(config);
        this.root = "";
        this.logger = new ldes_snapshot_1.Logger(this);
        this.viewDescriptionIdentifier = config.viewDescriptionIdentifier;
    }
    get pageSize() {
        var _a;
        return (_a = this._pageSize) !== null && _a !== void 0 ? _a : Infinity;
    }
    get timestampPath() {
        if (!this._timestampPath)
            throw Error("TimestampPath was not configured");
        return this._timestampPath;
    }
    instantiate(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startConnection();
            if (yield this.streamExists()) {
                const metadataStore = yield this.getStreamMetadata(); // Note: currently a single stream can only have one viewDescription!! -> TODO: overwrite getMetadata
                const mongoTSVD = new ldes_solid_server_1.MongoTSViewDescription(this.viewDescriptionIdentifier, this.streamIdentifier);
                const viewDescription = mongoTSVD.parseViewDescription(metadataStore);
                this._timestampPath = viewDescription.managedBy.bucketizeStrategy.path;
                if (viewDescription.managedBy.bucketizeStrategy.pageSize) {
                    this._pageSize = viewDescription.managedBy.bucketizeStrategy.pageSize;
                }
                else {
                    this._pageSize = Infinity;
                }
                this.logger.info(`View with description "${this.viewDescriptionIdentifier} for stream "${this.streamIdentifier}" exists already. timestampPath ${this.timestampPath} | pageSize ${this.pageSize}.`);
                return;
            }
            const { pageSize, timestampPath } = config;
            // Create metadata
            const viewDescription = this.createTSViewDescription(config);
            yield this.dbMetaCollection.insertOne({
                id: this.streamIdentifier,
                descriptionId: this.viewDescriptionIdentifier,
                type: ldes_snapshot_1.LDES.EventStream,
                value: (0, ldes_snapshot_1.storeToString)(viewDescription.getStore())
            });
            // extract metadata from config
            this._pageSize = pageSize !== null && pageSize !== void 0 ? pageSize : Infinity;
            this._timestampPath = timestampPath;
            this._metadata = viewDescription;
            const date = (_a = config.date) !== null && _a !== void 0 ? _a : new Date();
            // create root
            yield this.createBucket(this.root);
            // create first window
            const firstWindow = {
                identifier: date.valueOf() + '',
                start: date
            };
            yield this.createWindow(firstWindow);
            yield this.addWindowToRoot(firstWindow);
            this.logger.info(`Initialialise TS View. Time Series oldest relation: ${date.toISOString()} | timestampPath ${this.timestampPath} | pageSize ${this.pageSize}.`);
        });
    }
    getWindow(identifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = yield this.getBucket(identifier);
            if (!bucket) {
                throw Error(`Bucket with identifier "${identifier}" for stream ${this.streamIdentifier}} was not found in the database.`);
            }
            return this.fragmentToWindow(bucket);
        });
    }
    getMostRecentWindow() {
        return __awaiter(this, void 0, void 0, function* () {
            const mostRecentBucket = yield this.dbIndexCollection.find({ streamId: this.streamIdentifier }).sort({ "start": -1 }).limit(1).next();
            if (!mostRecentBucket) {
                throw Error("No buckets present");
            }
            return this.documentToWindow(mostRecentBucket);
        });
    }
    /**
     * Transforms a MongoDB document to a {@link Window}.
     * @param document
     * @returns
     */
    documentToWindow(document) {
        return {
            identifier: document.id,
            memberIdentifiers: document.members,
            start: new Date(document.start),
            end: new Date(document.start)
        };
    }
    fragmentToWindow(fragment) {
        const { id, members, start, end } = fragment;
        return {
            identifier: id,
            memberIdentifiers: members,
            start: start ? new Date(start) : undefined,
            end: end ? new Date(end) : undefined
        };
    }
    bucketSize(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = yield this.getBucket(window.identifier);
            if (!bucket.members)
                return 0; // though members should always exist
            return bucket.members.length;
        });
    }
    createWindow(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, start, end } = window;
            yield this.createBucket(identifier);
            const windowParams = {};
            if (start) {
                windowParams.start = start.toISOString();
            }
            if (end) {
                windowParams.end = end.toISOString();
            }
            yield this.dbIndexCollection.updateOne({
                streamId: this.streamIdentifier,
                id: identifier
            }, { "$set": windowParams });
        });
    }
    updateWindow(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, start, end } = window;
            const windowParams = {};
            if (start) {
                windowParams.start = start.toISOString();
            }
            if (end) {
                windowParams.end = end.toISOString();
            }
            yield this.dbIndexCollection.updateOne({
                streamId: this.streamIdentifier,
                id: identifier
            }, { "$set": windowParams });
        });
    }
    addWindowToRoot(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, start, end } = window;
            if (!start)
                throw Error("Can not add window " + identifier + " to the root as it has no start date value");
            yield this.addRelationsToBucket(this.root, [{
                    type: types_1.RelationType.GreaterThanOrEqualTo,
                    value: start.toISOString(),
                    path: this.timestampPath,
                    bucket: identifier
                }]);
            if (end) { // TODO: document
                yield this.addRelationsToBucket(this.root, [{
                        type: types_1.RelationType.LessThan,
                        value: end.toISOString(),
                        path: this.timestampPath,
                        bucket: identifier
                    }]);
            }
        });
    }
    append(member) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentWindow = yield this.getMostRecentWindow();
            const bucketSize = yield this.bucketSize(currentWindow);
            if (bucketSize + 1 > this.pageSize) {
                this.logger.debug('bucketSize: ' + bucketSize);
                this.logger.debug('pageSize: ' + this.pageSize);
                const memberDate = (0, ldes_snapshot_1.extractDate)(new n3_1.Store(member.quads), this.timestampPath);
                const newWindow = {
                    identifier: memberDate.valueOf() + '',
                    start: memberDate
                };
                // create new window
                yield this.createWindow(newWindow);
                yield this.addWindowToRoot(newWindow);
                // add end date to old window
                currentWindow.end = memberDate;
                yield this.updateWindow(currentWindow);
                yield this.addRelationsToBucket(this.root, [{
                        type: types_1.RelationType.LessThan,
                        value: memberDate.toISOString(),
                        path: this.timestampPath,
                        bucket: currentWindow.identifier
                    }]);
                // add member
                yield this.storeMember(member);
                yield this.addMemberstoBucket(newWindow.identifier, [member.id.value]);
            }
            else {
                // add member
                yield this.storeMember(member);
                yield this.addMemberstoBucket(currentWindow.identifier, [member.id.value]);
            }
        });
    }
    publish(members) {
        return __awaiter(this, void 0, void 0, function* () {
            // inefficient implementation
            for (const member of members) {
                yield this.append(member);
            }
        });
    }
    /**
     * Creates a TS Viewdescription that contains the metadata so the LDES Solid Server can serve the LDES.
     * @param config
     * @returns {ViewDescription}
     */
    createTSViewDescription(config) {
        const mongoTSVD = new ldes_solid_server_1.MongoTSViewDescription(this.viewDescriptionIdentifier, this.streamIdentifier);
        return mongoTSVD.generateViewDescription(config);
    }
}
exports.TSMongoDBIngestor = TSMongoDBIngestor;
