"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSMongoDBIngestorBTREE = void 0;
const TSMongoDBIngestor_1 = require("./TSMongoDBIngestor");
const types_1 = require("@treecg/types");
const uuid_1 = require("uuid");
const ldes_snapshot_1 = require("@treecg/ldes-snapshot");
const n3_1 = require("n3");
/**
 * Class which makes it possible to create multiple layers for the time-series.
 * (in contrast to the {@link TSMongoDBIngestor}, which only allows for having one layer)
 *
 * Basically it creates a B+TREE like fragmentation (not a true B+TREE yet -> see README.md
 */
class TSMongoDBIngestorBTREE extends TSMongoDBIngestor_1.TSMongoDBIngestor {
    constructor() {
        super(...arguments);
        /**
         * Variable for the number of relations per node in the view of the LDES.
         * Note: currently hardcoded
         * TODO: persist in meta
         */
        this.layerSize = 10;
    }
    append(member) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentWindow = yield this.getMostRecentWindow();
            const bucketSize = yield this.bucketSize(currentWindow);
            let windowIdentifierForMember = currentWindow.identifier;
            if (bucketSize + 1 > this.pageSize) {
                const memberDate = (0, ldes_snapshot_1.extractDate)(new n3_1.Store(member.quads), this.timestampPath);
                windowIdentifierForMember = yield this.addWindow(memberDate);
            }
            const window = yield this.getWindow(windowIdentifierForMember);
            const chain = yield this.getWindowChain(window);
            this.logger.debug(`Adding member ${member.id.value} to window ${windowIdentifierForMember}, placed in depth: ${chain.length}`);
            // add member
            yield this.storeMember(member);
            yield this.addMemberstoBucket(windowIdentifierForMember, [member.id.value]);
        });
    }
    /**
     * Searches for the most recent window.
     * Note: The node returned will be a leaf node.
     * @return {Promise<Window>}
     */
    getMostRecentWindow() {
        return __awaiter(this, void 0, void 0, function* () {
            const mostRecentBucket = yield this.dbIndexCollection.find({
                streamId: this.streamIdentifier,
                relations: []
            }).sort({ "start": -1 }).limit(1).next();
            if (!mostRecentBucket) {
                throw Error("No buckets present");
            }
            return this.documentToWindow(mostRecentBucket);
        });
    }
    /**
     * Creates a new window and adds it to the appropriate node.
     * Furthermore, adds the correct relations to this new node.
     *
     * @param date - The date to which all members in this new window will be GTE than.
     * @return {string} - The identifier of the newly created window.
     */
    addWindow(date) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentWindow = yield this.getMostRecentWindow();
            this.logger.debug('current most recent Window:' + currentWindow.identifier);
            // currently a list of Windows from root node -> ... -> window (top down chain of nodes)
            const chain = yield this.getWindowChain(currentWindow);
            const nodeForNewWindow = yield this.findNodeForNewWindow(chain);
            const nodeIdentifier = nodeForNewWindow.identifier;
            if (this.root === nodeIdentifier && this.uniqueNodes((yield this.getBucket(this.root)).relations) + 1 > this.layerSize) {
                const rootFragment = yield this.getBucket(this.root);
                const startDate = this.startDate(rootFragment.relations);
                this.logger.info(`A new layer is added as the root points to too many nodes: depth of tree: ${chain.length + 1} (layer size: ${this.layerSize} | amount of nodes from root: ${rootFragment.relations.length})`);
                const newNodeIdentifier = (0, uuid_1.v4)();
                const newWindowLayer = { identifier: newNodeIdentifier, start: startDate, end: date };
                // remove all relations from root: sameAs deleting and creating again (As nothing important is actually stored there (at least there shouldn't be)
                yield this.deleteBucket(this.root);
                yield this.createBucket(this.root);
                yield this.createWindow(newWindowLayer);
                // add all relations from root to the new layer
                const rootRelations = rootFragment.relations.map(({ type, value, path, bucket }) => {
                    return { type, value, path: path, bucket };
                });
                yield this.addRelationsToBucket(newNodeIdentifier, rootRelations);
                yield this.addWindowToRoot(newWindowLayer);
                // Create new window with the correct depth.
                const window = yield this.createChain(date, this.root, chain.length);
                return window.identifier;
            }
            const position = chain.indexOf(nodeForNewWindow);
            if (position === -1)
                throw Error("Could not find node in chain " + nodeIdentifier);
            for (const window of chain.slice(position + 1)) {
                // add end relation to window in the chain
                window.end = date;
                yield this.updateWindow(window);
                const parentWindow = yield this.getParentWindow(window); // could be optimised by just checking the previous index in the normal chain
                yield this.addRelationsToBucket(parentWindow.identifier, [{
                        type: types_1.RelationType.LessThan,
                        value: date.toISOString(),
                        path: this.timestampPath,
                        bucket: window.identifier
                    }]);
            }
            const window = yield this.createChain(date, nodeIdentifier, chain.length - (position + 1));
            return window.identifier;
        });
    }
    /**
     * Calculates the chain from the root to the window.
     *
     * Works bottom up.
     * Assumption: there are no two nodes with the same identifier within a stream.
     * @param window
     * @return {Promise<void>}
     */
    getWindowChain(window) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note: currently a shortcut to get the latest window chain
            const chain = [window];
            if (window.identifier === this.root) {
                return chain;
            }
            const parentWindow = yield this.getParentWindow(window);
            chain.unshift(...yield this.getWindowChain(parentWindow));
            return chain;
        });
    }
    /**
     * Find a node that has less relations than the maximum allowed number of relations.
     *
     * If no such is found, return the root.
     * @param chain
     * @return {Promise<void>}
     */
    findNodeForNewWindow(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const reverseChain = [...chain].reverse();
            // remove top window as this is one that is reserved to only have members
            reverseChain.shift();
            for (const window of reverseChain) {
                const fragment = yield this.getBucket(window.identifier);
                if (fragment.relations.length < this.layerSize) {
                    return window;
                }
            }
            this.logger.debug("No windows found: So root is returned.");
            return chain[0]; // this will always be the root
        });
    }
    /**
     * Creates a chain of nodes from identifier with given length, ending with the node `date.toISOString()`.
     *
     * Assumptions, the start node already exists.
     * @param date - The date to which all members in the bottom node will be GTE.
     * @param identifier - identifier of the node where the chain starts
     * @param chainLength - The length of the chain (i.e. how many nodes are created).
     * @return {Promise<void>}
     */
    createChain(date, identifier, chainLength) {
        return __awaiter(this, void 0, void 0, function* () {
            if (chainLength <= 0) {
                return yield this.getWindow(identifier);
            }
            const newNodeIdentifier = (0, uuid_1.v4)();
            const newWindowLayer = { identifier: newNodeIdentifier, start: date };
            yield this.createWindow(newWindowLayer);
            yield this.addRelationsToBucket(identifier, [{
                    type: types_1.RelationType.GreaterThanOrEqualTo,
                    bucket: newNodeIdentifier,
                    value: date.toISOString(),
                    path: this.timestampPath
                }]);
            return yield this.createChain(date, newNodeIdentifier, chainLength - 1);
        });
    }
    /**
     * TODO: docs
     * @param window
     * @return {Promise<Window>}
     */
    getParentWindow(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const parentFragment = yield this.dbIndexCollection.findOne({
                streamId: this.streamIdentifier,
                "relations.type": types_1.RelationType.GreaterThanOrEqualTo,
                "relations.value": new Date(window.start).toISOString(),
                "relations.path": this.timestampPath,
                "relations.bucket": window.identifier,
            });
            if (!parentFragment) {
                this.logger.info(`Parent not found: ${{
                    type: types_1.RelationType.GreaterThanOrEqualTo,
                    value: new Date(window.start).toISOString(),
                    path: this.timestampPath,
                    bucket: window.identifier
                }}`);
                throw Error(`No parent found for ${window.identifier}`);
            }
            return this.documentToWindow(parentFragment);
        });
    }
    /**
     * Calculates in an Array of relations the amount of unique nodes pointed to.
     * @param relations
     * @return {number}
     */
    uniqueNodes(relations) {
        const nodeSet = new Set(relations.map(({ bucket }) => bucket));
        return nodeSet.size;
    }
    /**
     * Calculates the lowest startDate from an Array of relations.
     * @param relations
     * @return {Date}
     */
    startDate(relations) {
        return relations
            .filter(({ type }) => {
            return type === types_1.RelationType.GreaterThanOrEqualTo;
        })
            .map(({ value }) => new Date(value))[0];
    }
}
exports.TSMongoDBIngestorBTREE = TSMongoDBIngestorBTREE;
