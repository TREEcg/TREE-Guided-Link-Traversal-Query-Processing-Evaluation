"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDBIngestor = void 0;
const types_1 = require("@treecg/types");
const mongodb_1 = require("mongodb");
const AbstractIngestor_1 = require("./AbstractIngestor");
const Util_1 = require("../util/Util");
const ldes_snapshot_1 = require("@treecg/ldes-snapshot");
class MongoDBIngestor extends AbstractIngestor_1.AbstractIngestor {
    constructor(config) {
        var _a, _b, _c, _d;
        super(config);
        this.mongoDBURL = (_a = config.mongoDBURL) !== null && _a !== void 0 ? _a : "mongodb://localhost:27017/ldes";
        this.metaCollectionName = (_b = config.metaCollectionName) !== null && _b !== void 0 ? _b : "meta";
        this.dataCollectionName = (_c = config.dataCollectionName) !== null && _c !== void 0 ? _c : "data";
        this.indexCollectionName = (_d = config.indexCollectionName) !== null && _d !== void 0 ? _d : "index";
    }
    get dbDataCollection() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL} while trying to use to the data Collection. Try \`initialise\` first.`);
        }
        return this.db.collection(this.dataCollectionName);
    }
    get dbIndexCollection() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL} while trying to use to the index Collection. Try \`initialise\` first.`);
        }
        return this.db.collection(this.indexCollectionName);
    }
    get dbMetaCollection() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL} while trying to use to the meta Collection. Try \`initialise\` first.`);
        }
        return this.db.collection(this.metaCollectionName);
    }
    get db() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL}. Try \`initialise\` first.`);
        }
        return this._db;
    }
    streamExists() {
        return __awaiter(this, void 0, void 0, function* () {
            const streamExists = yield this.dbMetaCollection.findOne({ id: this.streamIdentifier });
            if (streamExists)
                return true;
            return false;
        });
    }
    getStreamMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = yield this.dbMetaCollection.findOne({ id: this.streamIdentifier });
            if (!metadata)
                throw Error("does not exist yet");
            return yield (0, ldes_snapshot_1.turtleStringToStore)(metadata.value);
        });
    }
    startConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            this.mongoConnection = yield new mongodb_1.MongoClient(this.mongoDBURL).connect();
            this._db = this.mongoConnection.db();
        });
    }
    /**
     * Stores the metadata of the SDS stream into the Mongo Database in the meta collection.
     *
     * @param sdsMetadata - The SDS metadata for the SDS Stream.
     */
    initialise(sdsMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mongoConnection)
                yield this.startConnection();
            if (yield this.streamExists())
                return; // log that a stream already exists so must not be initialised
            if (!sdsMetadata)
                throw Error("No way to create SDS metadata, can be done later maybe.");
            yield this.dbMetaCollection.insertOne({ id: this.streamIdentifier, value: sdsMetadata, type: types_1.SDS.Stream }, {});
        });
    }
    exit() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`${new Date().toISOString()} [${this.constructor.name}] closing connection to the Mongo Database.`);
            yield ((_a = this.mongoConnection) === null || _a === void 0 ? void 0 : _a.close());
        });
    }
    /**
     * Stores members into the Mongo Database in the data collection.
     *
     * @param member
     * @param timestamp
     */
    storeMembers(member) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataElements = [];
            // todo: extract timestamp from data later by using the ldes:timestampPath from the sds:description
            member.forEach(member => {
                const id = member.id.value;
                const data = (0, Util_1.quadsToString)(member.quads);
                dataElements.push({ id, data });
            });
            yield this.dbDataCollection.insertMany(dataElements);
        });
    }
    /**
     * Stores a bucket into the Mongo Database in the index collection.
     *
     * @param bucketIdentifier
     */
    createBucket(bucketIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = {
                id: bucketIdentifier,
                streamId: this.streamIdentifier,
                leaf: true,
                relations: [],
                count: 0,
                members: []
            };
            yield this.dbIndexCollection.insertOne(bucket);
        });
    }
    /**
     * Remove a bucket from the Mongo Database in the index collection.
     * @param bucketIdentifier
     * @return {Promise<void>}
     */
    deleteBucket(bucketIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.dbIndexCollection.deleteMany({ streamId: this.streamIdentifier, id: bucketIdentifier });
        });
    }
    addMemberstoBucket(bucketIdentifier, memberIDs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.dbIndexCollection.updateOne({ id: bucketIdentifier, streamId: this.streamIdentifier }, { "$push": { members: { "$each": memberIDs } } });
        });
    }
    addRelationsToBucket(bucketIdentifier, relations) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: handle bucket in relation not existing
            // TODO: handle bucket itself not existing
            yield this.dbIndexCollection.updateOne({ id: bucketIdentifier, streamId: this.streamIdentifier }, { "$push": { relations: { "$each": relations } } });
        });
    }
    bucketExists(bucketIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = yield this.dbIndexCollection.findOne({ streamId: this.streamIdentifier, id: bucketIdentifier });
            if (exists) {
                return true;
            }
            return false;
        });
    }
    getBucket(bucketIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = yield this.dbIndexCollection.findOne({ streamId: this.streamIdentifier, id: bucketIdentifier });
            if (!bucket)
                throw Error("bucket does not exist");
            return bucket;
        });
    }
}
exports.MongoDBIngestor = MongoDBIngestor;
