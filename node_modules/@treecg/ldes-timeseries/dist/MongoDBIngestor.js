"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSMongoDBIngestor = exports.MongoDBIngestor = void 0;
const ldes_snapshot_1 = require("@treecg/ldes-snapshot");
const types_1 = require("@treecg/types");
const mongodb_1 = require("mongodb");
const n3_1 = require("n3");
const AbstractIngestor_1 = require("./AbstractIngestor");
const Util_1 = require("./util/Util");
const { namedNode, quad, blankNode, literal } = n3_1.DataFactory;
class MongoDBIngestor extends AbstractIngestor_1.AbstractIngestor {
    constructor(config) {
        var _a, _b, _c, _d;
        super(config);
        this.mongoDBURL = (_a = config.mongoDBURL) !== null && _a !== void 0 ? _a : "mongodb://localhost:27017/ldes";
        this.metaCollectionName = (_b = config.metaCollectionName) !== null && _b !== void 0 ? _b : "meta";
        this.dataCollectionName = (_c = config.dataCollectionName) !== null && _c !== void 0 ? _c : "data";
        this.indexCollectionName = (_d = config.indexCollectionName) !== null && _d !== void 0 ? _d : "index";
    }
    get dbDataCollection() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL} while trying to use to the data Collection. Try \`initialise\` first.`);
        }
        return this.db.collection(this.dataCollectionName);
    }
    get dbIndexCollection() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL} while trying to use to the index Collection. Try \`initialise\` first.`);
        }
        return this.db.collection(this.indexCollectionName);
    }
    get dbMetaCollection() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL} while trying to use to the meta Collection. Try \`initialise\` first.`);
        }
        return this.db.collection(this.metaCollectionName);
    }
    get db() {
        if (!this.mongoConnection) {
            throw Error(`Not connected to ${this.mongoDBURL}. Try \`initialise\` first.`);
        }
        return this._db;
    }
    streamExists() {
        return __awaiter(this, void 0, void 0, function* () {
            const streamExists = yield this.dbMetaCollection.findOne({ id: this.sdsStreamIdentifier });
            if (streamExists)
                return true;
            return false;
        });
    }
    getSDSMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = yield this.dbMetaCollection.findOne({ id: this.sdsStreamIdentifier });
            if (!metadata)
                throw Error("does not exist yet");
            return metadata.value;
        });
    }
    startConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            this.mongoConnection = yield new mongodb_1.MongoClient(this.mongoDBURL).connect();
            this._db = this.mongoConnection.db();
        });
    }
    /**
     * Stores the metadata of the SDS stream into the Mongo Database in the meta collection.
     *
     * @param sdsMetadata - The SDS metadata for the SDS Stream.
     */
    initialise(sdsMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mongoConnection)
                yield this.startConnection();
            if (yield this.streamExists())
                return; // log that a stream already exists so must not be initialised
            if (!sdsMetadata)
                throw Error("No way to create SDS metadata, can be done later maybe.");
            yield this.dbMetaCollection.insertOne({ id: this.sdsStreamIdentifier, value: sdsMetadata, type: types_1.SDS.Stream }, {});
        });
    }
    exit() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.mongoConnection) === null || _a === void 0 ? void 0 : _a.close());
        });
    }
    /**
     * Stores members into the Mongo Database in the data collection.
     *
     * @param member
     * @param timestamp
     */
    storeMembers(member) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataElements = [];
            // todo: extract timestamp from data later by using the ldes:timestampPath from the sds:description
            member.forEach(member => {
                const id = member.id.value;
                const data = (0, Util_1.quadsToString)(member.quads);
                dataElements.push({ id, data });
            });
            yield this.dbDataCollection.insertMany(dataElements);
        });
    }
    /**
     * Stores a bucket into the Mongo Database in the index collection.
     *
     * @param member
     * @param timestamp
     */
    createBucket(bucketIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = {
                id: bucketIdentifier,
                streamId: this.sdsStreamIdentifier,
                leaf: true,
                relations: [],
                count: 0,
                members: []
            };
            yield this.dbIndexCollection.insertOne(bucket);
        });
    }
    addMemberstoBucket(bucketIdentifier, memberIDs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.dbIndexCollection.updateOne({ id: bucketIdentifier, streamId: this.sdsStreamIdentifier }, { "$push": { members: { "$each": memberIDs } } });
        });
    }
    addRelationsToBucket(bucketIdentifier, relations) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: handle bucket in relation not existing
            // TODO: handle bucket itself not existing
            yield this.dbIndexCollection.updateOne({ id: bucketIdentifier, streamId: this.sdsStreamIdentifier }, { "$push": { relations: { "$each": relations } } });
        });
    }
    bucketExists(bucketIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = yield this.dbIndexCollection.findOne({ streamId: this.sdsStreamIdentifier, id: bucketIdentifier });
            if (exists) {
                return true;
            }
            return false;
        });
    }
}
exports.MongoDBIngestor = MongoDBIngestor;
class TSMongoDBIngestor extends MongoDBIngestor {
    constructor() {
        super(...arguments);
        this.root = "";
        this.logger = new ldes_snapshot_1.Logger(this);
    }
    get pageSize() {
        var _a;
        return (_a = this._pageSize) !== null && _a !== void 0 ? _a : Infinity;
    }
    get timestampPath() {
        if (!this._timestampPath)
            throw Error("TimestampPath was not configured");
        return this._timestampPath;
    }
    makeSDSConfig(config) {
        const { sdsStreamIdentifier, timestampPath, pageSize } = config;
        const dataSetNode = namedNode("http://example.org/sds#dataset");
        const sdsMetadataStore = new n3_1.Store();
        sdsMetadataStore.addQuad(namedNode(sdsStreamIdentifier), types_1.RDF.terms.type, types_1.SDS.terms.Stream);
        sdsMetadataStore.addQuad(namedNode(sdsStreamIdentifier), types_1.SDS.terms.carries, types_1.SDS.terms.Member);
        sdsMetadataStore.addQuad(namedNode(sdsStreamIdentifier), types_1.SDS.terms.dataset, dataSetNode);
        sdsMetadataStore.addQuad(dataSetNode, types_1.RDF.terms.type, ldes_snapshot_1.LDES.terms.EventStream);
        sdsMetadataStore.addQuad(dataSetNode, ldes_snapshot_1.LDES.terms.timestampPath, namedNode(timestampPath));
        if (pageSize) {
            sdsMetadataStore.addQuad(dataSetNode, ldes_snapshot_1.LDES.terms.pageSize, literal(pageSize));
        }
        return (0, ldes_snapshot_1.storeToString)(sdsMetadataStore);
    }
    // initializes a LDES-TS if it does not exist yet.
    // Otherwise, just starts up the database
    instantiate(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startConnection();
            if (yield this.streamExists()) {
                const metadata = yield this.getSDSMetadata();
                const metadataStore = yield (0, ldes_snapshot_1.turtleStringToStore)(metadata);
                const ldesNode = metadataStore.getQuads(this.sdsStreamIdentifier, types_1.SDS.terms.dataset, null, null)[0].object;
                this._timestampPath = metadataStore.getQuads(ldesNode, ldes_snapshot_1.LDES.timestampPath, null, null)[0].object.value;
                const pageSizeExists = metadataStore.getQuads(ldesNode, ldes_snapshot_1.LDES.pageSize, null, null)[0];
                if (pageSizeExists) {
                    this._pageSize = Number(pageSizeExists.object.value);
                }
                else {
                    this._pageSize = Infinity;
                }
                this.logger.info(`SDS exists already. timestampPath ${this.timestampPath} | pageSize ${this.pageSize}.`);
                return;
            }
            const { pageSize, timestampPath } = config;
            const sdsMetadata = this.makeSDSConfig(config);
            yield this.initialise(sdsMetadata);
            // extract metadata from config
            this._pageSize = pageSize !== null && pageSize !== void 0 ? pageSize : Infinity;
            this._timestampPath = timestampPath;
            this._metadata = sdsMetadata;
            const date = (_a = config.date) !== null && _a !== void 0 ? _a : new Date();
            // create root
            yield this.createBucket(this.root);
            // create first window
            const firstWindow = {
                identifier: date.valueOf() + '',
                start: date
            };
            yield this.createWindow(firstWindow);
            yield this.addWindowToRoot(firstWindow);
            this.logger.info(`Initialialise SDS. Time Series oldest relation: ${date.toISOString()} | timestampPath ${this.timestampPath} | pageSize ${this.pageSize}.`);
        });
    }
    getMostRecentWindow() {
        return __awaiter(this, void 0, void 0, function* () {
            const mostRecentBucket = yield this.dbIndexCollection.find({ streamId: this.sdsStreamIdentifier }).sort({ "start": -1 }).limit(1).next();
            if (!mostRecentBucket) {
                throw Error("No buckets present");
            }
            return this.documentToWindow(mostRecentBucket);
        });
    }
    /**
     * Transforms a MongoDB document to a {@link Window}.
     * @param document
     * @returns
     */
    documentToWindow(document) {
        return {
            identifier: document.id,
            memberIdentifiers: document.members,
            start: new Date(document.start),
            end: new Date(document.start)
        };
    }
    bucketSize(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = yield this.dbIndexCollection.findOne({ id: window.identifier, streamId: this.sdsStreamIdentifier });
            if (!bucket) {
                throw Error("Window with identifier " + window.identifier + " was not found in the database");
            }
            return bucket.members.length;
        });
    }
    createWindow(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, start, end } = window;
            yield this.createBucket(identifier);
            const windowParams = {};
            if (start) {
                windowParams.start = start.toISOString();
            }
            if (end) {
                windowParams.end = end.toISOString();
            }
            yield this.dbIndexCollection.updateOne({ streamId: this.sdsStreamIdentifier, id: identifier }, { "$set": windowParams });
        });
    }
    updateWindow(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, start, end } = window;
            const windowParams = {};
            if (start) {
                windowParams.start = start.toISOString();
            }
            if (end) {
                windowParams.end = end.toISOString();
            }
            yield this.dbIndexCollection.updateOne({ streamId: this.sdsStreamIdentifier, id: identifier }, { "$set": windowParams });
        });
    }
    addWindowToRoot(window) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, start } = window;
            if (!start)
                throw Error("Can not add window " + identifier + " to the root as it has no start date value");
            yield this.addRelationsToBucket(this.root, [{
                    type: types_1.RelationType.GreaterThanOrEqualTo,
                    value: start.toISOString(),
                    path: this.timestampPath,
                    bucket: identifier
                }]);
        });
    }
    append(member) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentWindow = yield this.getMostRecentWindow();
            const bucketSize = yield this.bucketSize(currentWindow);
            if (bucketSize + 1 > this.pageSize) {
                const memberDate = (0, ldes_snapshot_1.extractDate)(new n3_1.Store(member.quads), this.timestampPath);
                const newWindow = {
                    identifier: memberDate.valueOf() + '',
                    start: memberDate
                };
                // create new window
                yield this.createWindow(newWindow);
                yield this.addWindowToRoot(newWindow);
                // add end date to old window
                currentWindow.end = memberDate;
                yield this.updateWindow(currentWindow);
                yield this.addRelationsToBucket(this.root, [{
                        type: types_1.RelationType.LessThan,
                        value: memberDate.toISOString(),
                        path: this.timestampPath,
                        bucket: currentWindow.identifier
                    }]);
            }
            else {
                yield this.storeMember(member);
                yield this.addMemberstoBucket(currentWindow.identifier, [member.id.value]);
            }
        });
    }
    publish(members) {
        return __awaiter(this, void 0, void 0, function* () {
            // inefficient implementation
            for (const member of members) {
                yield this.append(member);
            }
        });
    }
}
exports.TSMongoDBIngestor = TSMongoDBIngestor;
