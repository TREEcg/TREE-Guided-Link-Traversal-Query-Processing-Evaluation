"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotTransform = void 0;
/***************************************
 * Title: SnapshotTransform
 * Description: Transforms a Member stream to a stream of materialized Members at a given snapshot time.
 * Author: Wout Slabbinck (wout.slabbinck@ugent.be)
 * Created on 07/03/2022
 *****************************************/
var stream_1 = require("stream");
var n3_1 = require("n3");
var version_materialize_rdf_js_1 = require("@treecg/version-materialize-rdf.js");
var SnapshotUtil_1 = require("./util/SnapshotUtil");
var Logger_1 = require("./logging/Logger");
var Conversion_1 = require("./util/Conversion");
var namedNode = n3_1.DataFactory.namedNode;
var SnapshotMetadataParser_1 = require("./metadata/SnapshotMetadataParser");
var Vocabularies_1 = require("./util/Vocabularies");
var SnapshotTransform = /** @class */ (function (_super) {
    __extends(SnapshotTransform, _super);
    /**
     *
     * @param options parameters for creating the snapshot
     * @param snapshotStore (optional) a snapshot Store (can be used to create an incremental snapshot on top of an existing one)
     */
    function SnapshotTransform(options, snapshotStore) {
        var _this = _super.call(this, { objectMode: true, highWaterMark: 1000 }) || this;
        _this.logger = new Logger_1.Logger(_this);
        if (!options.versionOfPath)
            throw new Error("No versionOfPath was given in options");
        if (!options.timestampPath)
            throw new Error("No timestampPath was given in options");
        _this.transformedMap = new Map();
        _this.versionTimeMap = new Map();
        _this.date = options.date ? options.date : new Date();
        _this.snapshotIdentifier = options.snapshotIdentifier ? options.snapshotIdentifier : "".concat(options.ldesIdentifier, "Snapshot");
        _this.ldesIdentifier = options.ldesIdentifier;
        _this.versionOfPath = options.versionOfPath;
        _this.timestampPath = options.timestampPath;
        _this.materialized = options.materialized ? options.materialized : false;
        // create metadata for the snapshot
        _this.metadataStore = (0, SnapshotUtil_1.createSnapshotMetadata)({
            date: _this.date,
            snapshotIdentifier: _this.snapshotIdentifier,
            ldesIdentifier: _this.ldesIdentifier,
            versionOfPath: _this.versionOfPath,
            timestampPath: _this.timestampPath,
            materialized: _this.materialized
        });
        _this.emitedMetadata = false;
        if (snapshotStore) {
            var snapshotOf = snapshotStore.getQuads(null, Vocabularies_1.LDES.snapshotOf, _this.ldesIdentifier, null);
            if (snapshotOf.length !== 1)
                throw new Error("Given snapshot does not point to the given LDES.");
            var snapshotMetadata = SnapshotMetadataParser_1.SnapshotMetadataParser.extractSnapshotMetadata(snapshotStore, snapshotOf[0].subject.value);
            for (var _i = 0, _a = snapshotMetadata.members; _i < _a.length; _i++) {
                var member = _a[_i];
                _this.processMember(member);
            }
        }
        return _this;
    }
    SnapshotTransform.prototype._transform = function (chunk, _enc, done) {
        // called each member
        if (!this.emitedMetadata) {
            this.emit('metadata', this.metadataStore.getQuads(null, null, null, null));
            this.emitedMetadata = true;
        }
        try {
            this.processMember(chunk);
        }
        catch (e) {
            if ((0, SnapshotUtil_1.isMember)(chunk)) {
                this.logger.info("Following member could not be transformed: ".concat(chunk.id.value));
            }
            else {
                this.logger.info('item in stream was not a member: ' + chunk);
            }
            console.log(e);
        }
        done();
    };
    SnapshotTransform.prototype._flush = function () {
        var _this = this;
        // called at the end
        if (!this.emitedMetadata) {
            this.emit('metadata', this.metadataStore.getQuads(null, null, null, null));
            this.emitedMetadata = true;
        }
        this.transformedMap.forEach(function (value, key) {
            //Note: can be wrong if not all subjects of the quads are the same id
            // -> could be solved in a more thorough isMember test before processing the members
            _this.push({ id: value[0].subject, quads: value });
        });
        this.push(null);
    };
    SnapshotTransform.prototype.processMember = function (member) {
        var objectIdentifier = this.extractObjectIdentifier(member);
        if (this.transformedMap.has(objectIdentifier)) {
            var versionPresentTime = this.versionTimeMap.get(objectIdentifier);
            var currentTime = this.extractDate(member);
            // dateTime must be more recent than the one already present and not more recent than the snapshotDate
            if (currentTime.getTime() <= this.date.getTime() && versionPresentTime.getTime() < currentTime.getTime()) {
                this.transformedMap.set(objectIdentifier, this.transform(member));
                this.versionTimeMap.set(objectIdentifier, currentTime);
            }
        }
        else {
            // first time for given version-object
            var transformed = this.transform(member);
            var date = this.extractDate(member);
            if (date.getTime() <= this.date.getTime()) {
                this.transformedMap.set(objectIdentifier, transformed);
                this.versionTimeMap.set(objectIdentifier, date);
            }
        }
    };
    SnapshotTransform.prototype.transform = function (member) {
        var transformedTriples;
        if (this.materialized) {
            // transform quads to triples
            transformedTriples = this.materialize(member);
        }
        else {
            transformedTriples = member.quads;
        }
        return transformedTriples;
    };
    /**
     * Extracts the timestamp from a member (which is a version-object).
     * note: only handles xsd:dateTime
     * @param member a {@link Member}
     * @returns {string}
     */
    SnapshotTransform.prototype.extractDate = function (member) {
        var store = new n3_1.Store(member.quads);
        try {
            return (0, SnapshotUtil_1.extractDate)(store, this.timestampPath);
        }
        catch (e) {
            var dateTimeLiterals = store.getObjects(member.id, namedNode(this.timestampPath), null);
            throw Error("Found ".concat(dateTimeLiterals.length, " dateTime literals following the timestamp path of ").concat(member.id.value, "; expected one such literal."));
        }
    };
    /**
     * Extracts the object Identifier from a member (which is a version-object).
     * @param member a non-materialized {@link Member}
     * @returns {string}
     */
    SnapshotTransform.prototype.extractObjectIdentifier = function (member) {
        var store = new n3_1.Store(member.quads);
        try {
            return (0, SnapshotUtil_1.extractObjectIdentifier)(store, this.versionOfPath);
        }
        catch (e) {
            var versionIds = store.getObjects(member.id, namedNode(this.versionOfPath), null);
            throw Error("Found ".concat(versionIds.length, " identifiers following the version paths of ").concat(member.id.value, "; expected one such identifier."));
        }
    };
    SnapshotTransform.prototype.materialize = function (member) {
        var materializedQuads = (0, version_materialize_rdf_js_1.materialize)(member.quads, {
            versionOfProperty: namedNode(this.versionOfPath),
            timestampProperty: namedNode(this.timestampPath)
        });
        return (0, Conversion_1.makeTriples)(materializedQuads, {
            objectIdentifier: this.extractObjectIdentifier(member),
            timestampPath: this.timestampPath
        });
    };
    return SnapshotTransform;
}(stream_1.Transform));
exports.SnapshotTransform = SnapshotTransform;
