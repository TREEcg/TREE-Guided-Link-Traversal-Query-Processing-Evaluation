"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LDESStore = void 0;
const community_server_1 = require("@solid/community-server");
const types_1 = require("@treecg/types");
const Vocabularies_1 = require("@treecg/types/dist/lib/Vocabularies");
const utils_1 = require("./util/utils");
const n3_1 = require("n3");
const Vocabulary_1 = require("./util/Vocabulary");
const { namedNode, quad, blankNode, literal } = n3_1.DataFactory;
/**
 * ResourceStore which uses {@link PrefixView} for backend access.
 *
 * The LDESStore provides read operations for the resources which are retrieved using the view of the PrefixView.
 *
 * There are two types of requests that can be executed:
 *  * Base request: A request to read all views stored in all databases,
 *  * Fragment request: A request to a fragment within a specific view.
 *
 */
class LDESStore {
    /**
     * @param id - The URI of the published LDES.
     * @param views - The mounted views that expose this LDES.
     * @param base - The base URI for the Solid Server.
     * @param relativePath - The relative path to the LDES.
     */
    constructor(id, views, base, relativePath) {
        this.logger = (0, community_server_1.getLoggerFor)(this);
        this.getRepresentation = async (identifier, preferences, conditions) => {
            this.logger.info("Get representation");
            await this.initPromise;
            if ((0, community_server_1.ensureTrailingSlash)(identifier.path) === this.base) {
                // We got a base request, let's announce all mounted view
                const quads = await this.getViewDescriptions();
                return new community_server_1.BasicRepresentation((0, community_server_1.guardedStreamFrom)(quads), new community_server_1.RepresentationMetadata(this.getMetadata({ pub: true, immutable: true })));
            }
            const view = this.views.find((pv) => identifier.path.indexOf(pv.prefix) >= 0);
            if (!view) {
                this.logger.info("No LDES view found for identifier " + identifier.path);
                throw new community_server_1.NotFoundHttpError("No LDES found!");
            }
            let idStart = identifier.path.indexOf(view.prefix) + view.prefix.length;
            // pesky trailing slashes
            if (identifier.path.charAt(idStart) == "/") {
                idStart += 1;
            }
            const baseIdentifier = identifier.path.substring(0, idStart);
            let bucketIdentifier = identifier.path.substring(idStart);
            const fragment = await view.view.getFragment(bucketIdentifier);
            const quads = [];
            if (view.view.getRoot() === identifier.path) {
                quads.push(...await view.view.getMetadata(this.id));
                quads.push(quad(namedNode(this.id), types_1.TREE.terms.view, namedNode(identifier.path)));
            }
            quads.push(quad(namedNode(identifier.path), Vocabularies_1.RDF.terms.type, types_1.TREE.terms.custom("Node")));
            const relations = await fragment.getRelations();
            const members = await fragment.getMembers();
            relations.forEach(relation => this.addRelations(quads, identifier.path, baseIdentifier, relation));
            members.forEach(m => this.addMember(quads, m));
            return new community_server_1.BasicRepresentation((0, community_server_1.guardedStreamFrom)(quads), new community_server_1.RepresentationMetadata(this.getMetadata(await fragment.getCacheDirectives())));
        };
        this.setRepresentation = async (identifier, representation, conditions) => {
            console.log("Set representation", identifier, representation, conditions);
            throw "Not implemented set";
        };
        this.addResource = async (container, representation, conditions) => {
            console.log("Add representation", container, representation, conditions);
            throw "Not implemented add";
        };
        this.deleteResource = async (identifier, conditions) => {
            console.log("Delete representation", identifier, conditions);
            throw "Not implemented delete";
        };
        this.modifyResource = async (identifier, patch, conditions) => {
            console.log("Modify representation", identifier, patch, conditions);
            throw "Not implemented modify";
        };
        this.hasResource = async (_id, _conditions) => {
            return false;
        };
        this.id = id;
        this.base = (0, community_server_1.ensureTrailingSlash)(base + (0, community_server_1.trimLeadingSlashes)(relativePath));
        this.views = views;
        this.initPromise = Promise.all(views.map(async (view) => view.view.init(this.base, view.prefix)));
        this.logger.info(`The LDES descriptions can be found at ${this.base}`);
        console.log(`The LDES descriptions can be found at ${this.base}`);
        this.logger.info(`Mounting ${this.views.length} LDES views ${this.views.map(x => x.prefix).join(", ")}`);
        console.log(`Mounting ${this.views.length} LDES views ${this.views.map(x => x.prefix).join(", ")}`);
    }
    async getViewDescriptions() {
        const quads = [];
        for (let view of this.views) {
            quads.push(...await view.view.getMetadata(this.id));
            const mRoot = view.view.getRoot();
            if (mRoot) {
                quads.push(quad(namedNode(this.id), types_1.TREE.terms.view, namedNode(mRoot)));
            }
        }
        return quads;
    }
    getMetadata(cache) {
        if (!cache)
            return { [community_server_1.CONTENT_TYPE]: community_server_1.INTERNAL_QUADS };
        const cacheLit = (0, utils_1.cacheToLiteral)(cache);
        return { [Vocabulary_1.HTTP.cache_control]: literal(cacheLit), [community_server_1.CONTENT_TYPE]: community_server_1.INTERNAL_QUADS };
    }
    addRelations(quads, identifier, baseIdentifier, relation) {
        const bn = blankNode();
        quads.push(quad(namedNode(identifier), types_1.TREE.terms.relation, bn));
        quads.push(quad(bn, Vocabularies_1.RDF.terms.type, namedNode(relation.type)));
        quads.push(quad(bn, types_1.TREE.terms.node, namedNode(baseIdentifier + relation.nodeId)));
        if (relation.path)
            quads.push(quad(bn, types_1.TREE.terms.path, relation.path));
        if (relation.value)
            relation.value.forEach(value => quads.push(quad(bn, types_1.TREE.terms.value, value)));
    }
    addMember(quads, member) {
        quads.push(quad(namedNode(this.id), types_1.TREE.terms.member, member.id));
        quads.push(...member.quads);
    }
}
exports.LDESStore = LDESStore;
//# sourceMappingURL=LDESStore.js.map