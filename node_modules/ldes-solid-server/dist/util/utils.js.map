{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/util/utils.ts"],"names":[],"mappings":";;;AAGA,SAAgB,cAAc,CAAC,WAA4B;IACvD,MAAM,GAAG,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;IACvD,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAC3E,MAAM,SAAS,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAE7D,OAAO,CAAC,GAAG,GAAG,EAAE,GAAG,MAAM,EAAE,GAAG,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACxD,CAAC;AAND,wCAMC;AAGD,SAAgB,UAAU,CAAC,KAAa;IACpC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC5C,MAAM,KAAK,GAAgC,EAAE,CAAC;IAE9C,IAAI,MAAM,EAAE;QACR,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YAC1B,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACrC,KAAK,CAAC,GAAG,CAAC,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAA;KACL;IAED,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;QACnB,OAAO,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC;KAC9B;IACD,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC;AAC7C,CAAC;AAfD,gCAeC;AAED,SAAgB,gBAAgB,CAAC,EAAE,IAAI,EAAE,KAAK,EAAU;IACpD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC5B,MAAM,OAAO,GAAG,EAAE,CAAC;IAEnB,KAAK,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QAC5C,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,CAAC,CAAC;KACnC;IAED,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;QACpB,OAAO,SAAS,CAAC,GAAG,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;KACpD;SAAM;QACH,OAAO,IAAI,CAAC;KACf;AACL,CAAC;AAbD,4CAaC","sourcesContent":["\nimport { CacheDirectives } from \"@treecg/types\";\n\nexport function cacheToLiteral(instruction: CacheDirectives): string {\n    const pub = instruction.pub ? [\"public\"] : [\"private\"];\n    const maxAge = instruction.maxAge ? [\"max-age=\" + instruction.maxAge] : [];\n    const immutable = instruction.immutable ? [\"immutable\"] : [];\n\n    return [...pub, ...maxAge, ...immutable].join(\", \");\n}\n\nexport type Parsed = { segs: string[], query: { [label: string]: string } };\nexport function parseIndex(index: string): Parsed {\n    const [first, second] = index.split('?', 2);\n    const query: { [label: string]: string } = {};\n\n    if (second) {\n        second.split(\"&\").forEach(q => {\n            const [key, value] = q.split(\"=\", 2);\n            query[key] = decodeURIComponent(value);\n        })\n    }\n\n    if (first.length == 0) {\n        return { segs: [], query };\n    }\n    return { segs: first.split(\"/\"), query };\n}\n\nexport function reconstructIndex({ segs, query }: Parsed): string {\n    const path = segs.join(\"/\");\n    const queries = [];\n\n    for (let [key, value] of Object.entries(query)) {\n        queries.push(`${key}=${value}`);\n    }\n\n    if (queries.length > 0) {\n        return encodeURI(`${path}?${queries.join(\"&\")}`);\n    } else {\n        return path;\n    }\n}\n"]}