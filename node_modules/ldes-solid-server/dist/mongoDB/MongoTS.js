"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoTSView = void 0;
const community_server_1 = require("@solid/community-server");
const types_1 = require("@treecg/types");
const n3_1 = require("n3");
const MongoTSViewDescription_1 = require("../ldes/viewDescription/MongoTSViewDescription");
const { namedNode, quad, literal } = n3_1.DataFactory;
class MongoTSFragment {
    constructor(members, relations, collection) {
        this.collection = collection;
        this.members = members;
        this.relations = relations;
    }
    async getMembers() {
        return await this.collection.find({ id: { $in: this.members } })
            .map(row => {
            return { id: namedNode(row.id), quads: new n3_1.Parser().parse(row.data) };
        })
            .toArray();
    }
    async getRelations() {
        return this.relations;
    }
    async getCacheDirectives() {
        return { pub: true };
    }
}
class MongoTSView {
    constructor(db, streamId, descriptionId) {
        this.logger = (0, community_server_1.getLoggerFor)(this);
        this.dbConfig = db;
        this.streamId = streamId;
        this.descriptionId = descriptionId;
    }
    async init(base, prefix) {
        this.db = await this.dbConfig.db();
        this.metaCollection = this.db.collection(this.dbConfig.meta);
        this.indexCollection = this.db.collection(this.dbConfig.index);
        this.dataCollection = this.db.collection(this.dbConfig.data);
        this.root = base + (0, community_server_1.ensureTrailingSlash)((0, community_server_1.trimTrailingSlashes)(prefix));
    }
    /**
     * The URL of the view of the LDES.
     * @returns {string}
     */
    getRoot() {
        return this.root;
    }
    async getMetadata(ldes) {
        const quads = [];
        const query = { "type": types_1.LDES.EventStream, "id": this.streamId };
        const meta = await this.metaCollection.findOne(query);
        if (meta) {
            const metaStore = new n3_1.Store(new n3_1.Parser().parse(meta.value));
            const mongoTSVD = new MongoTSViewDescription_1.MongoTSViewDescription(this.descriptionId, ldes, this.root);
            const viewDescription = mongoTSVD.parseViewDescription(metaStore);
            quads.push(...viewDescription.quads());
        }
        else {
            console.log(`No ViewDescription found for`, this.descriptionId);
            console.log(`tried following search query: `, query);
        }
        quads.push(quad(namedNode(ldes), types_1.RDF.terms.type, types_1.LDES.terms.EventStream));
        quads.push(quad(namedNode(this.getRoot()), types_1.RDF.terms.type, types_1.TREE.terms.custom("Node"))); // TODO: verify if this makes sense
        return quads;
    }
    async getFragment(identifier) {
        this.logger.info(`Looking for fragment with id "${identifier}" in the Mongo Database. (streamID: "${this.streamId}")`);
        console.log(`Looking for fragment with id "${identifier}" in the Mongo Database. (streamID: "${this.streamId}")`);
        const members = [];
        const relations = [];
        const search = { streamId: this.streamId, id: identifier, leaf: true };
        const dbFragment = await this.indexCollection.find(search).sort({ "timeStamp": -1 }).limit(1).next();
        if (!dbFragment) {
            this.logger.error("No such bucket found! " + JSON.stringify(search));
            console.log("No such bucket found! " + JSON.stringify(search));
        }
        else {
            members.push(...dbFragment.members || []);
            const rels = dbFragment.relations.map(({ type, value, bucket, path }) => {
                const values = [literal(value)];
                return { type: type, value: values, nodeId: bucket, path: namedNode(path) };
            });
            relations.push(...rels);
        }
        return new MongoTSFragment(members, relations, this.dataCollection);
    }
}
exports.MongoTSView = MongoTSView;
//# sourceMappingURL=MongoTS.js.map