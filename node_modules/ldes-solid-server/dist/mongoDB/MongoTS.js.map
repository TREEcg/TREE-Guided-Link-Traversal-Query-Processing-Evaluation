{"version":3,"file":"MongoTS.js","sourceRoot":"","sources":["../../src/mongoDB/MongoTS.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as Rdf from '@rdfjs/types';\nimport {ensureTrailingSlash, getLoggerFor, trimTrailingSlashes,} from '@solid/community-server';\nimport {CacheDirectives, LDES, Member, RDF, RelationParameters, RelationType, TREE} from \"@treecg/types\";\nimport {Collection, Db, Filter} from \"mongodb\";\nimport {DataFactory, Parser, Store} from \"n3\";\n\nimport {View} from \"../ldes/View\";\nimport {Fragment} from \"../ldes/Fragment\";\nimport {DBConfig} from \"./MongoDBConfig\";\nimport {DataCollectionDocument, IndexCollectionDocument, MetaCollectionDocument} from \"./MongoCollectionTypes\";\nimport {MongoTSViewDescription} from \"../ldes/viewDescription/MongoTSViewDescription\";\n\nconst {namedNode, quad, literal} = DataFactory;\n\nclass MongoTSFragment implements Fragment {\n    members: string[];\n    relations: RelationParameters[];\n    collection: Collection<DataCollectionDocument>;\n\n    constructor(members: string[], relations: RelationParameters[], collection: Collection<DataCollectionDocument>) {\n        this.collection = collection;\n        this.members = members;\n        this.relations = relations;\n    }\n\n    async getMembers(): Promise<Member[]> {\n        return await this.collection.find({id: {$in: this.members}})\n            .map(row => {\n                return <Member>{id: namedNode(row.id), quads: new Parser().parse(row.data)}\n            })\n            .toArray();\n    }\n\n    async getRelations(): Promise<RelationParameters[]> {\n        return this.relations;\n    }\n\n    async getCacheDirectives(): Promise<CacheDirectives> {\n        return {pub: true};\n    }\n}\n\nexport class MongoTSView implements View {\n    protected readonly logger = getLoggerFor(this);\n\n    dbConfig: DBConfig;\n    db!: Db;\n    metaCollection!: Collection<MetaCollectionDocument>;\n    indexCollection!: Collection<IndexCollectionDocument>;\n    dataCollection!: Collection<DataCollectionDocument>;\n    root!: string;\n\n    descriptionId: string;\n    streamId: string;\n\n\n    constructor(db: DBConfig, streamId: string, descriptionId: string) {\n        this.dbConfig = db;\n        this.streamId = streamId;\n        this.descriptionId = descriptionId;\n    }\n\n    async init(base: string, prefix: string): Promise<void> {\n        this.db = await this.dbConfig.db();\n        this.metaCollection = this.db.collection(this.dbConfig.meta);\n        this.indexCollection = this.db.collection(this.dbConfig.index);\n        this.dataCollection = this.db.collection(this.dbConfig.data);\n\n        this.root = base + ensureTrailingSlash(trimTrailingSlashes(prefix));\n    }\n\n    /**\n     * The URL of the view of the LDES.\n     * @returns {string}\n     */\n    getRoot(): string {\n        return this.root;\n    }\n\n    async getMetadata(ldes: string): Promise<Rdf.Quad[]> {\n        const quads = []\n        const query = {\"type\": LDES.EventStream, \"id\": this.streamId}\n        const meta = await this.metaCollection.findOne(query);\n        if (meta) {\n            const metaStore = new Store(new Parser().parse(meta.value))\n            const mongoTSVD = new MongoTSViewDescription(this.descriptionId, ldes, this.root);\n            const viewDescription = mongoTSVD.parseViewDescription(metaStore)\n            quads.push(...viewDescription.quads());\n        } else {\n            console.log(`No ViewDescription found for`, this.descriptionId)\n            console.log(`tried following search query: `, query)\n        }\n\n        quads.push(quad(namedNode(ldes), RDF.terms.type, LDES.terms.EventStream));\n        quads.push(quad(namedNode(this.getRoot()), RDF.terms.type, TREE.terms.custom(\"Node\"))); // TODO: verify if this makes sense\n        return quads;\n    }\n\n    async getFragment(identifier: string): Promise<Fragment> {\n        this.logger.info(`Looking for fragment with id \"${identifier}\" in the Mongo Database. (streamID: \"${this.streamId}\")`);\n        console.log(`Looking for fragment with id \"${identifier}\" in the Mongo Database. (streamID: \"${this.streamId}\")`)\n        const members = [] as string[];\n        const relations = <RelationParameters[]>[];\n        const search: Filter<IndexCollectionDocument> = {streamId: this.streamId, id: identifier, leaf: true};\n\n        const dbFragment = await this.indexCollection.find(search).sort({\"timeStamp\": -1}).limit(1).next();\n        if (!dbFragment) {\n            this.logger.error(\"No such bucket found! \" + JSON.stringify(search));\n            console.log(\"No such bucket found! \" + JSON.stringify(search));\n        } else {\n            members.push(...dbFragment.members || []);\n\n            const rels: RelationParameters[] = dbFragment!.relations.map(({type, value, bucket, path}) => {\n                const values: Rdf.Term[] = [literal(value)];\n                return {type: <RelationType>type, value: values, nodeId: bucket, path: namedNode(path)};\n            });\n\n            relations.push(...rels);\n        }\n        return new MongoTSFragment(members, relations, this.dataCollection);\n    }\n}\n\n"]}