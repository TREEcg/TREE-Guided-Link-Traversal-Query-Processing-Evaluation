"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoSDSView = void 0;
const community_server_1 = require("@solid/community-server");
const types_1 = require("@treecg/types");
const n3_1 = require("n3");
const utils_1 = require("../util/utils");
const DCAT = (0, community_server_1.createUriAndTermNamespace)("http://www.w3.org/ns/dcat#", "endpointURL", "servesDataset");
const { namedNode, quad, blankNode, literal } = n3_1.DataFactory;
class MongoSDSFragment {
    constructor(members, relations, collection) {
        this.collection = collection;
        this.members = members;
        this.relations = relations;
    }
    async getMembers() {
        return await this.collection.find({ id: { $in: this.members } })
            .map(row => { return { id: namedNode(row.id), quads: new n3_1.Parser().parse(row.data) }; })
            .toArray();
    }
    async getRelations() {
        return this.relations;
    }
    async getCacheDirectives() {
        return { pub: true };
    }
}
class MongoSDSView {
    constructor(db, streamId, descriptionId) {
        this.logger = (0, community_server_1.getLoggerFor)(this);
        this.dbConfig = db;
        this.streamId = streamId;
        this.descriptionId = descriptionId;
    }
    async init(base, prefix) {
        this.db = await this.dbConfig.db();
        this.metaCollection = this.db.collection(this.dbConfig.meta);
        this.indexCollection = this.db.collection(this.dbConfig.index);
        this.dataCollection = this.db.collection(this.dbConfig.data);
        this.root = [base.replace(/^\/|\/$/g, ""), prefix.replace(/^\/|\/$/g, "")].join("/");
    }
    getRoot() {
        return this.root;
    }
    async getMetadata(ldes) {
        const quads = [];
        const blankId = this.descriptionId ? namedNode(this.descriptionId) : blankNode();
        quads.push(quad(blankId, types_1.RDF.terms.type, types_1.TREE.terms.custom("ViewDescription")), quad(blankId, DCAT.terms.endpointURL, namedNode(this.getRoot())), quad(blankId, DCAT.terms.servesDataset, namedNode(ldes)));
        const stream = await this.metaCollection.findOne({ "type": types_1.SDS.Stream, "id": this.streamId });
        if (stream) {
            quads.push(quad(blankId, types_1.LDES.terms.custom("managedBy"), namedNode(this.streamId)));
            quads.push(...new n3_1.Parser().parse(stream.value));
        }
        return quads;
    }
    async getFragment(identifier) {
        const { segs, query } = (0, utils_1.parseIndex)(identifier);
        this.logger.error("ERROR ME");
        this.logger.info(`Getting fragment for segs ${segs} query ${query}`);
        console.log(`Getting fragment for segs ${JSON.stringify(segs)} query ${JSON.stringify(query)}`);
        // [a,b,c] => [[a], [a,b], [a,b,c]]
        const indices = segs.reduce((cum, _, i, arr) => [...cum, arr.slice(0, i + 1)], []);
        const timestampValue = query["timestamp"];
        const members = [];
        const relations = [];
        // Look for members and relations in path to leaf
        for (let i = 0; i < indices.length; i++) {
            const id = indices[i].join("/");
            const fragment = await this.indexCollection.findOne({ streamId: this.streamId, id, leaf: false });
            if (!fragment)
                continue;
            const rels = fragment.relations.map(({ type, value, bucket, path }) => {
                const values = [literal(value)];
                const index = { segs: segs.slice(), query: {} };
                index.segs[i] = bucket;
                return { type: type, value: values, nodeId: (0, utils_1.reconstructIndex)(index), path: namedNode(path) };
            });
            relations.push(...rels);
            members.push(...fragment.members || []);
        }
        const id = segs.join("/");
        const search = { streamId: this.streamId, id, leaf: true };
        if (timestampValue)
            search.timeStamp = { "$lte": timestampValue };
        const actualTimestampBucket = await this.indexCollection.find(search).sort({ "timeStamp": -1 }).limit(1).next();
        if (!actualTimestampBucket) {
            this.logger.error("No such bucket found! " + JSON.stringify(search));
        }
        else {
            members.push(...actualTimestampBucket.members || []);
            const rels = actualTimestampBucket.relations.map(({ type, value, bucket, path }) => {
                const index = { segs, query };
                index.query["timestamp"] = bucket;
                const values = [literal(value)];
                return { type: type, value: values, nodeId: (0, utils_1.reconstructIndex)(index), path: namedNode(path) };
            });
            relations.push(...rels);
        }
        return new MongoSDSFragment(members, relations, this.dataCollection);
    }
}
exports.MongoSDSView = MongoSDSView;
//# sourceMappingURL=MongoSDS.js.map