{"version":3,"file":"MongoSDS.js","sourceRoot":"","sources":["../../src/mongoDB/MongoSDS.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport {createUriAndTermNamespace, getLoggerFor} from '@solid/community-server';\nimport {CacheDirectives, LDES, Member, RDF as RDFT, RelationParameters, RelationType, SDS, TREE} from \"@treecg/types\";\nimport {Collection, Db, Filter} from \"mongodb\";\nimport {DataFactory, Parser} from \"n3\";\nimport {View} from \"../ldes/View\";\nimport {Parsed, parseIndex, reconstructIndex} from '../util/utils';\nimport {DBConfig} from \"./MongoDBConfig\";\nimport {DataCollectionDocument, IndexCollectionDocument, MetaCollectionDocument} from \"./MongoCollectionTypes\";\nimport {Fragment} from \"../ldes/Fragment\";\n\nconst DCAT = createUriAndTermNamespace(\"http://www.w3.org/ns/dcat#\", \"endpointURL\", \"servesDataset\");\nconst { namedNode, quad, blankNode, literal } = DataFactory;\n\nclass MongoSDSFragment implements Fragment {\n  members: string[];\n  relations: RelationParameters[];\n  collection: Collection<DataCollectionDocument>;\n  constructor(members: string[], relations: RelationParameters[], collection: Collection<DataCollectionDocument>) {\n    this.collection = collection;\n    this.members = members;\n    this.relations = relations;\n  }\n\n  async getMembers(): Promise<Member[]> {\n    return await this.collection.find({ id: { $in: this.members } })\n      .map(row => { return <Member>{ id: namedNode(row.id), quads: new Parser().parse(row.data) } })\n      .toArray();\n  }\n\n  async getRelations(): Promise<RelationParameters[]> {\n    return this.relations;\n  }\n\n  async getCacheDirectives(): Promise<CacheDirectives> {\n    return { pub: true };\n  }\n}\n\nexport class MongoSDSView implements View {\n  protected readonly logger = getLoggerFor(this);\n\n  dbConfig: DBConfig;\n  db!: Db;\n  metaCollection!: Collection<MetaCollectionDocument>;\n  indexCollection!: Collection<IndexCollectionDocument>;\n  dataCollection!: Collection<DataCollectionDocument>;\n  root!: string;\n\n  descriptionId?: string;\n  streamId: string;\n\n\n  constructor(db: DBConfig, streamId: string, descriptionId?: string) {\n    this.dbConfig = db;\n    this.streamId = streamId;\n    this.descriptionId = descriptionId;\n  }\n\n  async init(base: string, prefix: string): Promise<void> {\n    this.db = await this.dbConfig.db();\n    this.metaCollection = this.db.collection(this.dbConfig.meta);\n    this.indexCollection = this.db.collection(this.dbConfig.index);\n    this.dataCollection = this.db.collection(this.dbConfig.data);\n\n    this.root = [base.replace(/^\\/|\\/$/g, \"\"), prefix.replace(/^\\/|\\/$/g, \"\")].join(\"/\");\n  }\n\n  getRoot(): string {\n    return this.root;\n  }\n\n  async getMetadata(ldes: string): Promise<RDF.Quad[]> {\n    const quads = [];\n    const blankId = this.descriptionId ? namedNode(this.descriptionId) : blankNode();\n    quads.push(\n      quad(blankId, RDFT.terms.type, TREE.terms.custom(\"ViewDescription\")),\n      quad(blankId, DCAT.terms.endpointURL, namedNode(this.getRoot())),\n      quad(blankId, DCAT.terms.servesDataset, namedNode(ldes)),\n    );\n\n    const stream = await this.metaCollection.findOne({ \"type\": SDS.Stream, \"id\": this.streamId });\n    if (stream) {\n      quads.push(\n        quad(blankId, LDES.terms.custom(\"managedBy\"), namedNode(this.streamId)),\n      );\n\n      quads.push(...new Parser().parse(stream.value));\n    }\n\n    return quads;\n  }\n\n  async getFragment(identifier: string): Promise<Fragment> {\n    const { segs, query } = parseIndex(identifier);\n\n    this.logger.error(\"ERROR ME\");\n    this.logger.info(`Getting fragment for segs ${segs} query ${query}`);\n    console.log(`Getting fragment for segs ${JSON.stringify(segs)} query ${JSON.stringify(query)}`);\n\n    // [a,b,c] => [[a], [a,b], [a,b,c]]\n    const indices = segs.reduce((cum, _, i, arr) => [...cum, arr.slice(0, i + 1)], <string[][]>[]);\n    const timestampValue = query[\"timestamp\"];\n    const members = [] as string[];\n    const relations = <RelationParameters[]>[];\n\n    // Look for members and relations in path to leaf\n    for (let i = 0; i < indices.length; i++) {\n      const id = indices[i].join(\"/\");\n\n      const fragment = await this.indexCollection.findOne({ streamId: this.streamId, id, leaf: false });\n      if (!fragment) continue;\n\n      const rels: RelationParameters[] = fragment!.relations.map(({ type, value, bucket, path }) => {\n        const values: RDF.Term[] = [literal(value)];\n\n        const index: Parsed = { segs: segs.slice(), query: {} };\n        index.segs[i] = bucket;\n\n        return { type: <RelationType>type, value: values, nodeId: reconstructIndex(index), path: namedNode(path) };\n      });\n\n      relations.push(...rels);\n      members.push(...fragment.members || []);\n    }\n\n    const id = segs.join(\"/\");\n    const search: Filter<IndexCollectionDocument> = { streamId: this.streamId, id, leaf: true };\n\n    if (timestampValue)\n      search.timeStamp = { \"$lte\": timestampValue };\n\n    const actualTimestampBucket = await this.indexCollection.find(search).sort({ \"timeStamp\": -1 }).limit(1).next();\n    if (!actualTimestampBucket) {\n      this.logger.error(\"No such bucket found! \" + JSON.stringify(search));\n    } else {\n      members.push(...actualTimestampBucket.members || []);\n\n      const rels: RelationParameters[] = actualTimestampBucket!.relations.map(({ type, value, bucket, path }) => {\n        const index: Parsed = { segs, query };\n        index.query[\"timestamp\"] = bucket;\n        const values: RDF.Term[] = [literal(value)];\n\n        return { type: <RelationType>type, value: values, nodeId: reconstructIndex(index), path: namedNode(path) };\n      });\n\n      relations.push(...rels);\n    }\n\n    return new MongoSDSFragment(members, relations, this.dataCollection);\n  }\n}\n\n"]}