import { NamedNode } from '@rdfjs/types';
declare type RecordOf<TKey extends any[], TValue> = Record<TKey[number], TValue>;
export declare type Namespace<TKey extends any[], TValue, IValue> = {
    namespace: TValue;
    custom: (input: IValue) => TValue;
} & RecordOf<TKey, TValue>;
/**
 * Creates a function that expands local names from the given base URI,
 * and exports the given local names as properties on the returned object.
 */
export declare function createNamespace<TKey extends string, TValue, IValue extends string>(baseUri: string, toValue: (expanded: string) => TValue, ...localNames: TKey[]): Namespace<typeof localNames, TValue, IValue>;
/**
 * Creates a function that expands local names from the given base URI into strings,
 * and exports the given local names as properties on the returned object.
 */
export declare function createUriNamespace<T extends string>(baseUri: string, ...localNames: T[]): Namespace<typeof localNames, string, string>;
/**
 * Creates a function that expands local names from the given base URI into named nodes,
 * and exports the given local names as properties on the returned object.
 */
export declare function createTermNamespace<T extends string>(baseUri: string, ...localNames: T[]): Namespace<typeof localNames, NamedNode, string>;
/**
 * Creates a function that expands local names from the given base URI into string,
 * and exports the given local names as properties on the returned object.
 * Under the `terms` property, it exposes the expanded local names as named nodes.
 */
export declare function createUriAndTermNamespace<T extends string>(baseUri: string, ...localNames: T[]): Namespace<typeof localNames, string, string> & {
    terms: Namespace<typeof localNames, NamedNode, string>;
};
export declare const DC: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("description" | "modified" | "title")[], string> & {
    terms: Namespace<("description" | "modified" | "title")[], NamedNode<string>, string>;
};
export declare const FOAF: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<"Agent"[], string> & {
    terms: Namespace<"Agent"[], NamedNode<string>, string>;
};
export declare const RDF: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("type" | "nil" | "rest" | "first")[], string> & {
    terms: Namespace<("type" | "nil" | "rest" | "first")[], NamedNode<string>, string>;
};
export declare const XSD: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("string" | "integer" | "dateTime")[], string> & {
    terms: Namespace<("string" | "integer" | "dateTime")[], NamedNode<string>, string>;
};
export declare const TREE: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("search" | "path" | "node" | "value" | "Collection" | "member" | "view" | "relation" | "GreaterThanOrEqualRelation" | "shape" | "ConditionalImport" | "import" | "importStream" | "remainingItems" | "zoom" | "latitudeTile" | "longitudeTile")[], string> & {
    terms: Namespace<("search" | "path" | "node" | "value" | "Collection" | "member" | "view" | "relation" | "GreaterThanOrEqualRelation" | "shape" | "ConditionalImport" | "import" | "importStream" | "remainingItems" | "zoom" | "latitudeTile" | "longitudeTile")[], NamedNode<string>, string>;
};
export declare const LDES: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("EventStream" | "timestampPath" | "versionOfPath" | "DurationAgoPolicy" | "Bucketization" | "retentionPolicy" | "amount" | "bucket" | "bucketProperty" | "bucketType" | "LatestVersionSubset" | "BucketizeStrategy")[], string> & {
    terms: Namespace<("EventStream" | "timestampPath" | "versionOfPath" | "DurationAgoPolicy" | "Bucketization" | "retentionPolicy" | "amount" | "bucket" | "bucketProperty" | "bucketType" | "LatestVersionSubset" | "BucketizeStrategy")[], NamedNode<string>, string>;
};
export declare const SDS: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("stream" | "relation" | "shape" | "bucket" | "Member" | "Record" | "ImmutableMember" | "carries" | "dataset" | "Stream" | "payload" | "relationType" | "relationBucket" | "relationValue" | "relationPath")[], string> & {
    terms: Namespace<("stream" | "relation" | "shape" | "bucket" | "Member" | "Record" | "ImmutableMember" | "carries" | "dataset" | "Stream" | "payload" | "relationType" | "relationBucket" | "relationValue" | "relationPath")[], NamedNode<string>, string>;
};
export declare const PROV: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("used" | "startedAtTime" | "wasGeneratedBy")[], string> & {
    terms: Namespace<("used" | "startedAtTime" | "wasGeneratedBy")[], NamedNode<string>, string>;
};
export declare const PPLAN: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<"Activity"[], string> & {
    terms: Namespace<"Activity"[], NamedNode<string>, string>;
};
export declare const SHACL: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<("path" | "NodeShape" | "targetClass" | "property" | "datatype" | "nodeKind" | "minCount" | "maxCount")[], string> & {
    terms: Namespace<("path" | "NodeShape" | "targetClass" | "property" | "datatype" | "nodeKind" | "minCount" | "maxCount")[], NamedNode<string>, string>;
};
export declare const EX: {
    namespace: string;
    custom: (input: string) => string;
} & RecordOf<string[], string> & {
    terms: Namespace<string[], NamedNode<string>, string>;
};
export {};
