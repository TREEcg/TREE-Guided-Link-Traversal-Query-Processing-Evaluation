"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSparql = toSparql;

var _rdfString = require("@tpluscode/rdf-string");

var _path = require("./path.cjs");

class ToSparqlPropertyPath extends _path.PathVisitor {
  visitSequencePath({
    paths
  }, {
    isRoot = true
  } = {}) {
    const sequence = paths.reduce(this.pathChain('/'), (0, _rdfString.sparql)``);

    if (isRoot) {
      return sequence;
    }

    return (0, _rdfString.sparql)`(${sequence})`;
  }

  visitInversePath({
    path: inversed
  }) {
    return (0, _rdfString.sparql)`^${inversed.accept(this, {
      isRoot: false
    })}`;
  }

  visitAlternativePath({
    paths
  }, {
    isRoot = true
  } = {}) {
    const alternative = paths.reduce(this.pathChain('|'), (0, _rdfString.sparql)``);

    if (isRoot) {
      return alternative;
    }

    return (0, _rdfString.sparql)`(${alternative})`;
  }

  visitZeroOrMorePath({
    path: inner
  }) {
    return (0, _rdfString.sparql)`${inner.accept(this, {
      isRoot: false
    })}*`;
  }

  visitOneOrMorePath({
    path: inner
  }) {
    return (0, _rdfString.sparql)`${inner.accept(this, {
      isRoot: false
    })}+`;
  }

  visitZeroOrOnePath({
    path: inner
  }) {
    return (0, _rdfString.sparql)`${inner.accept(this, {
      isRoot: false
    })}?`;
  }

  visitPredicatePath({
    term: predicate
  }) {
    return (0, _rdfString.sparql)`${predicate}`;
  }

  pathChain(operator) {
    return (previous, current, index) => {
      if (index === 0) {
        return current.accept(this, {
          isRoot: false
        });
      }

      return (0, _rdfString.sparql)`${previous}${operator}${current.accept(this, {
        isRoot: false
      })}`;
    };
  }

}
/**
 * Creates a SPARQL template string which represents a SHACL path as Property Path
 *
 * @param path SHACL Property Path
 */


function toSparql(path) {
  const visitor = new ToSparqlPropertyPath();
  return visitor.visit((0, _path.fromNode)(path));
}
/**
 * Splits a Sequence Path and returns an array of SPARQL template results.
 * If the path is not a Sequence Path, returns an array with a single element
 *
 * @param path SHACL Property Path
 */


toSparql.sequence = path => {
  (0, _path.assertWellFormedPath)(path);
  const list = path.list();

  if (list) {
    return [...list].map(el => toSparql(el));
  }

  return [toSparql(path)];
};