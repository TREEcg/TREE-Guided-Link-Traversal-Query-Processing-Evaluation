"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromNode = fromNode;
exports.assertWellFormedPath = assertWellFormedPath;
exports.ZeroOrOnePath = exports.OneOrMorePath = exports.ZeroOrMorePath = exports.InversePath = exports.AlternativePath = exports.SequencePath = exports.PredicatePath = exports.ShaclPropertyPath = exports.PathVisitor = void 0;

var _rdfNsBuilders = require("@tpluscode/rdf-ns-builders");

class PathVisitor {
  visit(path, arg) {
    if (path instanceof PredicatePath) {
      return this.visitPredicatePath(path, arg);
    }

    if (path instanceof SequencePath) {
      return this.visitSequencePath(path, arg);
    }

    if (path instanceof AlternativePath) {
      return this.visitAlternativePath(path, arg);
    }

    if (path instanceof InversePath) {
      return this.visitInversePath(path, arg);
    }

    if (path instanceof ZeroOrMorePath) {
      return this.visitZeroOrMorePath(path, arg);
    }

    if (path instanceof OneOrMorePath) {
      return this.visitOneOrMorePath(path, arg);
    }

    if (path instanceof ZeroOrOnePath) {
      return this.visitZeroOrOnePath(path, arg);
    }

    throw new Error('Unexpected path');
  }

}

exports.PathVisitor = PathVisitor;

class ShaclPropertyPath {}

exports.ShaclPropertyPath = ShaclPropertyPath;

class PredicatePath extends ShaclPropertyPath {
  constructor(term) {
    super();
    this.term = term;
  }

  accept(visitor, arg) {
    return visitor.visitPredicatePath(this, arg);
  }

}

exports.PredicatePath = PredicatePath;

class SequencePath extends ShaclPropertyPath {
  constructor(paths) {
    super();
    this.paths = paths;
  }

  accept(visitor, arg) {
    return visitor.visitSequencePath(this, arg);
  }

}

exports.SequencePath = SequencePath;

class AlternativePath extends ShaclPropertyPath {
  constructor(paths) {
    super();
    this.paths = paths;
  }

  accept(visitor, arg) {
    return visitor.visitAlternativePath(this, arg);
  }

}

exports.AlternativePath = AlternativePath;

class InversePath extends ShaclPropertyPath {
  constructor(path) {
    super();
    this.path = path;
  }

  accept(visitor, arg) {
    return visitor.visitInversePath(this, arg);
  }

}

exports.InversePath = InversePath;

class ZeroOrMorePath extends ShaclPropertyPath {
  constructor(path) {
    super();
    this.path = path;
  }

  accept(visitor, arg) {
    return visitor.visitZeroOrMorePath(this, arg);
  }

}

exports.ZeroOrMorePath = ZeroOrMorePath;

class OneOrMorePath extends ShaclPropertyPath {
  constructor(path) {
    super();
    this.path = path;
  }

  accept(visitor, arg) {
    return visitor.visitOneOrMorePath(this, arg);
  }

}

exports.OneOrMorePath = OneOrMorePath;

class ZeroOrOnePath extends ShaclPropertyPath {
  constructor(path) {
    super();
    this.path = path;
  }

  accept(visitor, arg) {
    return visitor.visitZeroOrOnePath(this, arg);
  }

}

exports.ZeroOrOnePath = ZeroOrOnePath;

function fromNode(path) {
  if ('termType' in path) {
    return new PredicatePath(path);
  }

  assertWellFormedPath(path);

  if (path.term.termType === 'NamedNode') {
    return new PredicatePath(path.term);
  }

  const sequence = path.list();

  if (sequence) {
    const paths = [...sequence];
    assertWellFormedShaclList(paths);
    return new SequencePath(paths.map(fromNode));
  }

  if (path.term.termType === 'BlankNode') {
    const inversePath = path.out(_rdfNsBuilders.sh.inversePath);

    if (inversePath.term) {
      return new InversePath(fromNode(inversePath));
    }

    const alternativePath = path.out(_rdfNsBuilders.sh.alternativePath);

    if (alternativePath.term) {
      const list = [...(alternativePath.list() || [])];
      assertWellFormedShaclList(list);
      return new AlternativePath(list.map(fromNode));
    }

    const zeroOrMorePath = path.out(_rdfNsBuilders.sh.zeroOrMorePath);

    if (zeroOrMorePath.term) {
      return new ZeroOrMorePath(fromNode(zeroOrMorePath));
    }

    const oneOrMorePath = path.out(_rdfNsBuilders.sh.oneOrMorePath);

    if (oneOrMorePath.term) {
      return new OneOrMorePath(fromNode(oneOrMorePath));
    }

    const zeroOrOnePath = path.out(_rdfNsBuilders.sh.zeroOrOnePath);

    if (zeroOrOnePath.term) {
      return new ZeroOrOnePath(fromNode(zeroOrOnePath));
    }
  }

  throw new Error(`Unrecognized property path ${path.value}`);
}

function assertWellFormedPath(ptr) {
  if (!ptr.term) {
    throw new Error('SHACL Path must be single node');
  }
}

function assertWellFormedShaclList(list) {
  if (list.length < 2) {
    throw new Error('SHACL List must have at least 2 elements');
  }
}