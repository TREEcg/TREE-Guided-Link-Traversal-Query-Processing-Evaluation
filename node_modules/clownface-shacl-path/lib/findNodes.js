import TermSet from '@rdf-esm/term-set';
import * as Path from "./path.js";

class FindNodesVisitor extends Path.PathVisitor {
  visitSequencePath(_ref, _ref2) {
    var {
      paths
    } = _ref;
    var {
      pointer
    } = _ref2;
    return paths.reduce((previous, path) => {
      return pointer.node(path.accept(this, {
        pointer: previous
      }));
    }, pointer).terms;
  }

  visitInversePath(_ref3, _ref4) {
    var {
      path
    } = _ref3;
    var {
      pointer
    } = _ref4;

    if (path instanceof Path.PredicatePath) {
      return pointer.in(path.term).terms;
    }

    throw new Error('Only inverse of Predicate Paths is implemented');
  }

  visitAlternativePath(_ref5, arg) {
    var {
      paths
    } = _ref5;
    return paths.flatMap(path => {
      return path.accept(this, arg);
    });
  }

  visitZeroOrOnePath(_ref6, _ref7) {
    var {
      path
    } = _ref6;
    var {
      pointer
    } = _ref7;
    return [...pointer.terms, ...path.accept(this, {
      pointer
    })];
  }

  visitOneOrMorePath(path, _ref8) {
    var {
      pointer
    } = _ref8;
    return this.greedyPath(path, pointer);
  }

  visitZeroOrMorePath(path, _ref9) {
    var {
      pointer
    } = _ref9;
    return [...pointer.terms, ...this.greedyPath(path, pointer)];
  }

  greedyPath(_ref10, pointer) {
    var {
      path
    } = _ref10;
    var remaining = [...pointer.terms];
    var results = new TermSet();
    var current = remaining.pop();

    while (current) {
      var nextNodes = path.accept(this, {
        pointer: pointer.node(current)
      });

      for (var nextNode of nextNodes) {
        if (!results.has(nextNode)) {
          remaining.push(nextNode);
          results.add(nextNode);
        }
      }

      current = remaining.pop();
    }

    return [...results];
  }

  visitPredicatePath(_ref11, _ref12) {
    var {
      term
    } = _ref11;
    var {
      pointer
    } = _ref12;
    return pointer.out(term).terms;
  }

}
/**
 * Finds all nodes connected to the input node by following a [SHACL Property Path](https://www.w3.org/TR/shacl/#dfn-shacl-property-path)
 *
 * @param pointer starting node
 * @param shPath SHACL Property Path
 */


export function findNodes(pointer, shPath) {
  var path = 'termType' in shPath ? pointer.node(shPath) : shPath;
  var terms = new FindNodesVisitor().visit(Path.fromNode(path), {
    pointer
  });
  return pointer.node([...new TermSet(terms)]);
}