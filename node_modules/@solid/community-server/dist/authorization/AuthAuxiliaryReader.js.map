{"version":3,"file":"AuthAuxiliaryReader.js","sourceRoot":"","sources":["../../src/authorization/AuthAuxiliaryReader.ts"],"names":[],"mappings":";;;AAEA,gDAAkD;AAClD,6DAAkE;AAElE,iDAA6C;AAE7C,yDAAsD;AACtD,+DAAsD;AAItD;;;;;;;GAOG;AACH,MAAa,mBAAoB,SAAQ,mCAAgB;IAMvD,YAAmB,MAAwB,EAAE,YAA+B;QAC1E,KAAK,EAAE,CAAC;QANS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAO7C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,WAAW,EAAyB;QACxE,gCAAgC;QAChC,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC;QAEvD,yEAAyE;QACzE,MAAM,UAAU,GAAG,IAAA,gBAAM,EAAC,IAAI,qCAAqB,CAAC,cAAc,CAAC,EACjE,EAAE,GAAG,EAAE,OAAO,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACrD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,cAAc,EAAE,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;QAEzF,oEAAoE;QACpE,KAAK,MAAM,CAAE,UAAU,EAAE,CAAE,OAAO,CAAE,CAAC,IAAI,OAAO,EAAE;YAChD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,OAAO,CAAC,IAAI,8CAA8C,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YAC1G,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SAChF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,CAAE,QAAQ,CAAC,SAAoB;QACpC,KAAK,MAAM,CAAE,UAAU,CAAE,IAAI,SAAS,EAAE;YACtC,IAAI,IAAI,CAAC,YAAY,CAAC,qBAAqB,CAAC,UAAU,CAAC,EAAE;gBACvD,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBACnE,0EAA0E;gBAC1E,MAAM,CAAE,UAAU,EAAE,CAAE,OAAO,EAAE,IAAI,GAAG,CAAC,CAAE,uBAAO,CAAC,OAAO,CAA6B,CAAC,CAAE,CAAC,CAAC;aAC3F;SACF;IACH,CAAC;IAED;;;OAGG;IACO,gBAAgB,CAAC,UAA8B,EAAE,gBAA+B,EAAE;QAC1F,MAAM,OAAO,GAAkB,EAAE,CAAC;QAClC,KAAK,MAAM,CAAE,KAAK,EAAE,WAAW,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAA6C,EAAE;YAC9G,MAAM,EAAE,OAAO,EAAE,GAAG,WAAW,CAAC;YAChC,OAAO,CAAC,KAAK,CAAC,GAAG;gBACf,IAAI,EAAE,OAAO;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,OAAO;gBACd,OAAO;aACS,CAAC;SACpB;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;CACF;AA3DD,kDA2DC","sourcesContent":["import type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { IdentifierSetMultiMap } from '../util/map/IdentifierMap';\nimport type { MapEntry } from '../util/map/MapUtil';\nimport { modify } from '../util/map/MapUtil';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport { AclMode } from './permissions/AclPermission';\nimport type { AclPermission } from './permissions/AclPermission';\nimport type { AccessMap, AccessMode, PermissionMap, PermissionSet } from './permissions/Permissions';\n\n/**\n * Determines the permission for authorization resources (such as ACL or ACR).\n * In contrast to the regular resource mechanism, read/write access to authorization resources\n * is obtained by setting Control permissions on the corresponding subject resource\n * rather than directly setting permissions for the authorization resource itself.\n * Hence, this class transforms Control permissions on the subject resource\n * to Read/Write permissions on the authorization resource.\n */\nexport class AuthAuxiliaryReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly reader: PermissionReader;\n  private readonly authStrategy: AuxiliaryStrategy;\n\n  public constructor(reader: PermissionReader, authStrategy: AuxiliaryStrategy) {\n    super();\n    this.reader = reader;\n    this.authStrategy = authStrategy;\n  }\n\n  public async handle({ requestedModes, credentials }: PermissionReaderInput): Promise<PermissionMap> {\n    // Finds all the ACL identifiers\n    const authMap = new Map(this.findAuth(requestedModes));\n\n    // Replaces the ACL identifies with the corresponding subject identifiers\n    const updatedMap = modify(new IdentifierSetMultiMap(requestedModes),\n      { add: authMap.values(), remove: authMap.keys() });\n    const result = await this.reader.handleSafe({ requestedModes: updatedMap, credentials });\n\n    // Extracts the permissions based on the subject control permissions\n    for (const [ identifier, [ subject ]] of authMap) {\n      this.logger.debug(`Mapping ${subject.path} control permission to all permissions for ${identifier.path}`);\n      result.set(identifier, this.interpretControl(identifier, result.get(subject)));\n    }\n    return result;\n  }\n\n  /**\n   * Finds all authorization resource identifiers and maps them to their subject identifier and the requested modes.\n   */\n  private* findAuth(accessMap: AccessMap): Iterable<[ResourceIdentifier, MapEntry<AccessMap>]> {\n    for (const [ identifier ] of accessMap) {\n      if (this.authStrategy.isAuxiliaryIdentifier(identifier)) {\n        const subject = this.authStrategy.getSubjectIdentifier(identifier);\n        // Unfortunately there is no enum inheritance so we have to cast like this\n        yield [ identifier, [ subject, new Set([ AclMode.control ] as unknown as AccessMode[]) ]];\n      }\n    }\n  }\n\n  /**\n   * Updates the permissions for an authorization resource\n   * by interpreting the Control access mode as allowing full access.\n   */\n  protected interpretControl(identifier: ResourceIdentifier, permissionSet: PermissionSet = {}): PermissionSet {\n    const authSet: PermissionSet = {};\n    for (const [ group, permissions ] of Object.entries(permissionSet) as [ keyof PermissionSet, AclPermission ][]) {\n      const { control } = permissions;\n      authSet[group] = {\n        read: control,\n        append: control,\n        write: control,\n        control,\n      } as AclPermission;\n    }\n    return authSet;\n  }\n}\n"]}