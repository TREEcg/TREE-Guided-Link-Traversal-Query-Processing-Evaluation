{"version":3,"file":"PermissionBasedAuthorizer.js","sourceRoot":"","sources":["../../src/authorization/PermissionBasedAuthorizer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { CredentialSet } from '../authentication/Credentials';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { ResourceSet } from '../storage/ResourceSet';\nimport { ForbiddenHttpError } from '../util/errors/ForbiddenHttpError';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { UnauthorizedHttpError } from '../util/errors/UnauthorizedHttpError';\nimport type { AuthorizerInput } from './Authorizer';\nimport { Authorizer } from './Authorizer';\nimport type { PermissionSet } from './permissions/Permissions';\nimport { AccessMode } from './permissions/Permissions';\n\n/**\n * Authorizer that bases its decision on the output it gets from its PermissionReader.\n * For each permission it checks if the reader allows that for at least one credential type,\n * if yes authorization is granted.\n * `undefined` values for reader results are interpreted as `false`.\n */\nexport class PermissionBasedAuthorizer extends Authorizer {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly resourceSet: ResourceSet;\n\n  /**\n   * The existence of the target resource determines the output status code for certain situations.\n   * The provided {@link ResourceSet} will be used for that.\n   * @param resourceSet - {@link ResourceSet} that can verify the target resource existence.\n   */\n  public constructor(resourceSet: ResourceSet) {\n    super();\n    this.resourceSet = resourceSet;\n  }\n\n  public async handle(input: AuthorizerInput): Promise<void> {\n    const { credentials, requestedModes, availablePermissions } = input;\n\n    // Ensure all required modes are within the agent's permissions.\n    for (const [ identifier, modes ] of requestedModes.entrySets()) {\n      const modeString = [ ...modes ].join(',');\n      this.logger.debug(`Checking if ${credentials.agent?.webId} has ${modeString} permissions for ${identifier.path}`);\n      const permissions = availablePermissions.get(identifier) ?? {};\n      for (const mode of modes) {\n        try {\n          this.requireModePermission(credentials, permissions, mode);\n        } catch (error: unknown) {\n          await this.reportAccessError(identifier, modes, permissions, error);\n        }\n      }\n      this.logger.debug(`${JSON.stringify(credentials)} has ${modeString} permissions for ${identifier.path}`);\n    }\n  }\n\n  /**\n   * If we know the operation will return a 404 regardless (= resource does not exist and is not being created),\n   * and the agent is allowed to know about its existence (= the agent has Read permissions),\n   * then immediately send the 404 here, as it makes any other agent permissions irrelevant.\n   *\n   * Otherwise, deny access based on existing grounds.\n   */\n  private async reportAccessError(identifier: ResourceIdentifier, modes: ReadonlySet<AccessMode>,\n    permissions: PermissionSet, cause: unknown): Promise<never> {\n    const exposeExistence = this.hasModePermission(permissions, AccessMode.read);\n    if (exposeExistence && !modes.has(AccessMode.create) && !await this.resourceSet.hasResource(identifier)) {\n      throw new NotFoundHttpError();\n    }\n\n    throw cause;\n  }\n\n  /**\n   * Ensures that at least one of the credentials provides permissions for the given mode.\n   * Throws a {@link ForbiddenHttpError} or {@link UnauthorizedHttpError} depending on the credentials\n   * if access is not allowed.\n   * @param credentials - Credentials that require access.\n   * @param permissionSet - PermissionSet describing the available permissions of the credentials.\n   * @param mode - Which mode is requested.\n   */\n  private requireModePermission(credentials: CredentialSet, permissionSet: PermissionSet, mode: AccessMode): void {\n    if (!this.hasModePermission(permissionSet, mode)) {\n      if (this.isAuthenticated(credentials)) {\n        this.logger.warn(`Agent ${credentials.agent!.webId} has no ${mode} permissions`);\n        throw new ForbiddenHttpError();\n      } else {\n        // Solid, ยง2.1: \"When a client does not provide valid credentials when requesting a resource that requires it,\n        // the data pod MUST send a response with a 401 status code (unless 404 is preferred for security reasons).\"\n        // https://solid.github.io/specification/protocol#http-server\n        this.logger.warn(`Unauthenticated agent has no ${mode} permissions`);\n        throw new UnauthorizedHttpError();\n      }\n    }\n  }\n\n  /**\n   * Checks if one of the Permissions in the PermissionSet grants permission to use the given mode.\n   */\n  private hasModePermission(permissionSet: PermissionSet, mode: AccessMode): boolean {\n    for (const permissions of Object.values(permissionSet)) {\n      if (permissions[mode]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks whether the agent is authenticated (logged in) or not (public/anonymous).\n   * @param credentials - Credentials to check.\n   */\n  private isAuthenticated(credentials: CredentialSet): boolean {\n    return typeof credentials.agent?.webId === 'string';\n  }\n}\n"]}