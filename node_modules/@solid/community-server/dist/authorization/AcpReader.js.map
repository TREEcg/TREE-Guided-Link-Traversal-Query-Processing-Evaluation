{"version":3,"file":"AcpReader.js","sourceRoot":"","sources":["../../src/authorization/AcpReader.ts"],"names":[],"mappings":";;;AAAA,mCAAkC;AAClC,uGAAkG;AAQlG,gDAAkD;AAElD,uDAAsD;AACtD,wDAA8D;AAC9D,4EAAyE;AACzE,wEAAqE;AAErE,6DAA0D;AAC1D,iDAAiD;AACjD,mDAAqD;AACrD,uDAA2C;AAC3C,uCAAyD;AAEzD,yDAAsD;AAEtD,+DAAsD;AACtD,2DAAuD;AAGvD,MAAM,QAAQ,GAAsD;IAClE,CAAC,kBAAG,CAAC,IAAI,CAAC,EAAE,CAAE,wBAAU,CAAC,IAAI,CAAE;IAC/B,CAAC,kBAAG,CAAC,KAAK,CAAC,EAAE,CAAE,wBAAU,CAAC,MAAM,EAAE,wBAAU,CAAC,KAAK,CAAE;IACpD,CAAC,kBAAG,CAAC,MAAM,CAAC,EAAE,CAAE,wBAAU,CAAC,MAAM,CAAE;IACnC,CAAC,kBAAG,CAAC,OAAO,CAAC,EAAE,CAAE,uBAAO,CAAC,OAAO,CAAE;CAC1B,CAAC;AAEX;;;;;GAKG;AACH,MAAa,SAAU,SAAQ,mCAAgB;IAO7C,YAAmB,WAA8B,EAAE,QAAuB,EAAE,kBAAsC;QAChH,KAAK,EAAE,CAAC;QAPS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAQ7C,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;IAC/C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,cAAc,EAAyB;QACxE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,6BAA6B,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QAC9E,MAAM,aAAa,GAAG,IAAI,6BAAa,EAA+B,CAAC;QACvE,MAAM,aAAa,GAAkB,IAAI,6BAAa,EAAE,CAAC;QAEzD,oFAAoF;QACpF,KAAK,MAAM,MAAM,IAAI,cAAc,CAAC,YAAY,EAAE,EAAE;YAClD,aAAa,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC,CAAC;SAC9F;QACD,OAAO,aAAa,CAAC;IACvB,CAAC;IAED;;;;;OAKG;IACK,KAAK,CAAC,kBAAkB,CAAC,MAA0B,EAAE,WAAwB,EACnF,aAAyD;QACzD,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QACxD,MAAM,QAAQ,GAAc,EAAE,CAAC;QAE/B,mDAAmD;QACnD,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QACxD,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,MAAM,IAAI,GAAG,MAAM,IAAA,oBAAU,EAAC,aAAa,EAAE,UAAU,EAAE,KAAK,IAAyC,EAAE,CACvG,CAAE,GAAG,IAAA,sCAA4B,EAAC,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAE,CAAC,CAAC;YAC3E,MAAM,IAAI,GAAG,QAAQ,CAAC,MAAM,CAAC;YAC7B,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;YAC1D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,QAAQ,CAAC,MAAM,GAAG,IAAI,0BAA0B,MAAM,CAAC,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;SACjH;QACD,MAAM,KAAK,GAAG,IAAA,qCAAgB,EAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAElD,kEAAkE;QAClE,qDAAqD;QACrD,qEAAqE;QACrE,8DAA8D;QAC9D,MAAM,aAAa,GAAkB,EAAE,KAAK,EAAE,EAAE,EAAC,CAAC;QAClD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,IAAI,IAAI,IAAI,QAAQ,EAAE;gBACpB,KAAK,MAAM,UAAU,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;oBACvC,aAAa,CAAC,KAAM,CAAC,UAAwB,CAAC,GAAG,IAAI,CAAC;iBACvD;aACF;SACF;QACD,OAAO,aAAa,CAAC;IACvB,CAAC;IAED;;OAEG;IACK,aAAa,CAAC,MAA0B,EAAE,WAAwB;QACxE,OAAO;YACL,MAAM,EAAE,MAAM,CAAC,IAAI;YACnB,KAAK,EAAE,WAAW,CAAC,KAAK,EAAE,KAAK;YAC/B,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,QAAQ;YACpC,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,GAAG;SAChC,CAAC;IACJ,CAAC;IAED;;;OAGG;IACI,CAAE,oBAAoB,CAAC,MAA0B,EAAE,SAA8C;QAEtG,KAAK,MAAM,EAAE,GAAG,EAAE,qBAAqB,EAAE,IAAI,SAAS,EAAE;YACtD,4FAA4F;YAC5F,8GAA8G;YAC9G,MAAM,kBAAkB,GAAG,GAAG,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,qBAAqB,CAAC;YACzF,KAAK,CAAC,CAAC,qBAAqB,CAAC,kBAAkB,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,EAAa,EAAE,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;SACxF;IACH,CAAC;IAED;;;OAGG;IACI,CAAE,sBAAsB,CAAC,UAA8B;QAC5D,MAAM,UAAU,CAAC;QACjB,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,UAAU,CAAC,EAAE;YAC3D,UAAU,GAAG,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;YACpE,MAAM,UAAU,CAAC;SAClB;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,WAAW,CAAC,UAA8B;QACtD,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;QAC1E,IAAI,IAAc,CAAC;QACnB,IAAI;YACF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAwB,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC;YAChE,CAAC,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,aAAa,EAAE,EAAE,IAAI,EAAE,EAAE,CAAC,6BAAc,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC,CAAC,CAAC;SACrG;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,CAAC,qCAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;gBACxC,MAAM,OAAO,GAAG,qBAAqB,aAAa,CAAC,IAAI,KAAK,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC;gBACxF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;gBAC3B,MAAM,IAAI,yCAAmB,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;aAC1D;YACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,oCAAoC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YACzE,IAAI,GAAG,iBAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAC1B;QACD,OAAO,IAAA,4BAAe,EAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;CACF;AAzHD,8BAyHC","sourcesContent":["import { Readable } from 'stream';\nimport { allowAccessModes } from '@solid/access-control-policy/dist/algorithm/allow_access_modes';\nimport type { IAccessControlledResource } from '@solid/access-control-policy/dist/type/i_access_controlled_resource';\nimport type { IContext } from '@solid/access-control-policy/dist/type/i_context';\nimport type { IPolicy } from '@solid/access-control-policy/dist/type/i_policy';\nimport type { Store } from 'n3';\nimport type { Credentials } from '../authentication/Credentials';\nimport type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { ResourceStore } from '../storage/ResourceStore';\nimport { INTERNAL_QUADS } from '../util/ContentTypes';\nimport { createErrorMessage } from '../util/errors/ErrorUtil';\nimport { InternalServerError } from '../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport type { IdentifierStrategy } from '../util/identifiers/IdentifierStrategy';\nimport { IdentifierMap } from '../util/map/IdentifierMap';\nimport { getDefault } from '../util/map/MapUtil';\nimport { readableToQuads } from '../util/StreamUtil';\nimport { ACL } from '../util/Vocabularies';\nimport { getAccessControlledResources } from './AcpUtil';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport type { AclPermission } from './permissions/AclPermission';\nimport { AclMode } from './permissions/AclPermission';\nimport { AccessMode } from './permissions/Permissions';\nimport type { PermissionMap, PermissionSet } from './permissions/Permissions';\n\nconst modesMap: Record<string, Readonly<(keyof AclPermission)[]>> = {\n  [ACL.Read]: [ AccessMode.read ],\n  [ACL.Write]: [ AccessMode.append, AccessMode.write ],\n  [ACL.Append]: [ AccessMode.append ],\n  [ACL.Control]: [ AclMode.control ],\n} as const;\n\n/**\n * Finds the permissions of a resource as defined in the corresponding ACRs.\n * Implementation based on https://solid.github.io/authorization-panel/acp-specification/.\n *\n * Caches data so no duplicate calls are made to the {@link ResourceStore} for a single request.\n */\nexport class AcpReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly acrStrategy: AuxiliaryStrategy;\n  private readonly acrStore: ResourceStore;\n  private readonly identifierStrategy: IdentifierStrategy;\n\n  public constructor(acrStrategy: AuxiliaryStrategy, acrStore: ResourceStore, identifierStrategy: IdentifierStrategy) {\n    super();\n    this.acrStrategy = acrStrategy;\n    this.acrStore = acrStore;\n    this.identifierStrategy = identifierStrategy;\n  }\n\n  public async handle({ credentials, requestedModes }: PermissionReaderInput): Promise<PermissionMap> {\n    this.logger.debug(`Retrieving permissions of ${JSON.stringify(credentials)}`);\n    const resourceCache = new IdentifierMap<IAccessControlledResource[]>();\n    const permissionMap: PermissionMap = new IdentifierMap();\n\n    // Resolves the targets sequentially so the `resourceCache` can be filled and reused\n    for (const target of requestedModes.distinctKeys()) {\n      permissionMap.set(target, await this.extractPermissions(target, credentials, resourceCache));\n    }\n    return permissionMap;\n  }\n\n  /**\n   * Generates the allowed permissions.\n   * @param target - Target to generate permissions for.\n   * @param credentials - Credentials that are trying to access the resource.\n   * @param resourceCache - Cache used to store ACR data.\n   */\n  private async extractPermissions(target: ResourceIdentifier, credentials: Credentials,\n    resourceCache: IdentifierMap<IAccessControlledResource[]>): Promise<PermissionSet> {\n    const context = this.createContext(target, credentials);\n    const policies: IPolicy[] = [];\n\n    // Extract all the policies relevant for the target\n    const identifiers = this.getAncestorIdentifiers(target);\n    for (const identifier of identifiers) {\n      const acrs = await getDefault(resourceCache, identifier, async(): Promise<IAccessControlledResource[]> =>\n        [ ...getAccessControlledResources(await this.readAcrData(identifier)) ]);\n      const size = policies.length;\n      policies.push(...this.getEffectivePolicies(target, acrs));\n      this.logger.debug(`Found ${policies.length - size} policies relevant for ${target.path} in ${identifier.path}`);\n    }\n    const modes = allowAccessModes(policies, context);\n\n    // We don't do a separate ACP run for public and agent credentials\n    // as that is only relevant for the WAC-Allow header.\n    // All permissions are put in the `agent` field of the PermissionSet,\n    // as the actual field used does not matter for authorization.\n    const permissionSet: PermissionSet = { agent: {}};\n    for (const mode of modes) {\n      if (mode in modesMap) {\n        for (const permission of modesMap[mode]) {\n          permissionSet.agent![permission as AccessMode] = true;\n        }\n      }\n    }\n    return permissionSet;\n  }\n\n  /**\n   * Creates an ACP context targeting the given identifier with the provided credentials.\n   */\n  private createContext(target: ResourceIdentifier, credentials: Credentials): IContext {\n    return {\n      target: target.path,\n      agent: credentials.agent?.webId,\n      client: credentials.client?.clientId,\n      issuer: credentials.issuer?.url,\n    };\n  }\n\n  /**\n   * Returns all {@link IPolicy} found in `resources` that apply to the target identifier.\n   * https://solidproject.org/TR/2022/acp-20220518#effective-policies\n   */\n  private* getEffectivePolicies(target: ResourceIdentifier, resources: Iterable<IAccessControlledResource>):\n  Iterable<IPolicy> {\n    for (const { iri, accessControlResource } of resources) {\n      // Use the `accessControl` entries if the `target` corresponds to the `iri` used in the ACR.\n      // If not, this means this is an ACR of a parent resource, and we need to use the `memberAccessControl` field.\n      const accessControlField = iri === target.path ? 'accessControl' : 'memberAccessControl';\n      yield* accessControlResource[accessControlField].flatMap((ac): IPolicy[] => ac.policy);\n    }\n  }\n\n  /**\n   * Returns the given identifier and all its ancestors.\n   * These are all the identifiers that are relevant for determining the effective policies.\n   */\n  private* getAncestorIdentifiers(identifier: ResourceIdentifier): Iterable<ResourceIdentifier> {\n    yield identifier;\n    while (!this.identifierStrategy.isRootContainer(identifier)) {\n      identifier = this.identifierStrategy.getParentContainer(identifier);\n      yield identifier;\n    }\n  }\n\n  /**\n   * Returns the data found in the ACR corresponding to the given identifier.\n   */\n  private async readAcrData(identifier: ResourceIdentifier): Promise<Store> {\n    const acrIdentifier = this.acrStrategy.getAuxiliaryIdentifier(identifier);\n    let data: Readable;\n    try {\n      this.logger.debug(`Reading ACR document ${acrIdentifier.path}`);\n      ({ data } = await this.acrStore.getRepresentation(acrIdentifier, { type: { [INTERNAL_QUADS]: 1 }}));\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        const message = `Error reading ACR ${acrIdentifier.path}: ${createErrorMessage(error)}`;\n        this.logger.error(message);\n        throw new InternalServerError(message, { cause: error });\n      }\n      this.logger.debug(`No direct ACR document found for ${identifier.path}`);\n      data = Readable.from([]);\n    }\n    return readableToQuads(data);\n  }\n}\n"]}