{"version":3,"file":"WebAclAuxiliaryReader.js","sourceRoot":"","sources":["../../src/authorization/WebAclAuxiliaryReader.ts"],"names":[],"mappings":";;;AAGA,gDAAkD;AAClD,6DAAkE;AAElE,iDAA6C;AAE7C,yDAAsD;AACtD,+DAAsD;AAItD;;;GAGG;AACH,MAAa,qBAAsB,SAAQ,mCAAgB;IAMzD,YAAmB,MAAwB,EAAE,WAA8B;QACzE,KAAK,EAAE,CAAC;QANS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAO7C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,WAAW,EAAyB;QACxE,gCAAgC;QAChC,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;QAErD,yEAAyE;QACzE,MAAM,UAAU,GAAG,IAAA,gBAAM,EAAC,IAAI,qCAAqB,CAAC,cAAc,CAAC,EACjE,EAAE,GAAG,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACnD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,cAAc,EAAE,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;QAEzF,wEAAwE;QACxE,KAAK,MAAM,CAAE,UAAU,EAAE,CAAE,OAAO,CAAE,CAAC,IAAI,MAAM,EAAE;YAC/C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,OAAO,CAAC,IAAI,8CAA8C,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YAC1G,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SAChF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,CAAE,OAAO,CAAC,SAAoB;QACnC,KAAK,MAAM,CAAE,UAAU,CAAE,IAAI,SAAS,EAAE;YACtC,IAAI,IAAI,CAAC,WAAW,CAAC,qBAAqB,CAAC,UAAU,CAAC,EAAE;gBACtD,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBAClE,0EAA0E;gBAC1E,MAAM,CAAE,UAAU,EAAE,CAAE,OAAO,EAAE,IAAI,GAAG,CAAC,CAAE,uBAAO,CAAC,OAAO,CAA6B,CAAC,CAAE,CAAC,CAAC;aAC3F;SACF;IACH,CAAC;IAED;;OAEG;IACO,gBAAgB,CAAC,UAA8B,EAAE,gBAA+B,EAAE;QAC1F,MAAM,MAAM,GAAkB,EAAE,CAAC;QACjC,KAAK,MAAM,CAAE,KAAK,EAAE,WAAW,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAAyC,EAAE;YAC1G,MAAM,EAAE,OAAO,EAAE,GAAG,WAAW,CAAC;YAChC,MAAM,CAAC,KAAK,CAAC,GAAG;gBACd,IAAI,EAAE,OAAO;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,OAAO;gBACd,OAAO;aACS,CAAC;SACpB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA1DD,sDA0DC","sourcesContent":["import type { CredentialGroup } from '../authentication/Credentials';\nimport type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { IdentifierSetMultiMap } from '../util/map/IdentifierMap';\nimport type { MapEntry } from '../util/map/MapUtil';\nimport { modify } from '../util/map/MapUtil';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport { AclMode } from './permissions/AclPermission';\nimport type { AclPermission } from './permissions/AclPermission';\nimport type { AccessMap, AccessMode, PermissionMap, PermissionSet } from './permissions/Permissions';\n\n/**\n * Determines the permission for ACL auxiliary resources.\n * This is done by looking for control permissions on the subject resource.\n */\nexport class WebAclAuxiliaryReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly reader: PermissionReader;\n  private readonly aclStrategy: AuxiliaryStrategy;\n\n  public constructor(reader: PermissionReader, aclStrategy: AuxiliaryStrategy) {\n    super();\n    this.reader = reader;\n    this.aclStrategy = aclStrategy;\n  }\n\n  public async handle({ requestedModes, credentials }: PermissionReaderInput): Promise<PermissionMap> {\n    // Finds all the ACL identifiers\n    const aclMap = new Map(this.findAcl(requestedModes));\n\n    // Replaces the ACL identifies with the corresponding subject identifiers\n    const updatedMap = modify(new IdentifierSetMultiMap(requestedModes),\n      { add: aclMap.values(), remove: aclMap.keys() });\n    const result = await this.reader.handleSafe({ requestedModes: updatedMap, credentials });\n\n    // Extracts the ACL permissions based on the subject control permissions\n    for (const [ identifier, [ subject ]] of aclMap) {\n      this.logger.debug(`Mapping ${subject.path} control permission to all permissions for ${identifier.path}`);\n      result.set(identifier, this.interpretControl(identifier, result.get(subject)));\n    }\n    return result;\n  }\n\n  /**\n   * Finds all ACL identifiers and maps them to their subject identifier and the requested modes.\n   */\n  private* findAcl(accessMap: AccessMap): Iterable<[ResourceIdentifier, MapEntry<AccessMap>]> {\n    for (const [ identifier ] of accessMap) {\n      if (this.aclStrategy.isAuxiliaryIdentifier(identifier)) {\n        const subject = this.aclStrategy.getSubjectIdentifier(identifier);\n        // Unfortunately there is no enum inheritance so we have to cast like this\n        yield [ identifier, [ subject, new Set([ AclMode.control ] as unknown as AccessMode[]) ]];\n      }\n    }\n  }\n\n  /**\n   * Updates the permissions for an ACL resource by interpreting the Control access mode as allowing full access.\n   */\n  protected interpretControl(identifier: ResourceIdentifier, permissionSet: PermissionSet = {}): PermissionSet {\n    const aclSet: PermissionSet = {};\n    for (const [ group, permissions ] of Object.entries(permissionSet) as [ CredentialGroup, AclPermission ][]) {\n      const { control } = permissions;\n      aclSet[group] = {\n        read: control,\n        append: control,\n        write: control,\n        control,\n      } as AclPermission;\n    }\n    return aclSet;\n  }\n}\n"]}