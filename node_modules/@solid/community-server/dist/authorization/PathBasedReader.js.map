{"version":3,"file":"PathBasedReader.js","sourceRoot":"","sources":["../../src/authorization/PathBasedReader.ts"],"names":[],"mappings":";;;AAAA,gDAAkD;AAClD,uDAA8C;AAC9C,6DAAiF;AACjF,+CAA4E;AAE5E,yDAAsD;AAGtD;;;;;;;GAOG;AACH,MAAa,eAAgB,SAAQ,mCAAgB;IAMnD,YAAmB,OAAe,EAAE,KAAuC;QACzE,KAAK,EAAE,CAAC;QANS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAO7C,IAAI,CAAC,OAAO,GAAG,IAAA,8BAAmB,EAAC,OAAO,CAAC,CAAC;QAC5C,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;aAClC,GAAG,CAAC,CAAC,CAAE,GAAG,EAAE,GAAG,CAAE,EAA8B,EAAE,CAAC,CAAE,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAE,CAAC,CAAC;QACpF,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA4B;QAC9C,MAAM,OAAO,GAAoB,EAAE,CAAC;QACpC,KAAK,MAAM,CAAE,MAAM,EAAE,WAAW,CAAE,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;YAC7E,OAAO,CAAC,IAAI,CAAC,MAAM,MAAM,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,KAAK,CAAC,WAAW,EAAE,cAAc,EAAE,WAAW,EAAE,CAAC,CAAC,CAAC;SACxG;QACD,OAAO,IAAI,6BAAa,CAAC,IAAA,qBAAM,EAAC,OAAO,CAAC,CAAC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACK,YAAY,CAAC,SAAoB;QACvC,MAAM,MAAM,GAAG,IAAI,GAAG,EAA+B,CAAC;QACtD,KAAK,MAAM,CAAE,UAAU,EAAE,KAAK,CAAE,IAAI,SAAS,EAAE;YAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAChD,IAAI,MAAM,EAAE;gBACV,IAAI,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACjC,IAAI,CAAC,OAAO,EAAE;oBACZ,OAAO,GAAG,IAAI,qCAAqB,EAAE,CAAC;oBACtC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;iBAC7B;gBACD,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;aAChC;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,IAAY;QAC7B,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACjC,oCAAoC;YACpC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAA,8BAAmB,EAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;YACtE,KAAK,MAAM,CAAE,KAAK,EAAE,MAAM,CAAE,IAAI,IAAI,CAAC,KAAK,EAAE;gBAC1C,IAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;oBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,+BAA+B,IAAI,EAAE,CAAC,CAAC;oBACzD,OAAO,MAAM,CAAC;iBACf;aACF;SACF;IACH,CAAC;CACF;AAxDD,0CAwDC","sourcesContent":["import { getLoggerFor } from '../logging/LogUtil';\nimport { concat } from '../util/IterableUtil';\nimport { IdentifierMap, IdentifierSetMultiMap } from '../util/map/IdentifierMap';\nimport { ensureTrailingSlash, trimTrailingSlashes } from '../util/PathUtil';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport type { AccessMap, PermissionMap } from './permissions/Permissions';\n\n/**\n * Redirects requests to specific PermissionReaders based on their identifier.\n * The keys are regular expression strings.\n * The regular expressions should all start with a slash\n * and will be evaluated relative to the base URL.\n *\n * Will error if no match is found.\n */\nexport class PathBasedReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly baseUrl: string;\n  private readonly paths: Map<RegExp, PermissionReader>;\n\n  public constructor(baseUrl: string, paths: Record<string, PermissionReader>) {\n    super();\n    this.baseUrl = ensureTrailingSlash(baseUrl);\n    const entries = Object.entries(paths)\n      .map(([ key, val ]): [RegExp, PermissionReader] => [ new RegExp(key, 'u'), val ]);\n    this.paths = new Map(entries);\n  }\n\n  public async handle(input: PermissionReaderInput): Promise<PermissionMap> {\n    const results: PermissionMap[] = [];\n    for (const [ reader, readerModes ] of this.matchReaders(input.requestedModes)) {\n      results.push(await reader.handleSafe({ credentials: input.credentials, requestedModes: readerModes }));\n    }\n    return new IdentifierMap(concat(results));\n  }\n\n  /**\n   *  Returns for each reader the matching part of the access map.\n   */\n  private matchReaders(accessMap: AccessMap): Map<PermissionReader, AccessMap> {\n    const result = new Map<PermissionReader, AccessMap>();\n    for (const [ identifier, modes ] of accessMap) {\n      const reader = this.findReader(identifier.path);\n      if (reader) {\n        let matches = result.get(reader);\n        if (!matches) {\n          matches = new IdentifierSetMultiMap();\n          result.set(reader, matches);\n        }\n        matches.set(identifier, modes);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Find the PermissionReader corresponding to the given path.\n   */\n  private findReader(path: string): PermissionReader | undefined {\n    if (path.startsWith(this.baseUrl)) {\n      // We want to keep the leading slash\n      const relative = path.slice(trimTrailingSlashes(this.baseUrl).length);\n      for (const [ regex, reader ] of this.paths) {\n        if (regex.test(relative)) {\n          this.logger.debug(`Permission reader found for ${path}`);\n          return reader;\n        }\n      }\n    }\n  }\n}\n"]}