{"version":3,"file":"LazyLoggerFactory.js","sourceRoot":"","sources":["../../src/logging/LazyLoggerFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import cluster from 'cluster';\nimport { WrappingLogger } from './Logger';\nimport type { Logger } from './Logger';\nimport type { LoggerFactory } from './LoggerFactory';\nimport type { LogLevel } from './LogLevel';\n\n/**\n * Temporary {@link LoggerFactory} that buffers log messages in memory\n * until the {@link TemporaryLoggerFactory#switch} method is called.\n */\nclass TemporaryLoggerFactory implements LoggerFactory {\n  private bufferSpaces: number;\n  private readonly wrappers: { wrapper: WrappingLogger; label: string }[] = [];\n  private readonly buffer: { logger: Logger; level: LogLevel; message: string }[] = [];\n\n  public constructor(bufferSize = 1024) {\n    this.bufferSpaces = bufferSize;\n  }\n\n  public createLogger(label: string): WrappingLogger {\n    const wrapper = new WrappingLogger({\n      log: (level: LogLevel, message: string): Logger =>\n        this.bufferLogEntry(wrapper, level, message),\n    });\n    this.wrappers.push({ wrapper, label });\n    return wrapper;\n  }\n\n  private bufferLogEntry(logger: WrappingLogger, level: LogLevel, message: string): Logger {\n    // Buffer the message if spaces are still available\n    if (this.bufferSpaces > 0) {\n      this.bufferSpaces -= 1;\n      // If this is the last space, instead generate a warning through a new logger\n      if (this.bufferSpaces === 0) {\n        logger = this.createLogger('LazyLoggerFactory');\n        level = 'warn';\n        message = `Memory-buffered logging limit of ${this.buffer.length + 1} reached`;\n      }\n      this.buffer.push({ logger, level, message });\n    }\n    return logger;\n  }\n\n  /**\n   * Swaps all lazy loggers to new loggers from the given factory,\n   * and emits any buffered messages through those actual loggers.\n   */\n  public switch(loggerFactory: LoggerFactory): void {\n    // Instantiate an actual logger within every lazy logger\n    for (const { wrapper, label } of this.wrappers.splice(0, this.wrappers.length)) {\n      wrapper.logger = loggerFactory.createLogger(label);\n    }\n    // Emit all buffered log messages\n    for (const { logger, level, message } of this.buffer.splice(0, this.buffer.length)) {\n      logger.log(level, message, { isPrimary: cluster.isMaster, pid: process.pid });\n    }\n  }\n}\n\n/**\n * Wraps around another {@link LoggerFactory} that can be set lazily.\n * This is useful when objects are instantiated (and when they create loggers)\n * before the logging system has been fully instantiated,\n * as is the case when using a dependency injection framework such as Components.js.\n *\n * Loggers can be created even before a {@link LoggerFactory} is set;\n * any log messages will be buffered and re-emitted.\n */\nexport class LazyLoggerFactory implements LoggerFactory {\n  private factory: LoggerFactory;\n\n  public constructor(options: { bufferSize?: number } = {}) {\n    this.factory = new TemporaryLoggerFactory(options.bufferSize);\n  }\n\n  public get loggerFactory(): LoggerFactory {\n    if (this.factory instanceof TemporaryLoggerFactory) {\n      throw new Error('Logger factory not yet set.');\n    }\n    return this.factory;\n  }\n\n  public set loggerFactory(loggerFactory: LoggerFactory) {\n    if (this.factory instanceof TemporaryLoggerFactory) {\n      this.factory.switch(loggerFactory);\n    }\n    this.factory = loggerFactory;\n  }\n\n  public createLogger(label: string): Logger {\n    return this.factory.createLogger(label);\n  }\n}\n"]}