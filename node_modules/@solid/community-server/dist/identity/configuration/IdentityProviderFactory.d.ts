import type { Configuration } from 'oidc-provider';
import { Provider } from 'oidc-provider';
import type { ErrorHandler } from '../../http/output/error/ErrorHandler';
import type { ResponseWriter } from '../../http/output/ResponseWriter';
import type { KeyValueStorage } from '../../storage/keyvalue/KeyValueStorage';
import type { ClientCredentials } from '../interaction/email-password/credentials/ClientCredentialsAdapterFactory';
import type { InteractionHandler } from '../interaction/InteractionHandler';
import type { AdapterFactory } from '../storage/AdapterFactory';
import type { ProviderFactory } from './ProviderFactory';
export interface IdentityProviderFactoryArgs {
    /**
     * Factory that creates the adapter used for OIDC data storage.
     */
    adapterFactory: AdapterFactory;
    /**
     * Base URL of the server.
     */
    baseUrl: string;
    /**
     * Path for all requests targeting the OIDC library.
     */
    oidcPath: string;
    /**
     * The handler responsible for redirecting interaction requests to the correct URL.
     */
    interactionHandler: InteractionHandler;
    /**
     * Storage containing the generated client credentials with their associated WebID.
     */
    credentialStorage: KeyValueStorage<string, ClientCredentials>;
    /**
     * Storage used to store cookie and JWT keys so they can be re-used in case of multithreading.
     */
    storage: KeyValueStorage<string, unknown>;
    /**
     * Extra information will be added to the error output if this is true.
     */
    showStackTrace: boolean;
    /**
     * Used to convert errors thrown by the OIDC library.
     */
    errorHandler: ErrorHandler;
    /**
     * Used to write out errors thrown by the OIDC library.
     */
    responseWriter: ResponseWriter;
}
/**
 * Creates an OIDC Provider based on the provided configuration and parameters.
 * The provider will be cached and returned on subsequent calls.
 * Cookie and JWT keys will be stored in an internal storage so they can be re-used over multiple threads.
 * Necessary claims for Solid OIDC interactions will be added.
 * Routes will be updated based on the `baseUrl` and `oidcPath`.
 */
export declare class IdentityProviderFactory implements ProviderFactory {
    protected readonly logger: import("../..").Logger;
    private readonly config;
    private readonly adapterFactory;
    private readonly baseUrl;
    private readonly oidcPath;
    private readonly interactionHandler;
    private readonly credentialStorage;
    private readonly storage;
    private readonly showStackTrace;
    private readonly errorHandler;
    private readonly responseWriter;
    private readonly jwtAlg;
    private provider?;
    /**
     * @param config - JSON config for the OIDC library @range {json}
     * @param args - Remaining parameters required for the factory.
     */
    constructor(config: Configuration, args: IdentityProviderFactoryArgs);
    getProvider(): Promise<Provider>;
    /**
     * Creates a Provider by building a Configuration using all the stored parameters.
     */
    private createProvider;
    /**
     * In the `configureErrors` function below, we configure the `renderError` function of the provider configuration.
     * This function is called by the OIDC provider library to render errors,
     * but only does this if the accept header is HTML.
     * Otherwise, it just returns the error object iself as a JSON object.
     * See https://github.com/panva/node-oidc-provider/blob/0fcc112e0a95b3b2dae4eba6da812253277567c9/lib/shared/error_handler.js#L48-L52.
     *
     * In this function we override the `ctx.accepts` function
     * to make the above code think HTML is always requested there.
     * This way we have full control over error representation as configured in `configureErrors`.
     * We still check the accept headers ourselves so there still is content negotiation on the output,
     * the client will not simply always receive HTML.
     *
     * Should this part of the OIDC library code ever change, our function will break,
     * at which point behaviour will simply revert to what it was before.
     */
    private captureErrorResponses;
    /**
     * Creates a configuration by copying the internal configuration
     * and adding the adapter, default audience and jwks/cookie keys.
     */
    private initConfig;
    /**
     * Generates a JWKS using a single JWK.
     * The JWKS will be cached so subsequent calls return the same key.
     */
    private generateJwks;
    /**
     * Generates a cookie secret to be used for cookie signing.
     * The key will be cached so subsequent calls return the same key.
     */
    private generateCookieKeys;
    /**
     * Checks if the given token is an access token.
     * The AccessToken interface is not exported so we have to access it like this.
     */
    private isAccessToken;
    /**
     * Adds the necessary claims the to id and access tokens based on the Solid OIDC spec.
     */
    private configureClaims;
    /**
     * Creates the route string as required by the `oidc-provider` library.
     * In case base URL is `http://test.com/foo/`, `oidcPath` is `/idp` and `relative` is `device/auth`,
     * this would result in `/foo/idp/device/auth`.
     */
    private createRoute;
    /**
     * Sets up all the IDP routes relative to the IDP path.
     */
    private configureRoutes;
    /**
     * Pipes library errors to the provided ErrorHandler and ResponseWriter.
     */
    private configureErrors;
}
