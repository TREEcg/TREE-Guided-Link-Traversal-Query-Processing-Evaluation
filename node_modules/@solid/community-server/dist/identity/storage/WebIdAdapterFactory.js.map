{"version":3,"file":"WebIdAdapterFactory.js","sourceRoot":"","sources":["../../../src/identity/storage/WebIdAdapterFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Response } from 'cross-fetch';\nimport { fetch } from 'cross-fetch';\nimport type { Quad } from 'n3';\nimport type { Adapter, AdapterPayload } from 'oidc-provider';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport { responseToDataset } from '../../util/FetchUtil';\nimport { hasScheme } from '../../util/HeaderUtil';\nimport { OIDC } from '../../util/Vocabularies';\nimport type { AdapterFactory } from './AdapterFactory';\nimport { PassthroughAdapter, PassthroughAdapterFactory } from './PassthroughAdapterFactory';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * This {@link Adapter} redirects the `find` call to its source adapter.\n * In case no client data was found in the source for the given WebId,\n * this class will do an HTTP GET request to that WebId.\n * If a valid `solid:oidcRegistration` triple is found there,\n * that data will be returned instead.\n */\nexport class WebIdAdapter extends PassthroughAdapter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly converter: RepresentationConverter;\n\n  public constructor(name: string, source: Adapter, converter: RepresentationConverter) {\n    super(name, source);\n    this.converter = converter;\n  }\n\n  public async find(id: string): Promise<AdapterPayload | void> {\n    let payload = await this.source.find(id);\n\n    // No payload is stored for the given Client ID.\n    // Try to see if valid client metadata is found at the given Client ID.\n    // The oidc-provider library will check if the redirect_uri matches an entry in the list of redirect_uris,\n    // so no extra checks are needed from our side.\n    if (!payload && this.name === 'Client' && hasScheme(id, 'http', 'https')) {\n      this.logger.debug(`Looking for payload data at ${id}`);\n      // All checks based on https://solid.github.io/authentication-panel/solid-oidc/#clientids-webid\n      if (!/^https:|^http:\\/\\/localhost(?::\\d+)?(?:\\/|$)/u.test(id)) {\n        throw new Error(`SSL is required for client_id authentication unless working locally.`);\n      }\n      const response = await fetch(id);\n      if (response.status !== 200) {\n        throw new Error(`Unable to access data at ${id}: ${await response.text()}`);\n      }\n      const data = await response.text();\n      let json: any | undefined;\n      try {\n        json = JSON.parse(data);\n        const contexts = Array.isArray(json['@context']) ? json['@context'] : [ json['@context'] ];\n        // We can only parse as simple JSON if the @context is correct\n        if (!contexts.includes('https://www.w3.org/ns/solid/oidc-context.jsonld')) {\n          throw new Error('Missing context https://www.w3.org/ns/solid/oidc-context.jsonld');\n        }\n      } catch (error: unknown) {\n        json = undefined;\n        this.logger.debug(`Found unexpected client WebID for ${id}: ${createErrorMessage(error)}`);\n      }\n\n      if (json) {\n        // Need to make sure the document is about the id\n        if (json.client_id !== id) {\n          throw new Error('The client registration `client_id` field must match the client WebID');\n        }\n        payload = json;\n      } else {\n        // Since the WebID does not match the default JSON-LD we try to interpret it as RDF\n        payload = await this.parseRdfWebId(data, id, response);\n      }\n\n      // `token_endpoint_auth_method: 'none'` prevents oidc-provider from requiring a client_secret\n      payload = { ...payload, token_endpoint_auth_method: 'none' };\n    }\n\n    // Will also be returned if no valid client data was found above\n    return payload;\n  }\n\n  /**\n   * Parses RDF data found at a client WebID.\n   * @param data - Raw data from the WebID.\n   * @param id - The actual WebID.\n   * @param response - Response object from the request.\n   */\n  private async parseRdfWebId(data: string, id: string, response: Response): Promise<AdapterPayload> {\n    const representation = await responseToDataset(response, this.converter, data);\n\n    // Find the valid redirect URIs\n    const redirectUris: string[] = [];\n    for await (const entry of representation.data) {\n      const triple = entry as Quad;\n      if (triple.predicate.equals(OIDC.terms.redirect_uris)) {\n        redirectUris.push(triple.object.value);\n      }\n    }\n\n    return {\n      client_id: id,\n      redirect_uris: redirectUris,\n    };\n  }\n}\n\nexport class WebIdAdapterFactory extends PassthroughAdapterFactory {\n  private readonly converter: RepresentationConverter;\n\n  public constructor(source: AdapterFactory, converter: RepresentationConverter) {\n    super(source);\n    this.converter = converter;\n  }\n\n  public createStorageAdapter(name: string): Adapter {\n    return new WebIdAdapter(name, this.source.createStorageAdapter(name), this.converter);\n  }\n}\n"]}