"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAccountStore = void 0;
const assert_1 = __importDefault(require("assert"));
const bcryptjs_1 = require("bcryptjs");
const uuid_1 = require("uuid");
/**
 * A EmailPasswordStore that uses a KeyValueStorage to persist its information and an
 * ExpiringStorage to persist ForgotPassword records.
 *
 * `forgotPasswordExpiration` parameter is how long the ForgotPassword record should be
 *   stored in minutes. *(defaults to 15 minutes)*
 */
class BaseAccountStore {
    constructor(storage, forgotPasswordStorage, saltRounds, forgotPasswordExpiration = 15) {
        this.storage = storage;
        this.forgotPasswordStorage = forgotPasswordStorage;
        this.forgotPasswordExpiration = forgotPasswordExpiration * 60 * 1000;
        this.saltRounds = saltRounds;
    }
    /**
     * Generates a ResourceIdentifier to store data for the given email.
     */
    getAccountResourceIdentifier(email) {
        return `account/${encodeURIComponent(email)}`;
    }
    /**
     * Generates a ResourceIdentifier to store data for the given recordId.
     */
    getForgotPasswordRecordResourceIdentifier(recordId) {
        return `forgot-password-resource-identifier/${encodeURIComponent(recordId)}`;
    }
    async getAccountPayload(email, checkExistence) {
        const key = this.getAccountResourceIdentifier(email);
        const account = await this.storage.get(key);
        (0, assert_1.default)(!checkExistence || account, 'Account does not exist');
        return { key, account };
    }
    /* eslint-enable lines-between-class-members */
    async authenticate(email, password) {
        const { account } = await this.getAccountPayload(email, true);
        (0, assert_1.default)(account.verified, 'Account still needs to be verified');
        (0, assert_1.default)(await (0, bcryptjs_1.compare)(password, account.password), 'Incorrect password');
        return account.webId;
    }
    async create(email, webId, password, settings) {
        const { key, account } = await this.getAccountPayload(email, false);
        (0, assert_1.default)(!account, 'Account already exists');
        // Make sure there is no other account for this WebID
        const storedSettings = await this.storage.get(webId);
        (0, assert_1.default)(!storedSettings, 'There already is an account for this WebID');
        const payload = {
            email,
            password: await (0, bcryptjs_1.hash)(password, this.saltRounds),
            verified: false,
            webId,
        };
        await this.storage.set(key, payload);
        await this.storage.set(webId, settings);
    }
    async verify(email) {
        const { key, account } = await this.getAccountPayload(email, true);
        account.verified = true;
        await this.storage.set(key, account);
    }
    async changePassword(email, password) {
        const { key, account } = await this.getAccountPayload(email, true);
        account.password = await (0, bcryptjs_1.hash)(password, this.saltRounds);
        await this.storage.set(key, account);
    }
    async getSettings(webId) {
        const settings = await this.storage.get(webId);
        (0, assert_1.default)(settings, 'Account does not exist');
        return settings;
    }
    async updateSettings(webId, settings) {
        const oldSettings = await this.storage.get(webId);
        (0, assert_1.default)(oldSettings, 'Account does not exist');
        await this.storage.set(webId, settings);
    }
    async deleteAccount(email) {
        const { key, account } = await this.getAccountPayload(email, false);
        if (account) {
            await this.storage.delete(key);
            await this.storage.delete(account.webId);
        }
    }
    async generateForgotPasswordRecord(email) {
        const recordId = (0, uuid_1.v4)();
        await this.getAccountPayload(email, true);
        await this.forgotPasswordStorage.set(this.getForgotPasswordRecordResourceIdentifier(recordId), { recordId, email }, this.forgotPasswordExpiration);
        return recordId;
    }
    async getForgotPasswordRecord(recordId) {
        const identifier = this.getForgotPasswordRecordResourceIdentifier(recordId);
        const forgotPasswordRecord = await this.forgotPasswordStorage.get(identifier);
        return forgotPasswordRecord?.email;
    }
    async deleteForgotPasswordRecord(recordId) {
        await this.forgotPasswordStorage.delete(this.getForgotPasswordRecordResourceIdentifier(recordId));
    }
}
exports.BaseAccountStore = BaseAccountStore;
//# sourceMappingURL=BaseAccountStore.js.map