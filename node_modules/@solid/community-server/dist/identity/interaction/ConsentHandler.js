"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsentHandler = void 0;
const BasicRepresentation_1 = require("../../http/representation/BasicRepresentation");
const ContentTypes_1 = require("../../util/ContentTypes");
const BadRequestHttpError_1 = require("../../util/errors/BadRequestHttpError");
const FoundHttpError_1 = require("../../util/errors/FoundHttpError");
const NotImplementedHttpError_1 = require("../../util/errors/NotImplementedHttpError");
const StreamUtil_1 = require("../../util/StreamUtil");
const BaseInteractionHandler_1 = require("./BaseInteractionHandler");
/**
 * Handles the OIDC consent prompts where the user confirms they want to log in for the given client.
 *
 * Returns all the relevant Client metadata on GET requests.
 */
class ConsentHandler extends BaseInteractionHandler_1.BaseInteractionHandler {
    constructor(providerFactory) {
        super({});
        this.providerFactory = providerFactory;
    }
    async canHandle(input) {
        await super.canHandle(input);
        if (input.operation.method === 'POST' && !input.oidcInteraction) {
            throw new BadRequestHttpError_1.BadRequestHttpError('This action can only be performed as part of an OIDC authentication flow.', { errorCode: 'E0002' });
        }
    }
    async handleGet(input) {
        const { operation, oidcInteraction } = input;
        const provider = await this.providerFactory.getProvider();
        const client = await provider.Client.find(oidcInteraction.params.client_id);
        const metadata = client?.metadata() ?? {};
        // Only extract specific fields to prevent leaking information
        // Based on https://www.w3.org/ns/solid/oidc-context.jsonld
        const keys = ['client_id', 'client_uri', 'logo_uri', 'policy_uri',
            'client_name', 'contacts', 'grant_types', 'scope'];
        const jsonLd = Object.fromEntries(keys.filter((key) => key in metadata)
            .map((key) => [key, metadata[key]]));
        jsonLd['@context'] = 'https://www.w3.org/ns/solid/oidc-context.jsonld';
        const json = { webId: oidcInteraction.session?.accountId, client: jsonLd };
        return new BasicRepresentation_1.BasicRepresentation(JSON.stringify(json), operation.target, ContentTypes_1.APPLICATION_JSON);
    }
    async handlePost({ operation, oidcInteraction }) {
        const { remember, logOut } = await (0, StreamUtil_1.readJsonStream)(operation.body.data);
        if (logOut) {
            const provider = await this.providerFactory.getProvider();
            const session = (await provider.Session.find(oidcInteraction.session.cookie));
            delete session.accountId;
            await session.save(session.exp - Math.floor(Date.now() / 1000));
            throw new FoundHttpError_1.FoundHttpError(oidcInteraction.returnTo);
        }
        const grant = await this.getGrant(oidcInteraction);
        this.updateGrant(grant, oidcInteraction.prompt.details, remember);
        const location = await this.updateInteraction(oidcInteraction, grant);
        throw new FoundHttpError_1.FoundHttpError(location);
    }
    /**
     * Either returns the grant associated with the given interaction or creates a new one if it does not exist yet.
     */
    async getGrant(oidcInteraction) {
        if (!oidcInteraction.session) {
            throw new NotImplementedHttpError_1.NotImplementedHttpError('Only interactions with a valid session are supported.');
        }
        const { params, session: { accountId }, grantId } = oidcInteraction;
        const provider = await this.providerFactory.getProvider();
        let grant;
        if (grantId) {
            grant = (await provider.Grant.find(grantId));
        }
        else {
            grant = new provider.Grant({
                accountId,
                clientId: params.client_id,
            });
        }
        return grant;
    }
    /**
     * Updates the grant with all the missing scopes and claims requested by the interaction.
     *
     * Will reject the `offline_access` scope if `remember` is false.
     */
    updateGrant(grant, details, remember) {
        // Reject the offline_access scope if the user does not want to be remembered
        if (!remember) {
            grant.rejectOIDCScope('offline_access');
        }
        // Grant all the requested scopes and claims
        if (details.missingOIDCScope) {
            grant.addOIDCScope(details.missingOIDCScope.join(' '));
        }
        if (details.missingOIDCClaims) {
            grant.addOIDCClaims(details.missingOIDCClaims);
        }
        if (details.missingResourceScopes) {
            for (const [indicator, scopes] of Object.entries(details.missingResourceScopes)) {
                grant.addResourceScope(indicator, scopes.join(' '));
            }
        }
    }
    /**
     * Updates the interaction with the new grant and returns the resulting redirect URL.
     */
    async updateInteraction(oidcInteraction, grant) {
        const grantId = await grant.save();
        const consent = {};
        // Only need to update the grantId if it is new
        if (!oidcInteraction.grantId) {
            consent.grantId = grantId;
        }
        const result = { consent };
        // Need to merge with previous submission
        oidcInteraction.result = { ...oidcInteraction.lastSubmission, ...result };
        await oidcInteraction.save(oidcInteraction.exp - Math.floor(Date.now() / 1000));
        return oidcInteraction.returnTo;
    }
}
exports.ConsentHandler = ConsentHandler;
//# sourceMappingURL=ConsentHandler.js.map