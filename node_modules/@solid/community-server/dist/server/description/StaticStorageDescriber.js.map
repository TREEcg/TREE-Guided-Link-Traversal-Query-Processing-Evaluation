{"version":3,"file":"StaticStorageDescriber.js","sourceRoot":"","sources":["../../../src/server/description/StaticStorageDescriber.ts"],"names":[],"mappings":";;;AACA,2BAAiC;AACjC,2CAA0C;AAE1C,yDAAsD;AACtD,IAAO,IAAI,GAAG,gBAAW,CAAC,IAAI,CAAC;AAC/B,IAAO,SAAS,GAAG,gBAAW,CAAC,SAAS,CAAC;AAEzC;;;GAGG;AACH,MAAa,sBAAuB,SAAQ,mCAAgB;IAG1D,YAAmB,KAAwC;QACzD,KAAK,EAAE,CAAC;QACR,MAAM,OAAO,GAAG,IAAI,GAAG,EAA4B,CAAC;QACpD,KAAK,MAAM,CAAE,SAAS,EAAE,OAAO,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC1D,MAAM,QAAQ,GAAG,IAAA,yBAAY,EAAC,SAAS,CAAC,CAAC;YACzC,IAAI,QAAQ,CAAC,QAAQ,KAAK,WAAW,EAAE;gBACrC,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;aACxD;YACD,MAAM,QAAQ,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAE,OAAO,CAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAQ,EAAE,CAAC,IAAA,yBAAY,EAAC,GAAG,CAAC,CAAC,CAAC;YACxG,oDAAoD;YACpD,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAyB,CAAC,CAAC;SAClD;QACD,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,MAA0B;QAC5C,MAAM,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvC,OAAO,CAAE,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAE,CAAC;IAC9C,CAAC;IAEM,CAAE,eAAe,CAAC,OAAkB;QACzC,KAAK,MAAM,CAAE,SAAS,EAAE,OAAO,CAAE,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE;YACzD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;gBAC5B,MAAM,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;aACxC;SACF;IACH,CAAC;CACF;AA9BD,wDA8BC","sourcesContent":["import type { NamedNode, Quad, Quad_Object, Term } from '@rdfjs/types';\nimport { DataFactory } from 'n3';\nimport { stringToTerm } from 'rdf-string';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { StorageDescriber } from './StorageDescriber';\nimport quad = DataFactory.quad;\nimport namedNode = DataFactory.namedNode;\n\n/**\n * Adds a fixed set of triples to the storage description resource,\n * with the resource identifier as subject.\n */\nexport class StaticStorageDescriber extends StorageDescriber {\n  private readonly terms: ReadonlyMap<NamedNode, Quad_Object[]>;\n\n  public constructor(terms: Record<string, string | string[]>) {\n    super();\n    const termMap = new Map<NamedNode, Quad_Object[]>();\n    for (const [ predicate, objects ] of Object.entries(terms)) {\n      const predTerm = stringToTerm(predicate);\n      if (predTerm.termType !== 'NamedNode') {\n        throw new Error('Predicate needs to be a named node.');\n      }\n      const objTerms = (Array.isArray(objects) ? objects : [ objects ]).map((obj): Term => stringToTerm(obj));\n      // `stringToTerm` can only generate valid term types\n      termMap.set(predTerm, objTerms as Quad_Object[]);\n    }\n    this.terms = termMap;\n  }\n\n  public async handle(target: ResourceIdentifier): Promise<Quad[]> {\n    const subject = namedNode(target.path);\n    return [ ...this.generateTriples(subject) ];\n  }\n\n  private* generateTriples(subject: NamedNode): Iterable<Quad> {\n    for (const [ predicate, objects ] of this.terms.entries()) {\n      for (const object of objects) {\n        yield quad(subject, predicate, object);\n      }\n    }\n  }\n}\n"]}