"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageDescriptionHandler = void 0;
const OkResponseDescription_1 = require("../../http/output/response/OkResponseDescription");
const BasicRepresentation_1 = require("../../http/representation/BasicRepresentation");
const ContentTypes_1 = require("../../util/ContentTypes");
const MethodNotAllowedHttpError_1 = require("../../util/errors/MethodNotAllowedHttpError");
const NotImplementedHttpError_1 = require("../../util/errors/NotImplementedHttpError");
const PathUtil_1 = require("../../util/PathUtil");
const Vocabularies_1 = require("../../util/Vocabularies");
const OperationHttpHandler_1 = require("../OperationHttpHandler");
/**
 * Generates the response for GET requests targeting a storage description resource.
 * The suffix needs to match the suffix used to generate storage description resources
 * and will be used to verify the container it is linked to is an actual storage.
 */
class StorageDescriptionHandler extends OperationHttpHandler_1.OperationHttpHandler {
    constructor(store, suffix, converter, describer) {
        super();
        this.store = store;
        this.suffix = suffix;
        this.converter = converter;
        this.describer = describer;
    }
    async canHandle({ operation: { target, method } }) {
        if (method !== 'GET') {
            throw new MethodNotAllowedHttpError_1.MethodNotAllowedHttpError([method], `Only GET requests can target the storage description.`);
        }
        const container = { path: (0, PathUtil_1.ensureTrailingSlash)(target.path.slice(0, -this.suffix.length)) };
        const representation = await this.store.getRepresentation(container, {});
        representation.data.destroy();
        if (!representation.metadata.has(Vocabularies_1.RDF.terms.type, Vocabularies_1.PIM.terms.Storage)) {
            throw new NotImplementedHttpError_1.NotImplementedHttpError(`Only supports descriptions of storage containers.`);
        }
        await this.describer.canHandle(target);
    }
    async handle({ operation: { target, preferences } }) {
        const quads = await this.describer.handle(target);
        const representation = new BasicRepresentation_1.BasicRepresentation(quads, ContentTypes_1.INTERNAL_QUADS);
        const converted = await this.converter.handleSafe({ identifier: target, representation, preferences });
        return new OkResponseDescription_1.OkResponseDescription(converted.metadata, converted.data);
    }
}
exports.StorageDescriptionHandler = StorageDescriptionHandler;
//# sourceMappingURL=StorageDescriptionHandler.js.map