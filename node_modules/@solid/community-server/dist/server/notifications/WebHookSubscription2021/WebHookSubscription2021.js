"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebHookSubscription2021 = void 0;
const yup_1 = require("yup");
const Permissions_1 = require("../../../authorization/permissions/Permissions");
const BasicRepresentation_1 = require("../../../http/representation/BasicRepresentation");
const LogUtil_1 = require("../../../logging/LogUtil");
const ContentTypes_1 = require("../../../util/ContentTypes");
const BadRequestHttpError_1 = require("../../../util/errors/BadRequestHttpError");
const ErrorUtil_1 = require("../../../util/errors/ErrorUtil");
const IdentifierMap_1 = require("../../../util/map/IdentifierMap");
const StreamUtil_1 = require("../../../util/StreamUtil");
const Notification_1 = require("../Notification");
const Subscription_1 = require("../Subscription");
const type = 'WebHookSubscription2021';
const schema = Subscription_1.SUBSCRIBE_SCHEMA.shape({
    type: (0, yup_1.string)().required().oneOf([type]),
    // Not using `.url()` validator since it does not support localhost URLs
    target: (0, yup_1.string)().required(),
});
/**
 * The notification subscription type WebHookSubscription2021 as described in
 * https://github.com/solid/notifications/blob/main/webhook-subscription-2021.md
 *
 * Requires read permissions on a resource to be able to receive notifications.
 *
 * Also handles the `state` feature if present.
 */
class WebHookSubscription2021 {
    constructor(storage, unsubscribeRoute, stateHandler) {
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.type = type;
        this.schema = schema;
        this.storage = storage;
        this.unsubscribePath = unsubscribeRoute.getPath();
        this.stateHandler = stateHandler;
    }
    async extractModes(subscription) {
        return new IdentifierMap_1.IdentifierSetMultiMap([[{ path: subscription.topic }, Permissions_1.AccessMode.read]]);
    }
    async subscribe(subscription, credentials) {
        const webId = credentials.agent?.webId;
        if (!webId) {
            throw new BadRequestHttpError_1.BadRequestHttpError('A WebHookSubscription2021 subscription request needs to be authenticated with a WebID.');
        }
        const info = this.storage.create(subscription, { target: subscription.target, webId });
        await this.storage.add(info);
        const jsonld = {
            '@context': [Notification_1.CONTEXT_NOTIFICATION],
            type: this.type,
            target: subscription.target,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            unsubscribe_endpoint: `${this.unsubscribePath}/${encodeURI(info.id)}`,
        };
        const response = new BasicRepresentation_1.BasicRepresentation(JSON.stringify(jsonld), ContentTypes_1.APPLICATION_LD_JSON);
        // We want to send the state notification, if there is one,
        // right after we send the response for subscribing.
        // We do this by waiting for the response to be closed.
        (0, StreamUtil_1.endOfStream)(response.data)
            .then(() => this.stateHandler.handleSafe({ info }))
            .catch((error) => {
            this.logger.error(`Error emitting state notification: ${(0, ErrorUtil_1.createErrorMessage)(error)}`);
        });
        return { response, info };
    }
}
exports.WebHookSubscription2021 = WebHookSubscription2021;
//# sourceMappingURL=WebHookSubscription2021.js.map