"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebHookEmitter = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const jose_1 = require("jose");
const uuid_1 = require("uuid");
const LogUtil_1 = require("../../../logging/LogUtil");
const PathUtil_1 = require("../../../util/PathUtil");
const StreamUtil_1 = require("../../../util/StreamUtil");
const NotificationEmitter_1 = require("../NotificationEmitter");
/**
 * Emits a notification representation using the WebHookSubscription2021 specification.
 *
 * Generates a DPoP token and proof, and adds those to the HTTP request that is sent to the target.
 *
 * The `expiration` input parameter is how long the generated token should be valid in minutes.
 * Default is 20.
 */
class WebHookEmitter extends NotificationEmitter_1.NotificationEmitter {
    constructor(baseUrl, webIdRoute, jwkGenerator, expiration = 20) {
        super();
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.issuer = (0, PathUtil_1.trimTrailingSlashes)(baseUrl);
        this.webId = webIdRoute.getPath();
        this.jwkGenerator = jwkGenerator;
        this.expiration = expiration * 60 * 1000;
    }
    async handle({ info, representation }) {
        this.logger.debug(`Emitting WebHook notification with target ${info.features.target}`);
        const privateKey = await this.jwkGenerator.getPrivateKey();
        const publicKey = await this.jwkGenerator.getPublicKey();
        const privateKeyObject = await (0, jose_1.importJWK)(privateKey);
        // Make sure both header and proof have the same timestamp
        const time = Date.now();
        // The spec is not completely clear on which fields actually need to be present in the token,
        // only that it needs to contain the WebID somehow.
        // The format used here has been chosen to be similar
        // to how ID tokens are described in the Solid-OIDC specification for consistency.
        const dpopToken = await new jose_1.SignJWT({
            webid: this.webId,
            azp: this.webId,
            sub: this.webId,
            cnf: {
                jkt: await (0, jose_1.calculateJwkThumbprint)(publicKey, 'sha256'),
            },
        }).setProtectedHeader({ alg: privateKey.alg })
            .setIssuedAt(time)
            .setExpirationTime(time + this.expiration)
            .setAudience([this.webId, 'solid'])
            .setIssuer(this.issuer)
            .setJti((0, uuid_1.v4)())
            .sign(privateKeyObject);
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop#section-4.2
        const dpopProof = await new jose_1.SignJWT({
            htu: info.features.target,
            htm: 'POST',
        }).setProtectedHeader({ alg: privateKey.alg, jwk: publicKey, typ: 'dpop+jwt' })
            .setIssuedAt(time)
            .setJti((0, uuid_1.v4)())
            .sign(privateKeyObject);
        const response = await (0, cross_fetch_1.default)(info.features.target, {
            method: 'POST',
            headers: {
                'content-type': representation.metadata.contentType,
                authorization: `DPoP ${dpopToken}`,
                dpop: dpopProof,
            },
            body: await (0, StreamUtil_1.readableToString)(representation.data),
        });
        if (response.status >= 400) {
            this.logger.error(`There was an issue emitting a WebHook notification with target ${info.features.target}: ${await response.text()}`);
        }
    }
}
exports.WebHookEmitter = WebHookEmitter;
//# sourceMappingURL=WebHookEmitter.js.map