"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocket2021Emitter = void 0;
const LogUtil_1 = require("../../../logging/LogUtil");
const AsyncHandler_1 = require("../../../util/handlers/AsyncHandler");
const WrappedSetMultiMap_1 = require("../../../util/map/WrappedSetMultiMap");
const StreamUtil_1 = require("../../../util/StreamUtil");
const TimerUtil_1 = require("../../../util/TimerUtil");
/**
 * Keeps track of the WebSockets that were opened for a WebSocketSubscription2021 subscription
 * and uses them to emit events when necessary.
 *
 * SingleThreaded since the opened WebSocket might not be stored in the same thread
 * as the one that emits a relevant event.
 *
 * `cleanupTimer` defines in minutes how often the stored WebSockets are closed
 * if their corresponding subscription has expired.
 * Defaults to 60 minutes.
 * Although the WebSocket connection might still be open,
 * if the subscription has expired no notifications will be sent.
 */
class WebSocket2021Emitter extends AsyncHandler_1.AsyncHandler {
    constructor(storage, cleanupTimer = 60) {
        super();
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.storage = storage;
        this.webSockets = new WrappedSetMultiMap_1.WrappedSetMultiMap();
        const timer = (0, TimerUtil_1.setSafeInterval)(this.logger, 'Failed to remove closed WebSockets', this.closeExpiredSockets.bind(this), cleanupTimer * 60 * 1000);
        timer.unref();
    }
    async handle(input) {
        if (this.isWebSocket2021HandlerInput(input)) {
            // Called as a WebSocket2021Handler: store the WebSocket
            const { webSocket, info } = input;
            this.webSockets.add(info.id, webSocket);
            webSocket.on('error', () => this.webSockets.deleteEntry(info.id, webSocket));
            webSocket.on('close', () => this.webSockets.deleteEntry(info.id, webSocket));
        }
        else {
            // Called as a NotificationEmitter: emit the notification
            const webSockets = this.webSockets.get(input.info.id);
            if (webSockets) {
                const data = await (0, StreamUtil_1.readableToString)(input.representation.data);
                for (const webSocket of webSockets) {
                    webSocket.send(data);
                }
            }
            else {
                input.representation.data.destroy();
            }
        }
    }
    isWebSocket2021HandlerInput(input) {
        return Boolean(input.webSocket);
    }
    /**
     * Close all WebSockets that are attached to a subscription that no longer exists.
     */
    async closeExpiredSockets() {
        this.logger.debug('Closing expired WebSockets');
        for (const [id, sockets] of this.webSockets.entrySets()) {
            const result = await this.storage.get(id);
            if (!result) {
                for (const socket of sockets) {
                    // Due to the attached listener this also deletes the entries
                    socket.close();
                }
            }
        }
        this.logger.debug('Finished closing expired WebSockets');
    }
}
exports.WebSocket2021Emitter = WebSocket2021Emitter;
//# sourceMappingURL=WebSocket2021Emitter.js.map