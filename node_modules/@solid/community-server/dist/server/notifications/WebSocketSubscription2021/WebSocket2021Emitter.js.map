{"version":3,"file":"WebSocket2021Emitter.js","sourceRoot":"","sources":["../../../../src/server/notifications/WebSocketSubscription2021/WebSocket2021Emitter.ts"],"names":[],"mappings":";;;AAEA,sDAAwD;AACxD,sEAAmE;AAEnE,6EAA0E;AAC1E,yDAA4D;AAC5D,uDAA0D;AAK1D;;;;;;;;;;;;GAYG;AACH,MAAa,oBAAqB,SAAQ,2BAAkE;IAO1G,YAAmB,OAA4B,EAAE,YAAY,GAAG,EAAE;QAChE,KAAK,EAAE,CAAC;QANS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAQ7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,IAAI,uCAAkB,EAAqB,CAAC;QAE9D,MAAM,KAAK,GAAG,IAAA,2BAAe,EAAC,IAAI,CAAC,MAAM,EACvC,oCAAoC,EACpC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,EACnC,YAAY,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;QAC5B,KAAK,CAAC,KAAK,EAAE,CAAC;IAChB,CAAC;IAIM,KAAK,CAAC,MAAM,CAAC,KAA2D;QAC7E,IAAI,IAAI,CAAC,2BAA2B,CAAC,KAAK,CAAC,EAAE;YAC3C,wDAAwD;YACxD,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,KAAK,CAAC;YAClC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;YACxC,SAAS,CAAC,EAAE,CAAC,OAAO,EAAE,GAAY,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,CAAC;YACtF,SAAS,CAAC,EAAE,CAAC,OAAO,EAAE,GAAY,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,CAAC;SACvF;aAAM;YACL,yDAAyD;YACzD,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACtD,IAAI,UAAU,EAAE;gBACd,MAAM,IAAI,GAAG,MAAM,IAAA,6BAAgB,EAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAC/D,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;oBAClC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACtB;aACF;iBAAM;gBACL,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;aACrC;SACF;IACH,CAAC;IAEO,2BAA2B,CAAC,KAA2D;QAE7F,OAAO,OAAO,CAAE,KAAmC,CAAC,SAAS,CAAC,CAAC;IACjE,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,mBAAmB;QAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAC;QAChD,KAAK,MAAM,CAAE,EAAE,EAAE,OAAO,CAAE,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,EAAE;YACzD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YAC1C,IAAI,CAAC,MAAM,EAAE;gBACX,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,6DAA6D;oBAC7D,MAAM,CAAC,KAAK,EAAE,CAAC;iBAChB;aACF;SACF;QACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,qCAAqC,CAAC,CAAC;IAC3D,CAAC;CACF;AAhED,oDAgEC","sourcesContent":["import type { WebSocket } from 'ws';\nimport type { SingleThreaded } from '../../../init/cluster/SingleThreaded';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport { AsyncHandler } from '../../../util/handlers/AsyncHandler';\nimport type { SetMultiMap } from '../../../util/map/SetMultiMap';\nimport { WrappedSetMultiMap } from '../../../util/map/WrappedSetMultiMap';\nimport { readableToString } from '../../../util/StreamUtil';\nimport { setSafeInterval } from '../../../util/TimerUtil';\nimport type { NotificationEmitter, NotificationEmitterInput } from '../NotificationEmitter';\nimport type { SubscriptionStorage } from '../SubscriptionStorage';\nimport type { WebSocket2021Handler, WebSocket2021HandlerInput } from './WebSocket2021Handler';\n\n/**\n * Keeps track of the WebSockets that were opened for a WebSocketSubscription2021 subscription\n * and uses them to emit events when necessary.\n *\n * SingleThreaded since the opened WebSocket might not be stored in the same thread\n * as the one that emits a relevant event.\n *\n * `cleanupTimer` defines in minutes how often the stored WebSockets are closed\n * if their corresponding subscription has expired.\n * Defaults to 60 minutes.\n * Although the WebSocket connection might still be open,\n * if the subscription has expired no notifications will be sent.\n */\nexport class WebSocket2021Emitter extends AsyncHandler<NotificationEmitterInput | WebSocket2021HandlerInput>\n  implements NotificationEmitter, WebSocket2021Handler, SingleThreaded {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly storage: SubscriptionStorage;\n  private readonly webSockets: SetMultiMap<string, WebSocket>;\n\n  public constructor(storage: SubscriptionStorage, cleanupTimer = 60) {\n    super();\n\n    this.storage = storage;\n    this.webSockets = new WrappedSetMultiMap<string, WebSocket>();\n\n    const timer = setSafeInterval(this.logger,\n      'Failed to remove closed WebSockets',\n      this.closeExpiredSockets.bind(this),\n      cleanupTimer * 60 * 1000);\n    timer.unref();\n  }\n\n  public async handle(input: NotificationEmitterInput): Promise<void>;\n  public async handle(input: WebSocket2021HandlerInput): Promise<void>;\n  public async handle(input: NotificationEmitterInput | WebSocket2021HandlerInput): Promise<void> {\n    if (this.isWebSocket2021HandlerInput(input)) {\n      // Called as a WebSocket2021Handler: store the WebSocket\n      const { webSocket, info } = input;\n      this.webSockets.add(info.id, webSocket);\n      webSocket.on('error', (): boolean => this.webSockets.deleteEntry(info.id, webSocket));\n      webSocket.on('close', (): boolean => this.webSockets.deleteEntry(info.id, webSocket));\n    } else {\n      // Called as a NotificationEmitter: emit the notification\n      const webSockets = this.webSockets.get(input.info.id);\n      if (webSockets) {\n        const data = await readableToString(input.representation.data);\n        for (const webSocket of webSockets) {\n          webSocket.send(data);\n        }\n      } else {\n        input.representation.data.destroy();\n      }\n    }\n  }\n\n  private isWebSocket2021HandlerInput(input: NotificationEmitterInput | WebSocket2021HandlerInput):\n    input is WebSocket2021HandlerInput {\n    return Boolean((input as WebSocket2021HandlerInput).webSocket);\n  }\n\n  /**\n   * Close all WebSockets that are attached to a subscription that no longer exists.\n   */\n  private async closeExpiredSockets(): Promise<void> {\n    this.logger.debug('Closing expired WebSockets');\n    for (const [ id, sockets ] of this.webSockets.entrySets()) {\n      const result = await this.storage.get(id);\n      if (!result) {\n        for (const socket of sockets) {\n          // Due to the attached listener this also deletes the entries\n          socket.close();\n        }\n      }\n    }\n    this.logger.debug('Finished closing expired WebSockets');\n  }\n}\n"]}