"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationSubscriber = void 0;
const OkResponseDescription_1 = require("../../http/output/response/OkResponseDescription");
const LogUtil_1 = require("../../logging/LogUtil");
const ContentTypes_1 = require("../../util/ContentTypes");
const ErrorUtil_1 = require("../../util/errors/ErrorUtil");
const UnprocessableEntityHttpError_1 = require("../../util/errors/UnprocessableEntityHttpError");
const UnsupportedMediaTypeHttpError_1 = require("../../util/errors/UnsupportedMediaTypeHttpError");
const StreamUtil_1 = require("../../util/StreamUtil");
const OperationHttpHandler_1 = require("../OperationHttpHandler");
/**
 * Handles notification subscriptions.
 *
 * Uses the information from the provided {@link SubscriptionType} to validate the input
 * and verify the request has the required permissions available.
 */
class NotificationSubscriber extends OperationHttpHandler_1.OperationHttpHandler {
    constructor(args) {
        super();
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.subscriptionType = args.subscriptionType;
        this.credentialsExtractor = args.credentialsExtractor;
        this.permissionReader = args.permissionReader;
        this.authorizer = args.authorizer;
        this.maxDuration = (args.maxDuration ?? 0) * 60 * 1000;
    }
    async handle({ operation, request }) {
        if (operation.body.metadata.contentType !== ContentTypes_1.APPLICATION_LD_JSON) {
            throw new UnsupportedMediaTypeHttpError_1.UnsupportedMediaTypeHttpError('Subscribe bodies need to be application/ld+json.');
        }
        let subscription;
        try {
            const json = JSON.parse(await (0, StreamUtil_1.readableToString)(operation.body.data));
            subscription = await this.subscriptionType.schema.validate(json);
        }
        catch (error) {
            throw new UnprocessableEntityHttpError_1.UnprocessableEntityHttpError(`Unable to process subscription: ${(0, ErrorUtil_1.createErrorMessage)(error)}`);
        }
        if (this.maxDuration) {
            const duration = (subscription.expiration ?? Number.POSITIVE_INFINITY) - Date.now();
            if (duration > this.maxDuration) {
                subscription.expiration = Date.now() + this.maxDuration;
            }
        }
        // Verify if the client is allowed to subscribe
        const credentials = await this.authorize(request, subscription);
        const { response } = await this.subscriptionType.subscribe(subscription, credentials);
        return new OkResponseDescription_1.OkResponseDescription(response.metadata, response.data);
    }
    async authorize(request, subscription) {
        const credentials = await this.credentialsExtractor.handleSafe(request);
        this.logger.debug(`Extracted credentials: ${JSON.stringify(credentials)}`);
        const requestedModes = await this.subscriptionType.extractModes(subscription);
        this.logger.debug(`Retrieved required modes: ${[...requestedModes.entrySets()]}`);
        const availablePermissions = await this.permissionReader.handleSafe({ credentials, requestedModes });
        this.logger.debug(`Available permissions are ${[...availablePermissions.entries()]}`);
        await this.authorizer.handleSafe({ credentials, requestedModes, availablePermissions });
        this.logger.verbose(`Authorization succeeded, creating subscription`);
        return credentials;
    }
}
exports.NotificationSubscriber = NotificationSubscriber;
//# sourceMappingURL=NotificationSubscriber.js.map