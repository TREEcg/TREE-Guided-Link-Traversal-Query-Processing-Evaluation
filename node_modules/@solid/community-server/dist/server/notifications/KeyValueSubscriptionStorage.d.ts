import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';
import type { KeyValueStorage } from '../../storage/keyvalue/KeyValueStorage';
import type { ReadWriteLocker } from '../../util/locking/ReadWriteLocker';
import type { Subscription } from './Subscription';
import type { SubscriptionInfo, SubscriptionStorage } from './SubscriptionStorage';
declare type StorageValue<T> = string | string[] | SubscriptionInfo<T>;
/**
 * Stores all the {@link SubscriptionInfo} in a {@link KeyValueStorage}.
 *
 * Uses a {@link ReadWriteLocker} to prevent internal race conditions.
 */
export declare class KeyValueSubscriptionStorage<T extends Record<string, unknown>> implements SubscriptionStorage<T> {
    protected logger: import("../..").Logger;
    private readonly storage;
    private readonly locker;
    constructor(storage: KeyValueStorage<string, StorageValue<T>>, locker: ReadWriteLocker);
    create(subscription: Subscription, features: T): SubscriptionInfo<T>;
    get(id: string): Promise<SubscriptionInfo<T> | undefined>;
    getAll(topic: ResourceIdentifier): Promise<string[]>;
    add(info: SubscriptionInfo<T>): Promise<void>;
    update(info: SubscriptionInfo<T>): Promise<void>;
    delete(id: string): Promise<void>;
    /**
     * Utility function for deleting a specific {@link SubscriptionInfo} object.
     * Does not create a lock on the subscription ID so should be wrapped in such a lock.
     */
    private deleteInfo;
    private isSubscriptionInfo;
    private getLockKey;
}
export {};
