{"version":3,"file":"NotificationSubscriber.js","sourceRoot":"","sources":["../../../src/server/notifications/NotificationSubscriber.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Credentials } from '../../authentication/Credentials';\nimport type { CredentialsExtractor } from '../../authentication/CredentialsExtractor';\nimport type { Authorizer } from '../../authorization/Authorizer';\nimport type { PermissionReader } from '../../authorization/PermissionReader';\nimport { OkResponseDescription } from '../../http/output/response/OkResponseDescription';\nimport type { ResponseDescription } from '../../http/output/response/ResponseDescription';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { APPLICATION_LD_JSON } from '../../util/ContentTypes';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport { UnprocessableEntityHttpError } from '../../util/errors/UnprocessableEntityHttpError';\nimport { UnsupportedMediaTypeHttpError } from '../../util/errors/UnsupportedMediaTypeHttpError';\nimport { readableToString } from '../../util/StreamUtil';\nimport type { HttpRequest } from '../HttpRequest';\nimport type { OperationHttpHandlerInput } from '../OperationHttpHandler';\nimport { OperationHttpHandler } from '../OperationHttpHandler';\nimport type { Subscription } from './Subscription';\nimport type { SubscriptionType } from './SubscriptionType';\n\nexport interface NotificationSubscriberArgs {\n  /**\n   * The {@link SubscriptionType} with all the necessary information.\n   */\n  subscriptionType: SubscriptionType;\n  /**\n   * Used to extract the credentials from the request.\n   */\n  credentialsExtractor: CredentialsExtractor;\n  /**\n   * Used to determine which permissions the found credentials have.\n   */\n  permissionReader: PermissionReader;\n  /**\n   * Used to determine if the request has the necessary permissions.\n   */\n  authorizer: Authorizer;\n  /**\n   * Overrides the expiration feature of subscriptions by making sure they always expire after the `maxDuration` value.\n   * In case the expiration of the subscription is shorter than `maxDuration` the original value will be kept.\n   * Value is set in minutes. 0 is infinite.\n   */\n  maxDuration?: number;\n}\n\n/**\n * Handles notification subscriptions.\n *\n * Uses the information from the provided {@link SubscriptionType} to validate the input\n * and verify the request has the required permissions available.\n */\nexport class NotificationSubscriber extends OperationHttpHandler {\n  protected logger = getLoggerFor(this);\n\n  private readonly subscriptionType: SubscriptionType;\n  private readonly credentialsExtractor: CredentialsExtractor;\n  private readonly permissionReader: PermissionReader;\n  private readonly authorizer: Authorizer;\n  private readonly maxDuration: number;\n\n  public constructor(args: NotificationSubscriberArgs) {\n    super();\n    this.subscriptionType = args.subscriptionType;\n    this.credentialsExtractor = args.credentialsExtractor;\n    this.permissionReader = args.permissionReader;\n    this.authorizer = args.authorizer;\n    this.maxDuration = (args.maxDuration ?? 0) * 60 * 1000;\n  }\n\n  public async handle({ operation, request }: OperationHttpHandlerInput): Promise<ResponseDescription> {\n    if (operation.body.metadata.contentType !== APPLICATION_LD_JSON) {\n      throw new UnsupportedMediaTypeHttpError('Subscribe bodies need to be application/ld+json.');\n    }\n\n    let subscription: Subscription;\n    try {\n      const json = JSON.parse(await readableToString(operation.body.data));\n      subscription = await this.subscriptionType.schema.validate(json);\n    } catch (error: unknown) {\n      throw new UnprocessableEntityHttpError(`Unable to process subscription: ${createErrorMessage(error)}`);\n    }\n\n    if (this.maxDuration) {\n      const duration = (subscription.expiration ?? Number.POSITIVE_INFINITY) - Date.now();\n      if (duration > this.maxDuration) {\n        subscription.expiration = Date.now() + this.maxDuration;\n      }\n    }\n\n    // Verify if the client is allowed to subscribe\n    const credentials = await this.authorize(request, subscription);\n\n    const { response } = await this.subscriptionType.subscribe(subscription, credentials);\n\n    return new OkResponseDescription(response.metadata, response.data);\n  }\n\n  private async authorize(request: HttpRequest, subscription: Subscription): Promise<Credentials> {\n    const credentials = await this.credentialsExtractor.handleSafe(request);\n    this.logger.debug(`Extracted credentials: ${JSON.stringify(credentials)}`);\n\n    const requestedModes = await this.subscriptionType.extractModes(subscription);\n    this.logger.debug(`Retrieved required modes: ${[ ...requestedModes.entrySets() ]}`);\n\n    const availablePermissions = await this.permissionReader.handleSafe({ credentials, requestedModes });\n    this.logger.debug(`Available permissions are ${[ ...availablePermissions.entries() ]}`);\n\n    await this.authorizer.handleSafe({ credentials, requestedModes, availablePermissions });\n    this.logger.verbose(`Authorization succeeded, creating subscription`);\n\n    return credentials;\n  }\n}\n"]}