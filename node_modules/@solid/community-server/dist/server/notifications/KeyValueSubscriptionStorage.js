"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyValueSubscriptionStorage = void 0;
const uuid_1 = require("uuid");
const LogUtil_1 = require("../../logging/LogUtil");
const InternalServerError_1 = require("../../util/errors/InternalServerError");
/**
 * Stores all the {@link SubscriptionInfo} in a {@link KeyValueStorage}.
 *
 * Uses a {@link ReadWriteLocker} to prevent internal race conditions.
 */
class KeyValueSubscriptionStorage {
    constructor(storage, locker) {
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.storage = storage;
        this.locker = locker;
    }
    create(subscription, features) {
        return {
            id: `${subscription.type}:${(0, uuid_1.v4)()}:${subscription.topic}`,
            topic: subscription.topic,
            type: subscription.type,
            lastEmit: 0,
            expiration: subscription.expiration,
            accept: subscription.accept,
            rate: subscription.rate,
            state: subscription.state,
            features,
        };
    }
    async get(id) {
        const info = await this.storage.get(id);
        if (info && this.isSubscriptionInfo(info)) {
            if (typeof info.expiration === 'number' && info.expiration < Date.now()) {
                this.logger.info(`Subscription ${id} has expired.`);
                await this.locker.withWriteLock(this.getLockKey(id), async () => {
                    await this.deleteInfo(info);
                });
                return;
            }
            return info;
        }
    }
    async getAll(topic) {
        const infos = await this.storage.get(topic.path);
        if (Array.isArray(infos)) {
            return infos;
        }
        return [];
    }
    async add(info) {
        const target = { path: info.topic };
        return this.locker.withWriteLock(this.getLockKey(target), async () => {
            const infos = await this.getAll(target);
            await this.storage.set(info.id, info);
            infos.push(info.id);
            await this.storage.set(info.topic, infos);
        });
    }
    async update(info) {
        return this.locker.withWriteLock(this.getLockKey(info.id), async () => {
            const oldInfo = await this.storage.get(info.id);
            if (oldInfo) {
                if (!this.isSubscriptionInfo(oldInfo)) {
                    throw new InternalServerError_1.InternalServerError(`Trying to update ${info.id} which is not a SubscriptionInfo.`);
                }
                if (info.topic !== oldInfo.topic) {
                    throw new InternalServerError_1.InternalServerError(`Trying to change the topic of subscription ${info.id}`);
                }
            }
            await this.storage.set(info.id, info);
        });
    }
    async delete(id) {
        return this.locker.withWriteLock(this.getLockKey(id), async () => {
            const info = await this.get(id);
            if (!info) {
                return;
            }
            await this.deleteInfo(info);
        });
    }
    /**
     * Utility function for deleting a specific {@link SubscriptionInfo} object.
     * Does not create a lock on the subscription ID so should be wrapped in such a lock.
     */
    async deleteInfo(info) {
        await this.locker.withWriteLock(this.getLockKey(info.topic), async () => {
            const infos = await this.getAll({ path: info.topic });
            const idx = infos.indexOf(info.id);
            // If idx < 0 we have an inconsistency
            if (idx < 0) {
                this.logger.error(`Subscription info ${info.id} was not found in the list of info targeting ${info.topic}.`);
                this.logger.error('This should not happen and indicates a data consistency issue.');
            }
            else {
                infos.splice(idx, 1);
                if (infos.length > 0) {
                    await this.storage.set(info.topic, infos);
                }
                else {
                    await this.storage.delete(info.topic);
                }
            }
            await this.storage.delete(info.id);
        });
    }
    isSubscriptionInfo(value) {
        return Boolean(value.id);
    }
    getLockKey(identifier) {
        return { path: `${typeof identifier === 'string' ? identifier : identifier.path}.notification-storage` };
    }
}
exports.KeyValueSubscriptionStorage = KeyValueSubscriptionStorage;
//# sourceMappingURL=KeyValueSubscriptionStorage.js.map