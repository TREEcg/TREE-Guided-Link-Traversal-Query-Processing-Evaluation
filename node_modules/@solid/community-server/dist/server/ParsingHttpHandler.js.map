{"version":3,"file":"ParsingHttpHandler.js","sourceRoot":"","sources":["../../src/server/ParsingHttpHandler.ts"],"names":[],"mappings":";;;AAKA,gDAAkD;AAClD,wDAAuD;AACvD,wDAAqD;AAErD,+CAA4C;AA4B5C;;;;GAIG;AACH,MAAa,kBAAmB,SAAQ,yBAAW;IASjD,YAAmB,IAA4B;QAC7C,KAAK,EAAE,CAAC;QATO,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAU3C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAChD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;IAChD,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAoB;QACzD,IAAI,MAA2B,CAAC;QAEhC,IAAI;YACF,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SACtD;QAAC,OAAO,KAAc,EAAE;YACvB,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;SACjD;QAED,IAAI,MAAM,EAAE;YACV,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;SAC5D;IACH,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,aAAa,CAAC,OAAoB,EAAE,QAAsB;QAExE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAC/D,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;QAExF,IAAI,MAAM,EAAE,QAAQ,EAAE;YACpB,MAAM,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;SACnF;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,SAAS,CAAC,MAAM,iBAAiB,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;QACxF,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,WAAW,CAAC,KAAc,EAAE,OAAoB;QAC9D,IAAA,uBAAW,EAAC,KAAK,CAAC,CAAC;QACnB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC;QACtE,IAAI,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,QAAQ,EAAE;YAClD,MAAM,KAAK,GAAG,KAAK,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACjE,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;SACjC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA5DD,gDA4DC","sourcesContent":["import type { RequestParser } from '../http/input/RequestParser';\nimport type { OperationMetadataCollector } from '../http/ldp/metadata/OperationMetadataCollector';\nimport type { ErrorHandler } from '../http/output/error/ErrorHandler';\nimport type { ResponseDescription } from '../http/output/response/ResponseDescription';\nimport type { ResponseWriter } from '../http/output/ResponseWriter';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { assertError } from '../util/errors/ErrorUtil';\nimport { HttpError } from '../util/errors/HttpError';\nimport type { HttpHandlerInput } from './HttpHandler';\nimport { HttpHandler } from './HttpHandler';\nimport type { HttpRequest } from './HttpRequest';\nimport type { HttpResponse } from './HttpResponse';\nimport type { OperationHttpHandler } from './OperationHttpHandler';\n\nexport interface ParsingHttpHandlerArgs {\n  /**\n   * Parses the incoming requests.\n   */\n  requestParser: RequestParser;\n  /**\n   * Generates generic operation metadata that is required for a response.\n   */\n  metadataCollector: OperationMetadataCollector;\n  /**\n   * Converts errors to a serializable format.\n   */\n  errorHandler: ErrorHandler;\n  /**\n   * Writes out the response of the operation.\n   */\n  responseWriter: ResponseWriter;\n  /**\n   * Handler to send the operation to.\n   */\n  operationHandler: OperationHttpHandler;\n}\n\n/**\n * Parses requests and sends the resulting {@link Operation} to the wrapped {@link OperationHttpHandler}.\n * Errors are caught and handled by the {@link ErrorHandler}.\n * In case the {@link OperationHttpHandler} returns a result it will be sent to the {@link ResponseWriter}.\n */\nexport class ParsingHttpHandler extends HttpHandler {\n  private readonly logger = getLoggerFor(this);\n\n  private readonly requestParser: RequestParser;\n  private readonly errorHandler: ErrorHandler;\n  private readonly responseWriter: ResponseWriter;\n  private readonly metadataCollector: OperationMetadataCollector;\n  private readonly operationHandler: OperationHttpHandler;\n\n  public constructor(args: ParsingHttpHandlerArgs) {\n    super();\n    this.requestParser = args.requestParser;\n    this.errorHandler = args.errorHandler;\n    this.responseWriter = args.responseWriter;\n    this.metadataCollector = args.metadataCollector;\n    this.operationHandler = args.operationHandler;\n  }\n\n  public async handle({ request, response }: HttpHandlerInput): Promise<void> {\n    let result: ResponseDescription;\n\n    try {\n      result = await this.handleRequest(request, response);\n    } catch (error: unknown) {\n      result = await this.handleError(error, request);\n    }\n\n    if (result) {\n      await this.responseWriter.handleSafe({ response, result });\n    }\n  }\n\n  /**\n   * Interprets the request and passes the generated Operation object to the stored OperationHttpHandler.\n   */\n  protected async handleRequest(request: HttpRequest, response: HttpResponse):\n  Promise<ResponseDescription> {\n    const operation = await this.requestParser.handleSafe(request);\n    const result = await this.operationHandler.handleSafe({ operation, request, response });\n\n    if (result?.metadata) {\n      await this.metadataCollector.handleSafe({ operation, metadata: result.metadata });\n    }\n\n    this.logger.verbose(`Parsed ${operation.method} operation on ${operation.target.path}`);\n    return result;\n  }\n\n  /**\n   * Handles the error output correctly based on the preferences.\n   */\n  protected async handleError(error: unknown, request: HttpRequest): Promise<ResponseDescription> {\n    assertError(error);\n    const result = await this.errorHandler.handleSafe({ error, request });\n    if (HttpError.isInstance(error) && result.metadata) {\n      const quads = error.generateMetadata(result.metadata.identifier);\n      result.metadata.addQuads(quads);\n    }\n    return result;\n  }\n}\n"]}