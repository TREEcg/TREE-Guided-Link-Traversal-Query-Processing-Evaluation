"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerServerListener = void 0;
const LogUtil_1 = require("../logging/LogUtil");
const ErrorUtil_1 = require("../util/errors/ErrorUtil");
const GuardedStream_1 = require("../util/GuardedStream");
const ServerListener_1 = require("./ServerListener");
/**
 * A {@link ServerListener} that attaches an {@link HttpHandler} to the `request` event of a {@link Server}.
 * All incoming requests will be sent to the provided handler.
 * Failsafes are added to make sure a valid response is sent in case something goes wrong.
 *
 * The `showStackTrace` parameter can be used to add stack traces to error outputs.
 */
class HandlerServerListener extends ServerListener_1.ServerListener {
    constructor(handler, showStackTrace = false) {
        super();
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.handler = handler;
        this.showStackTrace = showStackTrace;
    }
    async handle(server) {
        server.on('request', async (request, response) => {
            try {
                this.logger.info(`Received ${request.method} request for ${request.url}`);
                const guardedRequest = (0, GuardedStream_1.guardStream)(request);
                guardedRequest.on('error', (error) => {
                    this.logger.error(`Request error: ${error.message}`);
                });
                await this.handler.handleSafe({ request: guardedRequest, response });
            }
            catch (error) {
                let errMsg;
                if (!(0, ErrorUtil_1.isError)(error)) {
                    errMsg = `Unknown error: ${error}.\n`;
                }
                else if (this.showStackTrace && error.stack) {
                    errMsg = `${error.stack}\n`;
                }
                else {
                    errMsg = `${error.name}: ${error.message}\n`;
                }
                this.logger.error(errMsg);
                if (response.headersSent) {
                    response.end();
                }
                else {
                    response.setHeader('Content-Type', 'text/plain; charset=utf-8');
                    response.writeHead(500).end(errMsg);
                }
            }
            finally {
                if (!response.headersSent) {
                    response.writeHead(404).end();
                }
            }
        });
    }
}
exports.HandlerServerListener = HandlerServerListener;
//# sourceMappingURL=HandlerServerListener.js.map