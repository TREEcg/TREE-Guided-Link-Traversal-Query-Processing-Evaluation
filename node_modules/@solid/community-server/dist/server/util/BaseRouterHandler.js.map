{"version":3,"file":"BaseRouterHandler.js","sourceRoot":"","sources":["../../../src/server/util/BaseRouterHandler.ts"],"names":[],"mappings":";;;AACA,2FAAwF;AACxF,2EAAwE;AAExE,mEAAgE;AAChE,kDAA0D;AA0B1D;;;;;;GAMG;AACH,MAAsB,iBACpB,SAAQ,2BAAyD;IAOjE,YAAsB,IAA8B;QAClD,KAAK,EAAE,CAAC;QACR,IAAI,OAAO,IAAI,CAAC,gBAAgB,KAAK,WAAW,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,QAAQ,EAAE;YACpF,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;SACjF;QACD,wDAAwD;QACxD,IAAI,CAAC,aAAa,GAAG,IAAA,8BAAmB,EAAC,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC;QACpE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,CAAE,GAAG,CAAE,CAAC;QACrD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QACpD,IAAI,CAAC,qBAAqB,GAAG,CAAC,IAAI,CAAC,gBAAgB,IAAI,CAAE,IAAI,CAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,EAAU,EAAE,CAAC,IAAI,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;IAC5G,CAAC;IAES,KAAK,CAAC,cAAc,CAAC,KAA2B,EAAE,MAAc,EAAE,MAA0B;QAEpG,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;YAC7D,MAAM,IAAI,qDAAyB,CAAC,CAAE,MAAM,CAAE,EAAE,GAAG,MAAM,kBAAkB,CAAC,CAAC;SAC9E;QACD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACvD,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,KAAK,EAAW,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;YAC9E,MAAM,IAAI,qCAAiB,CAAC,uBAAuB,QAAQ,EAAE,CAAC,CAAC;SAChE;QACD,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA2B;QAC7C,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;CACF;AApCD,8CAoCC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { MethodNotAllowedHttpError } from '../../util/errors/MethodNotAllowedHttpError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport type { AsyncHandlerInput, AsyncHandlerOutput } from '../../util/handlers/AsyncHandler';\nimport { AsyncHandler } from '../../util/handlers/AsyncHandler';\nimport { trimTrailingSlashes } from '../../util/PathUtil';\n\nexport interface BaseRouterHandlerArgs<T extends AsyncHandler<any, any>> {\n  /**\n   * The base URL of the server.\n   * Not required if no value is provided for `allowedPathNames`.\n   */\n  baseUrl?: string;\n  /**\n   * The handler to call if all checks pass.\n   */\n  handler: T;\n  /**\n   * The allowed method(s). `*` can be used to indicate all methods are allowed.\n   * Default is `[ '*' ]`.\n   */\n  allowedMethods?: string[];\n  /**\n   * Regular expression(s) used to match the target URL.\n   * The base URl without trailing slash will be stripped of before applying the regular expressions,\n   * so the input will always start with a `/`.\n   * Default is `[ '.*' ]`.\n   */\n  allowedPathNames?: string[];\n}\n\n/**\n * Checks if a given method and path are satisfied and allows its handler to be executed if so.\n *\n * Implementations of this class should call `canHandleInput` in their `canHandle` call with the correct parameters.\n *\n * `canHandleInput` expects a ResourceIdentifier to indicate it expects the target to have been validated already.\n */\nexport abstract class BaseRouterHandler<T extends AsyncHandler<any, any>>\n  extends AsyncHandler<AsyncHandlerInput<T>, AsyncHandlerOutput<T>> {\n  protected readonly baseUrlLength: number;\n  protected readonly handler: T;\n  protected readonly allowedMethods: string[];\n  protected readonly allMethods: boolean;\n  protected readonly allowedPathNamesRegEx: RegExp[];\n\n  protected constructor(args: BaseRouterHandlerArgs<T>) {\n    super();\n    if (typeof args.allowedPathNames !== 'undefined' && typeof args.baseUrl !== 'string') {\n      throw new Error('A value for allowedPathNames requires baseUrl to be defined.');\n    }\n    // Trimming trailing slash so regexes can start with `/`\n    this.baseUrlLength = trimTrailingSlashes(args.baseUrl ?? '').length;\n    this.handler = args.handler;\n    this.allowedMethods = args.allowedMethods ?? [ '*' ];\n    this.allMethods = this.allowedMethods.includes('*');\n    this.allowedPathNamesRegEx = (args.allowedPathNames ?? [ '.*' ]).map((pn): RegExp => new RegExp(pn, 'u'));\n  }\n\n  protected async canHandleInput(input: AsyncHandlerInput<T>, method: string, target: ResourceIdentifier):\n  Promise<void> {\n    if (!this.allMethods && !this.allowedMethods.includes(method)) {\n      throw new MethodNotAllowedHttpError([ method ], `${method} is not allowed.`);\n    }\n    const pathName = target.path.slice(this.baseUrlLength);\n    if (!this.allowedPathNamesRegEx.some((regex): boolean => regex.test(pathName))) {\n      throw new NotFoundHttpError(`Cannot handle route ${pathName}`);\n    }\n    await this.handler.canHandle(input);\n  }\n\n  public async handle(input: AsyncHandlerInput<T>): Promise<AsyncHandlerOutput<T>> {\n    return this.handler.handle(input);\n  }\n}\n"]}