{"version":3,"file":"RegexRouterRule.js","sourceRoot":"","sources":["../../../src/storage/routing/RegexRouterRule.ts"],"names":[],"mappings":";;;AAEA,+EAA4E;AAC5E,uFAAoF;AACpF,kDAA0D;AAE1D,6CAA0C;AAE1C;;GAEG;AACH,MAAa,SAAS;IAIpB,YAAmB,KAAa,EAAE,KAAoB;QACpD,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACpC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;CACF;AARD,8BAQC;AAED;;;;;;;GAOG;AACH,MAAa,eAAgB,SAAQ,uBAAU;IAI7C;;OAEG;IACH,YAAmB,IAAY,EAAE,KAAkB;QACjD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,IAAI,GAAG,IAAA,8BAAmB,EAAC,IAAI,CAAC,CAAC;QACtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAA0E;QAC/F,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACpC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAyC;QAC3D,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAC3C,CAAC;IAED;;;OAGG;IACK,UAAU,CAAC,UAA8B;QAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QACzC,KAAK,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,IAAI,CAAC,KAAK,EAAE;YACzC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACpB,OAAO,KAAK,CAAC;aACd;SACF;QACD,MAAM,IAAI,iDAAuB,CAAC,2BAA2B,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;IAClF,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,UAA8B;QAC/C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC1C,MAAM,IAAI,yCAAmB,CAAC,kCAAkC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;SAC9E;QACD,OAAO,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACjD,CAAC;CACF;AA5CD,0CA4CC","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { trimTrailingSlashes } from '../../util/PathUtil';\nimport type { ResourceStore } from '../ResourceStore';\nimport { RouterRule } from './RouterRule';\n\n/**\n * Utility class to easily configure Regex to ResourceStore mappings in the config files.\n */\nexport class RegexRule {\n  public readonly regex: RegExp;\n  public readonly store: ResourceStore;\n\n  public constructor(regex: string, store: ResourceStore) {\n    this.regex = new RegExp(regex, 'u');\n    this.store = store;\n  }\n}\n\n/**\n * Routes requests to a store based on the path of the identifier.\n * The identifier will be stripped of the base URI after which regexes will be used to find the correct store.\n * The trailing slash of the base URI will still be present so the first character a regex can match would be that `/`.\n * This way regexes such as `/container/` can match containers in any position.\n *\n * In case none of the regexes match an error will be thrown.\n */\nexport class RegexRouterRule extends RouterRule {\n  private readonly base: string;\n  private readonly rules: RegexRule[];\n\n  /**\n   * The keys of the `storeMap` will be converted into actual RegExp objects that will be used for testing.\n   */\n  public constructor(base: string, rules: RegexRule[]) {\n    super();\n    this.base = trimTrailingSlashes(base);\n    this.rules = rules;\n  }\n\n  public async canHandle(input: { identifier: ResourceIdentifier; representation?: Representation }): Promise<void> {\n    this.matchStore(input.identifier);\n  }\n\n  public async handle(input: { identifier: ResourceIdentifier }): Promise<ResourceStore> {\n    return this.matchStore(input.identifier);\n  }\n\n  /**\n   * Finds the store corresponding to the regex that matches the given identifier.\n   * Throws an error if none is found.\n   */\n  private matchStore(identifier: ResourceIdentifier): ResourceStore {\n    const path = this.toRelative(identifier);\n    for (const { regex, store } of this.rules) {\n      if (regex.test(path)) {\n        return store;\n      }\n    }\n    throw new NotImplementedHttpError(`No stored regexes match ${identifier.path}`);\n  }\n\n  /**\n   * Strips the base of the identifier and throws an error if there is no overlap.\n   */\n  private toRelative(identifier: ResourceIdentifier): string {\n    if (!identifier.path.startsWith(this.base)) {\n      throw new BadRequestHttpError(`Identifiers need to start with ${this.base}`);\n    }\n    return identifier.path.slice(this.base.length);\n  }\n}\n"]}