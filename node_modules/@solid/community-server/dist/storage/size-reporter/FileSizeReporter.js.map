{"version":3,"file":"FileSizeReporter.js","sourceRoot":"","sources":["../../../src/storage/size-reporter/FileSizeReporter.ts"],"names":[],"mappings":";;;AACA,2BAA4C;AAG5C,kDAA2F;AAG3F,iCAAoC;AAGpC;;GAEG;AACH,MAAa,gBAAgB;IAK3B,YAAmB,oBAA0C,EAAE,YAAoB,EAAE,aAAwB;QAC3G,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;QACjD,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,MAAc,EAAU,EAAE,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACjH,IAAI,CAAC,YAAY,GAAG,IAAA,4BAAiB,EAAC,YAAY,CAAC,CAAC;IACtD,CAAC;IAED,wEAAwE;IACjE,OAAO;QACZ,OAAO,iBAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,UAA8B;QACjD,MAAM,YAAY,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC;QAEpG,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,MAAM,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,EAAE,CAAC;IACjF,CAAC;IAEM,KAAK,CAAC,kBAAkB,CAAC,KAAa;QAC3C,OAAO,KAAK,CAAC,MAAM,CAAC;IACtB,CAAC;IAED,4FAA4F;IACrF,KAAK,CAAC,YAAY,CAAC,QAAgC;QACxD,OAAO,QAAQ,CAAC,aAAa,CAAC;IAChC,CAAC;IAED;;;;;OAKG;IACK,KAAK,CAAC,YAAY,CAAC,YAAoB;QAC7C,IAAI,IAAW,CAAC;QAEhB,2BAA2B;QAC3B,IAAI;YACF,IAAI,GAAG,MAAM,aAAU,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;SAC5C;QAAC,MAAM;YACN,OAAO,CAAC,CAAC;SACV;QAED,yEAAyE;QACzE,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;YACjB,OAAO,IAAI,CAAC,IAAI,CAAC;SAClB;QAED,wEAAwE;QACxE,qDAAqD;QACrD,MAAM,UAAU,GAAG,MAAM,aAAU,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAC1D,MAAM,kBAAkB,GAAG,IAAA,8BAAmB,EAAC,IAAI,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC;QAEzE,OAAO,MAAM,UAAU,CAAC,MAAM,CAAC,KAAK,EAAC,GAAoB,EAAE,OAAO,EAAmB,EAAE;YACrF,MAAM,iBAAiB,GAAG,IAAA,4BAAiB,EAAC,IAAA,uBAAY,EAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;YACjF,IAAI,MAAM,GAAG,MAAM,GAAG,CAAC;YAEvB,yBAAyB;YACzB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,MAAc,EAAW,EAAE,CACvD,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC,EAAE;gBAC3D,MAAM,IAAI,MAAM,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC;aACtD;YAED,OAAO,MAAM,CAAC;QAChB,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjC,CAAC;CACF;AAzED,4CAyEC","sourcesContent":["import type { Stats } from 'fs';\nimport { promises as fsPromises } from 'fs';\nimport type { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { joinFilePath, normalizeFilePath, trimTrailingSlashes } from '../../util/PathUtil';\nimport type { FileIdentifierMapper } from '../mapping/FileIdentifierMapper';\nimport type { Size } from './Size';\nimport { UNIT_BYTES } from './Size';\nimport type { SizeReporter } from './SizeReporter';\n\n/**\n * SizeReporter that is used to calculate sizes of resources for a file based system.\n */\nexport class FileSizeReporter implements SizeReporter<string> {\n  private readonly fileIdentifierMapper: FileIdentifierMapper;\n  private readonly ignoreFolders: RegExp[];\n  private readonly rootFilePath: string;\n\n  public constructor(fileIdentifierMapper: FileIdentifierMapper, rootFilePath: string, ignoreFolders?: string[]) {\n    this.fileIdentifierMapper = fileIdentifierMapper;\n    this.ignoreFolders = ignoreFolders ? ignoreFolders.map((folder: string): RegExp => new RegExp(folder, 'u')) : [];\n    this.rootFilePath = normalizeFilePath(rootFilePath);\n  }\n\n  /** The FileSizeReporter will always return data in the form of bytes */\n  public getUnit(): string {\n    return UNIT_BYTES;\n  }\n\n  /**\n   * Returns the size of the given resource ( and its children ) in bytes\n   */\n  public async getSize(identifier: ResourceIdentifier): Promise<Size> {\n    const fileLocation = (await this.fileIdentifierMapper.mapUrlToFilePath(identifier, false)).filePath;\n\n    return { unit: this.getUnit(), amount: await this.getTotalSize(fileLocation) };\n  }\n\n  public async calculateChunkSize(chunk: string): Promise<number> {\n    return chunk.length;\n  }\n\n  /** The estimated size of a resource in this reporter is simply the content-length header */\n  public async estimateSize(metadata: RepresentationMetadata): Promise<number | undefined> {\n    return metadata.contentLength;\n  }\n\n  /**\n   * Get the total size of a resource and its children if present\n   *\n   * @param fileLocation - the resource of which you want the total size of ( on disk )\n   * @returns a number specifying how many bytes are used by the resource\n   */\n  private async getTotalSize(fileLocation: string): Promise<number> {\n    let stat: Stats;\n\n    // Check if the file exists\n    try {\n      stat = await fsPromises.stat(fileLocation);\n    } catch {\n      return 0;\n    }\n\n    // If the file's location points to a file, simply return the file's size\n    if (stat.isFile()) {\n      return stat.size;\n    }\n\n    // If the location DOES exist and is NOT a file it should be a directory\n    // recursively add all sizes of children to the total\n    const childFiles = await fsPromises.readdir(fileLocation);\n    const rootFilePathLength = trimTrailingSlashes(this.rootFilePath).length;\n\n    return await childFiles.reduce(async(acc: Promise<number>, current): Promise<number> => {\n      const childFileLocation = normalizeFilePath(joinFilePath(fileLocation, current));\n      let result = await acc;\n\n      // Exclude internal files\n      if (!this.ignoreFolders.some((folder: RegExp): boolean =>\n        folder.test(childFileLocation.slice(rootFilePathLength)))) {\n        result += await this.getTotalSize(childFileLocation);\n      }\n\n      return result;\n    }, Promise.resolve(stat.size));\n  }\n}\n"]}