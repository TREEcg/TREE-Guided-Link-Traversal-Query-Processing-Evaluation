{"version":3,"file":"RepresentationPatchHandler.js","sourceRoot":"","sources":["../../../src/storage/patch/RepresentationPatchHandler.ts"],"names":[],"mappings":";;;AACA,mDAAqD;AACrD,0DAAuD;AACvD,2EAAwE;AACxE,2EAAwE;AACxE,kDAA4D;AAG5D,iDAA8C;AAG9C;;;;;;GAMG;AACH,MAAa,0BAA2B,SAAQ,2BAAY;IAK1D,YAAmB,OAA8C;QAC/D,KAAK,EAAE,CAAC;QALS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAM7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,UAAU,EAAqB;QAClE,wCAAwC;QACxC,IAAI,cAA0C,CAAC;QAC/C,IAAI;YACF,0EAA0E;YAC1E,cAAc,GAAG,MAAM,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,2BAAY,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC,CAAC;SACvG;QAAC,OAAO,KAAc,EAAE;YACvB,2EAA2E;YAC3E,qFAAqF;YACrF,0EAA0E;YAC1E,IAAI,CAAC,qCAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;gBACxC,MAAM,KAAK,CAAC;aACb;YACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,yBAAyB,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;SAC/D;QAED,WAAW;QACX,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC;QAErF,2GAA2G;QAC3G,kFAAkF;QAClF,IAAI,IAAA,gCAAqB,EAAC,UAAU,CAAC,EAAE;YACrC,MAAM,IAAI,qCAAiB,CAAC,sDAAsD,CAAC,CAAC;SACrF;QAED,6BAA6B;QAC7B,OAAO,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;CACF;AAtCD,gEAsCC","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { INTERNAL_ALL } from '../../util/ContentTypes';\nimport { ConflictHttpError } from '../../util/errors/ConflictHttpError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { isContainerIdentifier } from '../../util/PathUtil';\nimport type { ChangeMap } from '../ResourceStore';\nimport type { PatchHandlerInput } from './PatchHandler';\nimport { PatchHandler } from './PatchHandler';\nimport type { RepresentationPatcher } from './RepresentationPatcher';\n\n/**\n * Handles a patch operation by getting the representation from the store, applying a `RepresentationPatcher`,\n * and then writing the result back to the store.\n *\n * In case there is no original representation (the store throws a `NotFoundHttpError`),\n * the patcher is expected to create a new one.\n */\nexport class RepresentationPatchHandler extends PatchHandler {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly patcher: RepresentationPatcher<Representation>;\n\n  public constructor(patcher: RepresentationPatcher<Representation>) {\n    super();\n    this.patcher = patcher;\n  }\n\n  public async handle({ source, patch, identifier }: PatchHandlerInput): Promise<ChangeMap> {\n    // Get the representation from the store\n    let representation: Representation | undefined;\n    try {\n      // Internal types are converted unless specified otherwise like we do here\n      representation = await source.getRepresentation(identifier, { type: { '*/*': 1, [INTERNAL_ALL]: 1 }});\n    } catch (error: unknown) {\n      // Solid, ยง5.1: \"When a successful PUT or PATCH request creates a resource,\n      // the server MUST use the effective request URI to assign the URI to that resource.\"\n      // https://solid.github.io/specification/protocol#resource-type-heuristics\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n      this.logger.debug(`Patching new resource ${identifier.path}`);\n    }\n\n    // Patch it\n    const patched = await this.patcher.handleSafe({ patch, identifier, representation });\n\n    // Solid, ยง5.3: \"Servers MUST NOT allow HTTP PUT or PATCH on a container to update its containment triples;\n    // if the server receives such a request, it MUST respond with a 409 status code.\"\n    if (isContainerIdentifier(identifier)) {\n      throw new ConflictHttpError('Not allowed to execute PATCH requests on containers.');\n    }\n\n    // Write it back to the store\n    return source.setRepresentation(identifier, patched);\n  }\n}\n"]}