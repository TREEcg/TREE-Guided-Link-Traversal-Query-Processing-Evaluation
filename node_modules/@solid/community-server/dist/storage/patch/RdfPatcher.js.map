{"version":3,"file":"RdfPatcher.js","sourceRoot":"","sources":["../../../src/storage/patch/RdfPatcher.ts"],"names":[],"mappings":";;;AACA,2BAA2B;AAC3B,uFAAoF;AAGpF,6FAA0F;AAC1F,mDAAqD;AACrD,0DAAyD;AACzD,+EAA4E;AAC5E,sDAAwD;AAExD,mEAAgE;AAEhE;;;GAGG;AACH,MAAa,UAAW,SAAQ,6CAAqC;IAKnE,YAAmB,OAAwD;QACzE,KAAK,EAAE,CAAC;QALS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAM7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,cAAc,EAA8C;QAEtG,IAAI,iBAAuD,CAAC;QAC5D,IAAI,cAAc,EAAE;YAClB,iBAAiB,GAAG,EAAE,GAAG,cAA0C,EAAE,OAAO,EAAE,IAAI,UAAK,EAAE,EAAE,CAAC;SAC7F;QACD,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,cAAc,EAAE,iBAAiB,EAAE,CAAC,CAAC;IACzF,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,cAAc,EAA8C;QAEnG,IAAI,QAAQ,GAAG,IAAI,+CAAsB,CAAC,UAAU,EAAE,6BAAc,CAAC,CAAC;QACtE,IAAI,cAAc,IAAI,cAAc,CAAC,QAAQ,CAAC,WAAW,KAAK,6BAAc,EAAE;YAC5E,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4FAA4F,CAAC,CAAC;YAChH,MAAM,IAAI,yCAAmB,CAAC,wCAAwC,CAAC,CAAC;SACzE;QAED,wCAAwC;QACxC,MAAM,mBAAmB,GAA6B,cAAc,CAAC,CAAC;YACpE,cAA0C,CAAC,CAAC;YAC5C,IAAI,yCAAmB,EAA8B,CAAC;QAExD,IAAI,cAAc,EAAE;YAClB,mBAAmB,CAAC,OAAO,GAAG,MAAM,IAAA,4BAAe,EAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACzE,CAAC,EAAE,QAAQ,EAAE,GAAG,cAAc,CAAC,CAAC;SACjC;aAAM;YACL,mBAAmB,CAAC,OAAO,GAAG,IAAI,UAAK,EAAE,CAAC;SAC3C;QAED,sBAAsB;QACtB,MAAM,qBAAqB,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YACtD,UAAU;YACV,KAAK;YACL,cAAc,EAAE,mBAAmB;SACpC,CAAC,CAAC;QAEH,4CAA4C;QAC5C,0EAA0E;QAC1E,MAAM,IAAI,GAAG,qBAAqB,CAAC,OAAO,CAAC,KAAK,EAAyB,CAAC;QAC1E,OAAO,IAAI,yCAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;IACxD,CAAC;CACF;AAnDD,gCAmDC","sourcesContent":["import type { Readable } from 'stream';\nimport { Store } from 'n3';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { RdfDatasetRepresentation } from '../../http/representation/RdfDatasetRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { readableToQuads } from '../../util/StreamUtil';\nimport type { RepresentationPatcherInput } from './RepresentationPatcher';\nimport { RepresentationPatcher } from './RepresentationPatcher';\n\n/**\n * Patcher that converts the representation data to a representation with an N3 store, does the patch using this store\n * and then converts the representation with store back to a representation with data which gets returned\n */\nexport class RdfPatcher extends RepresentationPatcher<Representation> {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly patcher: RepresentationPatcher<RdfDatasetRepresentation>;\n\n  public constructor(patcher: RepresentationPatcher<RdfDatasetRepresentation>) {\n    super();\n    this.patcher = patcher;\n  }\n\n  public async canHandle({ identifier, patch, representation }: RepresentationPatcherInput<Representation>):\n  Promise<void> {\n    let newRepresentation: RdfDatasetRepresentation | undefined;\n    if (representation) {\n      newRepresentation = { ...representation as RdfDatasetRepresentation, dataset: new Store() };\n    }\n    await this.patcher.canHandle({ identifier, patch, representation: newRepresentation });\n  }\n\n  public async handle({ identifier, patch, representation }: RepresentationPatcherInput<Representation>):\n  Promise<Representation> {\n    let metadata = new RepresentationMetadata(identifier, INTERNAL_QUADS);\n    if (representation && representation.metadata.contentType !== INTERNAL_QUADS) {\n      this.logger.error('Received non-quad data. This should not happen so there is probably a configuration error.');\n      throw new InternalServerError('Quad stream was expected for patching.');\n    }\n\n    // Drain representation data to N3 Store\n    const inputRepresentation: RdfDatasetRepresentation = representation ?\n      representation as RdfDatasetRepresentation :\n      new BasicRepresentation() as RdfDatasetRepresentation;\n\n    if (representation) {\n      inputRepresentation.dataset = await readableToQuads(representation.data);\n      ({ metadata } = representation);\n    } else {\n      inputRepresentation.dataset = new Store();\n    }\n\n    // Execute the patcher\n    const patchedRepresentation = await this.patcher.handle({\n      identifier,\n      patch,\n      representation: inputRepresentation,\n    });\n\n    // Return the n3 store to the representation\n    // This casting is necessary due to N3.js typings not being precise enough\n    const data = patchedRepresentation.dataset.match() as unknown as Readable;\n    return new BasicRepresentation(data, metadata, false);\n  }\n}\n"]}