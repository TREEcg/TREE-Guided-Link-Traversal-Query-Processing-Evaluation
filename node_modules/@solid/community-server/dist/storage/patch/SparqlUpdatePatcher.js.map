{"version":3,"file":"SparqlUpdatePatcher.js","sourceRoot":"","sources":["../../../src/storage/patch/SparqlUpdatePatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { QueryEngine } from '@comunica/query-sparql';\nimport type { Store } from 'n3';\nimport { DataFactory } from 'n3';\nimport { Algebra } from 'sparqlalgebrajs';\nimport type { Patch } from '../../http/representation/Patch';\nimport type { RdfDatasetRepresentation } from '../../http/representation/RdfDatasetRepresentation';\nimport type { SparqlUpdatePatch } from '../../http/representation/SparqlUpdatePatch';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { readableToString } from '../../util/StreamUtil';\nimport type { RdfStorePatcherInput } from './RdfStorePatcher';\nimport type { RepresentationPatcherInput } from './RepresentationPatcher';\nimport { RepresentationPatcher } from './RepresentationPatcher';\n\n/**\n * Supports application/sparql-update PATCH requests on RDF resources.\n *\n * Only DELETE/INSERT updates without variables are supported.\n */\nexport class SparqlUpdatePatcher extends RepresentationPatcher<RdfDatasetRepresentation> {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly engine: QueryEngine;\n\n  public constructor() {\n    super();\n    this.engine = new QueryEngine();\n  }\n\n  public async canHandle({ patch }: RepresentationPatcherInput<RdfDatasetRepresentation>): Promise<void> {\n    if (!this.isSparqlUpdate(patch)) {\n      throw new NotImplementedHttpError('Only SPARQL update patches are supported');\n    }\n  }\n\n  public async handle({ identifier, patch, representation }: RepresentationPatcherInput<RdfDatasetRepresentation>):\n  Promise<RdfDatasetRepresentation> {\n    // Verify the patch\n    const op = (patch as SparqlUpdatePatch).algebra;\n\n    if (!representation) {\n      throw new InternalServerError('Patcher requires a representation as input.');\n    }\n    const store = representation.dataset;\n\n    // In case of a NOP we can skip everything\n    if (op.type === Algebra.types.NOP) {\n      return representation;\n    }\n\n    this.validateUpdate(op);\n    await this.patch({\n      identifier,\n      patch,\n      store,\n    });\n    return representation;\n  }\n\n  private isSparqlUpdate(patch: Patch): patch is SparqlUpdatePatch {\n    return typeof (patch as SparqlUpdatePatch).algebra === 'object';\n  }\n\n  private isDeleteInsert(op: Algebra.Operation): op is Algebra.DeleteInsert {\n    return op.type === Algebra.types.DELETE_INSERT;\n  }\n\n  private isComposite(op: Algebra.Operation): op is Algebra.CompositeUpdate {\n    return op.type === Algebra.types.COMPOSITE_UPDATE;\n  }\n\n  /**\n   * Checks if the input operation is of a supported type (DELETE/INSERT or composite of those)\n   */\n  private validateUpdate(op: Algebra.Operation): void {\n    if (this.isDeleteInsert(op)) {\n      this.validateDeleteInsert(op);\n    } else if (this.isComposite(op)) {\n      this.validateComposite(op);\n    } else {\n      this.logger.warn(`Unsupported operation: ${op.type}`);\n      throw new NotImplementedHttpError('Only DELETE/INSERT SPARQL update operations are supported');\n    }\n  }\n\n  /**\n   * Checks if the input DELETE/INSERT is supported.\n   * This means: no GRAPH statements, no DELETE WHERE containing terms of type Variable.\n   */\n  private validateDeleteInsert(op: Algebra.DeleteInsert): void {\n    const def = DataFactory.defaultGraph();\n    const deletes = op.delete ?? [];\n    const inserts = op.insert ?? [];\n    if (!deletes.every((pattern): boolean => pattern.graph.equals(def))) {\n      this.logger.warn('GRAPH statement in DELETE clause');\n      throw new NotImplementedHttpError('GRAPH statements are not supported');\n    }\n    if (!inserts.every((pattern): boolean => pattern.graph.equals(def))) {\n      this.logger.warn('GRAPH statement in INSERT clause');\n      throw new NotImplementedHttpError('GRAPH statements are not supported');\n    }\n    if (!(typeof op.where === 'undefined' || op.where.type === Algebra.types.BGP)) {\n      this.logger.warn('Non-BGP WHERE statements are not supported');\n      throw new NotImplementedHttpError('Non-BGP WHERE statements are not supported');\n    }\n  }\n\n  /**\n   * Checks if the composite update only contains supported update components.\n   */\n  private validateComposite(op: Algebra.CompositeUpdate): void {\n    for (const update of op.updates) {\n      this.validateUpdate(update);\n    }\n  }\n\n  /**\n   * Apply the given algebra operation to the given identifier.\n   */\n  private async patch({ identifier, patch, store }: RdfStorePatcherInput): Promise<Store> {\n    const result = store;\n    this.logger.debug(`${result.size} quads in ${identifier.path}.`);\n\n    // Run the query through Comunica\n    const sparql = await readableToString(patch.data);\n    await this.engine.queryVoid(sparql, { sources: [ result ], baseIRI: identifier.path });\n\n    this.logger.debug(`${result.size} quads will be stored to ${identifier.path}.`);\n\n    return result;\n  }\n}\n"]}