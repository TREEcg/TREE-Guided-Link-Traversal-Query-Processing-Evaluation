"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonitoringStore = void 0;
const events_1 = require("events");
const Vocabularies_1 = require("../util/Vocabularies");
// The ActivityStream terms for which we emit an event
const emittedActivities = new Set([Vocabularies_1.AS.Create, Vocabularies_1.AS.Delete, Vocabularies_1.AS.Update]);
/**
 * Store that notifies listeners of changes to its source
 * by emitting a `changed` event.
 */
class MonitoringStore extends events_1.EventEmitter {
    constructor(source) {
        super();
        this.source = source;
    }
    async hasResource(identifier) {
        return this.source.hasResource(identifier);
    }
    async getRepresentation(identifier, preferences, conditions) {
        return this.source.getRepresentation(identifier, preferences, conditions);
    }
    async addResource(container, representation, conditions) {
        return this.emitChanged(await this.source.addResource(container, representation, conditions));
    }
    async deleteResource(identifier, conditions) {
        return this.emitChanged(await this.source.deleteResource(identifier, conditions));
    }
    async setRepresentation(identifier, representation, conditions) {
        return this.emitChanged(await this.source.setRepresentation(identifier, representation, conditions));
    }
    async modifyResource(identifier, patch, conditions) {
        return this.emitChanged(await this.source.modifyResource(identifier, patch, conditions));
    }
    emitChanged(changes) {
        for (const [identifier, metadata] of changes) {
            const activity = metadata.get(Vocabularies_1.SOLID_AS.terms.Activity);
            this.emit('changed', identifier, activity);
            if (activity && emittedActivities.has(activity.value)) {
                this.emit(activity.value, identifier);
            }
        }
        return changes;
    }
}
exports.MonitoringStore = MonitoringStore;
//# sourceMappingURL=MonitoringStore.js.map