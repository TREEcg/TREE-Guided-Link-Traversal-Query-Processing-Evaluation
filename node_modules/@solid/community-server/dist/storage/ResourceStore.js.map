{"version":3,"file":"ResourceStore.js","sourceRoot":"","sources":["../../src/storage/ResourceStore.ts"],"names":[],"mappings":"","sourcesContent":["import type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationMetadata } from '../http/representation/RepresentationMetadata';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport type { IdentifierMap } from '../util/map/IdentifierMap';\nimport type { Conditions } from './Conditions';\nimport type { ResourceSet } from './ResourceSet';\n\n/**\n * An {@link IdentifierMap} containing one entry for each resource that was created, updated or deleted\n * by this operation. Where the value is a {@link RepresentationMetadata}\n * containing extra information about the change of the resource.\n */\nexport type ChangeMap = IdentifierMap<RepresentationMetadata>;\n\n/**\n * A ResourceStore represents a collection of resources.\n * It has been designed such that each of its methods\n * can be implemented in an atomic way:  for each CRUD operation, only one\n * dedicated method needs to be called. A fifth method enables the optimization\n * of partial updates with PATCH. It is up to the implementer of the interface to\n * (not) make an implementation atomic.\n *\n * ResourceStores are also responsible for taking auxiliary resources into account\n * should those be relevant to the store.\n */\nexport interface ResourceStore extends ResourceSet {\n  /**\n   * Retrieves a representation of a resource.\n   * @param identifier - Identifier of the resource to read.\n   * @param preferences - Preferences indicating desired representations.\n   * @param conditions - Optional conditions under which to proceed.\n   *\n   * @returns A representation corresponding to the identifier.\n   */\n  getRepresentation: (\n    identifier: ResourceIdentifier,\n    preferences: RepresentationPreferences,\n    conditions?: Conditions,\n  ) => Promise<Representation>;\n\n  /**\n   * Sets or replaces the representation of a resource,\n   * creating a new resource and intermediary containers as needed.\n   * @param identifier - Identifier of resource to update.\n   * @param representation - New representation of the resource.\n   * @param conditions - Optional conditions under which to proceed.\n   *\n   * @returns A {@link ChangeMap}.\n   */\n  setRepresentation: (\n    identifier: ResourceIdentifier,\n    representation: Representation,\n    conditions?: Conditions,\n  ) => Promise<ChangeMap>;\n\n  /**\n   * Creates a new resource in the container.\n   * @param container - Container in which to create a resource.\n   * @param representation - Representation of the new resource\n   * @param conditions - Optional conditions under which to proceed.\n   *\n   * @returns A {@link ChangeMap}.\n   */\n  addResource: (\n    container: ResourceIdentifier,\n    representation: Representation,\n    conditions?: Conditions,\n  ) => Promise<ChangeMap>;\n\n  /**\n   * Deletes a resource.\n   * @param identifier - Identifier of resource to delete.\n   * @param conditions - Optional conditions under which to proceed.\n   *\n   * @returns A {@link ChangeMap}.\n   */\n  deleteResource: (\n    identifier: ResourceIdentifier,\n    conditions?: Conditions,\n  ) => Promise<ChangeMap>;\n\n  /**\n   * Sets or updates the representation of a resource,\n   * creating a new resource and intermediary containers as needed.\n   * @param identifier - Identifier of resource to update.\n   * @param patch - Description of which parts to update.\n   * @param conditions - Optional conditions under which to proceed.\n   *\n   * @returns A {@link ChangeMap}.\n   */\n  modifyResource: (\n    identifier: ResourceIdentifier,\n    patch: Patch,\n    conditions?: Conditions,\n  ) => Promise<ChangeMap>;\n}\n"]}