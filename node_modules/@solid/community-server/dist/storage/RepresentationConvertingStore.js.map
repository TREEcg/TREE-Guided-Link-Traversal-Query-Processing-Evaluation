{"version":3,"file":"RepresentationConvertingStore.js","sourceRoot":"","sources":["../../src/storage/RepresentationConvertingStore.ts"],"names":[],"mappings":";;;AAIA,gDAAkD;AAClD,uDAAsD;AAEtD,4EAAyE;AAEzE,yDAAsD;AAGtD;;GAEG;AACH,MAAa,6BAAuE,SAAQ,mCAAmB;IAQ7G;;OAEG;IACH,YAAmB,MAAS,EAAE,gBAAmC,EAAE,OAIlE;QACC,KAAK,CAAC,MAAM,CAAC,CAAC;QAfG,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAgB7C,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QACtD,IAAI,CAAC,WAAW,GAAG,WAAW,IAAI,IAAI,2CAAoB,EAAE,CAAC;QAC7D,IAAI,CAAC,YAAY,GAAG,YAAY,IAAI,IAAI,2CAAoB,EAAE,CAAC;QAC/D,IAAI,CAAC,aAAa,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC;IAC/D,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAAC,UAA8B,EAAE,WAAsC,EACnG,UAAuB;QACvB,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;QAC1F,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE,CAAC,CAAC;IACnF,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,UAA8B,EAAE,cAA8B,EACrF,UAAuB;QACvB,yFAAyF;QACzF,IAAI,cAAc,CAAC,QAAQ,CAAC,WAAW,EAAE;YACvC,4GAA4G;YAC5G,0DAA0D;YAC1D,cAAc,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAChD,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE,IAAI,CAAC,aAAa,EAAE,CAChE,CAAC;SACH;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,UAAU,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IACzE,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAAC,UAA8B,EAAE,cAA8B,EAC3F,UAAuB;QACvB,gGAAgG;QAChG,IAAI,IAAI,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,UAAU,CAAC,EAAE;YAC3D,cAAc,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAChD,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE,EAAE,IAAI,EAAE,EAAE,CAAC,6BAAc,CAAC,EAAE,CAAC,EAAE,EAAC,EAAC,CAC7E,CAAC;SACH;aAAM,IAAI,cAAc,CAAC,QAAQ,CAAC,WAAW,EAAE;YAC9C,cAAc,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAChD,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE,IAAI,CAAC,aAAa,EAAE,CAChE,CAAC;SACH;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IAC/E,CAAC;CACF;AAzDD,sEAyDC","sourcesContent":["import type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { INTERNAL_QUADS } from '../util/ContentTypes';\nimport type { Conditions } from './Conditions';\nimport { PassthroughConverter } from './conversion/PassthroughConverter';\nimport type { RepresentationConverter } from './conversion/RepresentationConverter';\nimport { PassthroughStore } from './PassthroughStore';\nimport type { ResourceStore, ChangeMap } from './ResourceStore';\n\n/**\n * Store that provides (optional) conversion of incoming and outgoing {@link Representation}s.\n */\nexport class RepresentationConvertingStore<T extends ResourceStore = ResourceStore> extends PassthroughStore<T> {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly metadataStrategy: AuxiliaryStrategy;\n  private readonly inConverter: RepresentationConverter;\n  private readonly outConverter: RepresentationConverter;\n  private readonly inPreferences: RepresentationPreferences;\n\n  /**\n   * TODO: This should take RepresentationPreferences instead of a type string when supported by Components.js.\n   */\n  public constructor(source: T, metadataStrategy: AuxiliaryStrategy, options: {\n    outConverter?: RepresentationConverter;\n    inConverter?: RepresentationConverter;\n    inType?: string;\n  }) {\n    super(source);\n    this.metadataStrategy = metadataStrategy;\n    const { inConverter, outConverter, inType } = options;\n    this.inConverter = inConverter ?? new PassthroughConverter();\n    this.outConverter = outConverter ?? new PassthroughConverter();\n    this.inPreferences = !inType ? {} : { type: { [inType]: 1 }};\n  }\n\n  public async getRepresentation(identifier: ResourceIdentifier, preferences: RepresentationPreferences,\n    conditions?: Conditions): Promise<Representation> {\n    const representation = await super.getRepresentation(identifier, preferences, conditions);\n    return this.outConverter.handleSafe({ identifier, representation, preferences });\n  }\n\n  public async addResource(identifier: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ChangeMap> {\n    // In case of containers, no content-type is required and the representation is not used.\n    if (representation.metadata.contentType) {\n      // We can potentially run into problems here if we convert a turtle document where the base IRI is required,\n      // since we don't know the resource IRI yet at this point.\n      representation = await this.inConverter.handleSafe(\n        { identifier, representation, preferences: this.inPreferences },\n      );\n    }\n    return this.source.addResource(identifier, representation, conditions);\n  }\n\n  public async setRepresentation(identifier: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ChangeMap> {\n    // When it is a metadata resource, convert it to Quads as those are expected in the later stores\n    if (this.metadataStrategy.isAuxiliaryIdentifier(identifier)) {\n      representation = await this.inConverter.handleSafe(\n        { identifier, representation, preferences: { type: { [INTERNAL_QUADS]: 1 }}},\n      );\n    } else if (representation.metadata.contentType) {\n      representation = await this.inConverter.handleSafe(\n        { identifier, representation, preferences: this.inPreferences },\n      );\n    }\n    return this.source.setRepresentation(identifier, representation, conditions);\n  }\n}\n"]}