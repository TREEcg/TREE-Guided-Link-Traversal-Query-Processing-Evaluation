{"version":3,"file":"AtomicFileDataAccessor.js","sourceRoot":"","sources":["../../../src/storage/accessors/AtomicFileDataAccessor.ts"],"names":[],"mappings":";;;AACA,uCAAyD;AACzD,+BAA0B;AAI1B,kDAAmD;AAGnD,yDAAsD;AAEtD;;;;GAIG;AACH,MAAa,sBAAuB,SAAQ,mCAAgB;IAG1D,YAAmB,cAAoC,EAAE,YAAoB,EAAE,YAAoB;QACjG,KAAK,CAAC,cAAc,CAAC,CAAC;QACtB,IAAI,CAAC,YAAY,GAAG,IAAA,uBAAY,EAAC,YAAY,EAAE,YAAY,CAAC,CAAC;QAC7D,IAAA,wBAAa,EAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACnC,CAAC;IAED;;;;;;OAMG;IACI,KAAK,CAAC,aAAa,CAAC,UAA8B,EAAE,IAAuB,EAAE,QAAgC;QAElH,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,CAAC,WAAW,CAAC,CAAC;QAEjG,+BAA+B;QAC/B,MAAM,YAAY,GAAG,IAAA,uBAAY,EAAC,IAAI,CAAC,YAAY,EAAE,QAAQ,IAAA,SAAE,GAAE,MAAM,CAAC,CAAC;QAEzE,IAAI;YACF,MAAM,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;YAE7C,2EAA2E;YAC3E,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;YAEzC,mEAAmE;YACnE,MAAM,IAAA,iBAAM,EAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC3C;QAAC,OAAO,KAAc,EAAE;YACvB,kCAAkC;YAClC,IAAI;gBACF,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,EAAE,EAAE;oBAChD,MAAM,IAAA,iBAAM,EAAC,YAAY,CAAC,CAAC;iBAC5B;aACF;YAAC,MAAM;gBACN,MAAM,KAAK,CAAC;aACb;YACD,MAAM,KAAK,CAAC;SACb;QACD,MAAM,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC/C,CAAC;CACF;AA5CD,wDA4CC","sourcesContent":["import type { Readable } from 'stream';\nimport { ensureDirSync, rename, unlink } from 'fs-extra';\nimport { v4 } from 'uuid';\nimport type { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { joinFilePath } from '../../util/PathUtil';\nimport type { FileIdentifierMapper } from '../mapping/FileIdentifierMapper';\nimport type { AtomicDataAccessor } from './AtomicDataAccessor';\nimport { FileDataAccessor } from './FileDataAccessor';\n\n/**\n * AtomicDataAccessor that uses the file system to store documents as files and containers as folders.\n * Data will first be written to a temporary location and only if no errors occur\n * will the data be written to the desired location.\n */\nexport class AtomicFileDataAccessor extends FileDataAccessor implements AtomicDataAccessor {\n  private readonly tempFilePath: string;\n\n  public constructor(resourceMapper: FileIdentifierMapper, rootFilePath: string, tempFilePath: string) {\n    super(resourceMapper);\n    this.tempFilePath = joinFilePath(rootFilePath, tempFilePath);\n    ensureDirSync(this.tempFilePath);\n  }\n\n  /**\n   * Writes the given data as a file (and potential metadata as additional file).\n   * Data will first be written to a temporary file and if no errors occur only then the\n   * file will be moved to desired destination.\n   * If the stream errors it is made sure the temporary file will be deleted.\n   * The metadata file will only be written if the data was written successfully.\n   */\n  public async writeDocument(identifier: ResourceIdentifier, data: Guarded<Readable>, metadata: RepresentationMetadata):\n  Promise<void> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false, metadata.contentType);\n\n    // Generate temporary file name\n    const tempFilePath = joinFilePath(this.tempFilePath, `temp-${v4()}.txt`);\n\n    try {\n      await this.writeDataFile(tempFilePath, data);\n\n      // Check if we already have a corresponding file with a different extension\n      await this.verifyExistingExtension(link);\n\n      // When no quota errors occur move the file to its desired location\n      await rename(tempFilePath, link.filePath);\n    } catch (error: unknown) {\n      // Delete the data already written\n      try {\n        if ((await this.getStats(tempFilePath)).isFile()) {\n          await unlink(tempFilePath);\n        }\n      } catch {\n        throw error;\n      }\n      throw error;\n    }\n    await this.writeMetadataFile(link, metadata);\n  }\n}\n"]}