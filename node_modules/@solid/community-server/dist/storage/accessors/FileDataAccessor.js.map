{"version":3,"file":"FileDataAccessor.js","sourceRoot":"","sources":["../../../src/storage/accessors/FileDataAccessor.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Readable } from 'stream';\nimport type { Stats } from 'fs-extra';\nimport { ensureDir, remove, stat, lstat, createWriteStream, createReadStream, opendir } from 'fs-extra';\nimport type { Quad } from 'rdf-js';\nimport type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { isSystemError } from '../../util/errors/SystemError';\nimport { UnsupportedMediaTypeHttpError } from '../../util/errors/UnsupportedMediaTypeHttpError';\nimport { guardStream } from '../../util/GuardedStream';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { parseContentType } from '../../util/HeaderUtil';\nimport { joinFilePath, isContainerIdentifier, isContainerPath } from '../../util/PathUtil';\nimport { parseQuads, serializeQuads } from '../../util/QuadUtil';\nimport { addResourceMetadata, updateModifiedDate } from '../../util/ResourceUtil';\nimport { toLiteral, toNamedTerm } from '../../util/TermUtil';\nimport { CONTENT_TYPE_TERM, DC, IANA, LDP, POSIX, RDF, SOLID_META, XSD } from '../../util/Vocabularies';\nimport type { FileIdentifierMapper, ResourceLink } from '../mapping/FileIdentifierMapper';\nimport type { DataAccessor } from './DataAccessor';\n\n/**\n * DataAccessor that uses the file system to store documents as files and containers as folders.\n */\nexport class FileDataAccessor implements DataAccessor {\n  protected readonly logger = getLoggerFor(this);\n\n  protected readonly resourceMapper: FileIdentifierMapper;\n\n  public constructor(resourceMapper: FileIdentifierMapper) {\n    this.resourceMapper = resourceMapper;\n  }\n\n  /**\n   * Only binary data can be directly stored as files so will error on non-binary data.\n   */\n  public async canHandle(representation: Representation): Promise<void> {\n    if (!representation.binary) {\n      throw new UnsupportedMediaTypeHttpError('Only binary data is supported.');\n    }\n  }\n\n  /**\n   * Will return data stream directly to the file corresponding to the resource.\n   * Will throw NotFoundHttpError if the input is a container.\n   */\n  public async getData(identifier: ResourceIdentifier): Promise<Guarded<Readable>> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    const stats = await this.getStats(link.filePath);\n\n    if (stats.isFile()) {\n      return guardStream(createReadStream(link.filePath));\n    }\n\n    throw new NotFoundHttpError();\n  }\n\n  /**\n   * Will return corresponding metadata by reading the metadata file (if it exists)\n   * and adding file system specific metadata elements.\n   */\n  public async getMetadata(identifier: ResourceIdentifier): Promise<RepresentationMetadata> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    const stats = await this.getStats(link.filePath);\n    if (!isContainerIdentifier(identifier) && stats.isFile()) {\n      return this.getFileMetadata(link, stats);\n    }\n    if (isContainerIdentifier(identifier) && stats.isDirectory()) {\n      return this.getDirectoryMetadata(link, stats);\n    }\n    throw new NotFoundHttpError();\n  }\n\n  public async* getChildren(identifier: ResourceIdentifier): AsyncIterableIterator<RepresentationMetadata> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    yield* this.getChildMetadata(link);\n  }\n\n  /**\n   * Writes the given data as a file (and potential metadata as additional file).\n   * The metadata file will be written first and will be deleted if something goes wrong writing the actual data.\n   */\n  public async writeDocument(identifier: ResourceIdentifier, data: Guarded<Readable>, metadata: RepresentationMetadata):\n  Promise<void> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false, metadata.contentType);\n\n    // Check if we already have a corresponding file with a different extension\n    await this.verifyExistingExtension(link);\n\n    const wroteMetadata = await this.writeMetadataFile(link, metadata);\n\n    try {\n      await this.writeDataFile(link.filePath, data);\n    } catch (error: unknown) {\n      // Delete the metadata if there was an error writing the file\n      if (wroteMetadata) {\n        const metaLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n        await remove(metaLink.filePath);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Creates corresponding folder if necessary and writes metadata to metadata file if necessary.\n   */\n  public async writeContainer(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    await ensureDir(link.filePath);\n\n    await this.writeMetadataFile(link, metadata);\n  }\n\n  public async writeMetadata(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    const metadataLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n    await this.writeMetadataFile(metadataLink, metadata);\n  }\n\n  /**\n   * Removes the corresponding file/folder (and metadata file).\n   */\n  public async deleteResource(identifier: ResourceIdentifier): Promise<void> {\n    const metaLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n    await remove(metaLink.filePath);\n\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    const stats = await this.getStats(link.filePath);\n\n    if (!isContainerIdentifier(identifier) && stats.isFile()) {\n      await remove(link.filePath);\n    } else if (isContainerIdentifier(identifier) && stats.isDirectory()) {\n      await remove(link.filePath);\n    } else {\n      throw new NotFoundHttpError();\n    }\n  }\n\n  /**\n   * Gets the Stats object corresponding to the given file path,\n   * resolving symbolic links.\n   * @param path - File path to get info from.\n   *\n   * @throws NotFoundHttpError\n   * If the file/folder doesn't exist.\n   */\n  protected async getStats(path: string): Promise<Stats> {\n    try {\n      return await stat(path);\n    } catch (error: unknown) {\n      if (isSystemError(error) && error.code === 'ENOENT') {\n        throw new NotFoundHttpError('', { cause: error });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Reads and generates all metadata relevant for the given file,\n   * ingesting it into a RepresentationMetadata object.\n   *\n   * @param link - Path related metadata.\n   * @param stats - Stats object of the corresponding file.\n   */\n  private async getFileMetadata(link: ResourceLink, stats: Stats):\n  Promise<RepresentationMetadata> {\n    const metadata = await this.getBaseMetadata(link, stats, false);\n    // If the resource is using an unsupported contentType, the original contentType was written to the metadata file.\n    // As a result, we should only set the contentType derived from the file path,\n    // when no previous metadata entry for contentType is present.\n    if (typeof metadata.contentType === 'undefined') {\n      metadata.set(CONTENT_TYPE_TERM, link.contentType);\n    }\n    return metadata;\n  }\n\n  /**\n   * Reads and generates all metadata relevant for the given directory,\n   * ingesting it into a RepresentationMetadata object.\n   *\n   * @param link - Path related metadata.\n   * @param stats - Stats object of the corresponding directory.\n   */\n  private async getDirectoryMetadata(link: ResourceLink, stats: Stats):\n  Promise<RepresentationMetadata> {\n    return await this.getBaseMetadata(link, stats, true);\n  }\n\n  /**\n   * Writes the metadata of the resource to a meta file.\n   * @param link - Path related metadata of the resource.\n   * @param metadata - Metadata to write.\n   *\n   * @returns True if data was written to a file.\n   */\n  protected async writeMetadataFile(link: ResourceLink, metadata: RepresentationMetadata): Promise<boolean> {\n    // These are stored by file system conventions\n    metadata.remove(RDF.terms.type, LDP.terms.Resource);\n    metadata.remove(RDF.terms.type, LDP.terms.Container);\n    metadata.remove(RDF.terms.type, LDP.terms.BasicContainer);\n    metadata.removeAll(DC.terms.modified);\n    // When writing metadata for a document, only remove the content-type when dealing with a supported media type.\n    // A media type is supported if the FileIdentifierMapper can correctly store it.\n    // This allows restoring the appropriate content-type on data read (see getFileMetadata).\n    if (isContainerPath(link.filePath) || typeof link.contentType !== 'undefined') {\n      metadata.removeAll(CONTENT_TYPE_TERM);\n    }\n    const quads = metadata.quads();\n    const metadataLink = await this.resourceMapper.mapUrlToFilePath(link.identifier, true);\n    let wroteMetadata: boolean;\n\n    // Write metadata to file if there are quads remaining\n    if (quads.length > 0) {\n      // Determine required content-type based on mapper\n      const serializedMetadata = serializeQuads(quads, metadataLink.contentType);\n      await this.writeDataFile(metadataLink.filePath, serializedMetadata);\n      wroteMetadata = true;\n\n    // Delete (potentially) existing metadata file if no metadata needs to be stored\n    } else {\n      await remove(metadataLink.filePath);\n      wroteMetadata = false;\n    }\n    return wroteMetadata;\n  }\n\n  /**\n   * Generates metadata relevant for any resources stored by this accessor.\n   * @param link - Path related metadata.\n   * @param stats - Stats objects of the corresponding directory.\n   * @param isContainer - If the path points to a container (directory) or not.\n   */\n  private async getBaseMetadata(link: ResourceLink, stats: Stats, isContainer: boolean):\n  Promise<RepresentationMetadata> {\n    const metadata = new RepresentationMetadata(link.identifier)\n      .addQuads(await this.getRawMetadata(link.identifier));\n    addResourceMetadata(metadata, isContainer);\n    this.addPosixMetadata(metadata, stats);\n    return metadata;\n  }\n\n  /**\n   * Reads the metadata from the corresponding metadata file.\n   * Returns an empty array if there is no metadata file.\n   *\n   * @param identifier - Identifier of the resource (not the metadata!).\n   */\n  private async getRawMetadata(identifier: ResourceIdentifier): Promise<Quad[]> {\n    try {\n      const metadataLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n\n      // Check if the metadata file exists first\n      await lstat(metadataLink.filePath);\n\n      const readMetadataStream = guardStream(createReadStream(metadataLink.filePath));\n      return await parseQuads(readMetadataStream, { format: metadataLink.contentType, baseIRI: identifier.path });\n    } catch (error: unknown) {\n      // Metadata file doesn't exist so lets keep `rawMetaData` an empty array.\n      if (!isSystemError(error) || error.code !== 'ENOENT') {\n        throw error;\n      }\n      return [];\n    }\n  }\n\n  /**\n   * Generate metadata for all children in a container.\n   *\n   * @param link - Path related metadata.\n   */\n  private async* getChildMetadata(link: ResourceLink): AsyncIterableIterator<RepresentationMetadata> {\n    const dir = await opendir(link.filePath);\n\n    // For every child in the container we want to generate specific metadata\n    for await (const entry of dir) {\n      // Obtain details of the entry, resolving any symbolic links\n      const childPath = joinFilePath(link.filePath, entry.name);\n      let childStats;\n      try {\n        childStats = await this.getStats(childPath);\n      } catch {\n        // Skip this entry if details could not be retrieved (e.g., bad symbolic link)\n        continue;\n      }\n\n      // Ignore non-file/directory entries in the folder\n      if (!childStats.isFile() && !childStats.isDirectory()) {\n        continue;\n      }\n\n      // Generate the URI corresponding to the child resource\n      const childLink = await this.resourceMapper.mapFilePathToUrl(childPath, childStats.isDirectory());\n\n      // Hide metadata files\n      if (childLink.isMetadata) {\n        continue;\n      }\n\n      // Generate metadata of this specific child as described in\n      // https://solidproject.org/TR/2021/protocol-20211217#contained-resource-metadata\n      const metadata = new RepresentationMetadata(childLink.identifier);\n      addResourceMetadata(metadata, childStats.isDirectory());\n      this.addPosixMetadata(metadata, childStats);\n      // Containers will not have a content-type\n      const { contentType, identifier } = childLink;\n      if (contentType) {\n        // Make sure we don't generate invalid URIs\n        try {\n          const { value } = parseContentType(contentType);\n          metadata.add(RDF.terms.type, toNamedTerm(`${IANA.namespace}${value}#Resource`));\n        } catch {\n          this.logger.warn(`Detected an invalid content-type \"${contentType}\" for ${identifier.path}`);\n        }\n      }\n\n      yield metadata;\n    }\n  }\n\n  /**\n   * Helper function to add file system related metadata.\n   * @param metadata - metadata object to add to\n   * @param stats - Stats of the file/directory corresponding to the resource.\n   */\n  private addPosixMetadata(metadata: RepresentationMetadata, stats: Stats): void {\n    updateModifiedDate(metadata, stats.mtime);\n    metadata.add(POSIX.terms.mtime,\n      toLiteral(Math.floor(stats.mtime.getTime() / 1000), XSD.terms.integer),\n      SOLID_META.terms.ResponseMetadata);\n    if (!stats.isDirectory()) {\n      metadata.add(POSIX.terms.size, toLiteral(stats.size, XSD.terms.integer), SOLID_META.terms.ResponseMetadata);\n    }\n  }\n\n  /**\n   * Verifies if there already is a file corresponding to the given resource.\n   * If yes, that file is removed if it does not match the path given in the input ResourceLink.\n   * This can happen if the content-type differs from the one that was stored.\n   *\n   * @param link - ResourceLink corresponding to the new resource data.\n   */\n  protected async verifyExistingExtension(link: ResourceLink): Promise<void> {\n    // Delete the old file with the (now) wrong extension\n    const oldLink = await this.resourceMapper.mapUrlToFilePath(link.identifier, false);\n    if (oldLink.filePath !== link.filePath) {\n      await remove(oldLink.filePath);\n    }\n  }\n\n  /**\n   * Helper function without extra validation checking to create a data file.\n   * @param path - The filepath of the file to be created.\n   * @param data - The data to be put in the file.\n   */\n  protected async writeDataFile(path: string, data: Readable): Promise<void> {\n    return new Promise((resolve, reject): any => {\n      const writeStream = createWriteStream(path);\n      data.pipe(writeStream);\n      data.on('error', (error): void => {\n        reject(error);\n        writeStream.end();\n      });\n\n      writeStream.on('error', reject);\n      writeStream.on('finish', resolve);\n    });\n  }\n}\n"]}