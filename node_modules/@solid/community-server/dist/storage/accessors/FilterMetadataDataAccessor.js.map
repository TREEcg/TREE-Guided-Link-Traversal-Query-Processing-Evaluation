{"version":3,"file":"FilterMetadataDataAccessor.js","sourceRoot":"","sources":["../../../src/storage/accessors/FilterMetadataDataAccessor.ts"],"names":[],"mappings":";;;AAMA,uEAAoE;AAEpE;;;GAGG;AACH,MAAa,0BAA2B,SAAQ,iDAAuB;IAGrE;;;;;OAKG;IACH,YAAmB,QAAsB,EAAE,OAAwB;QACjE,KAAK,CAAC,QAAQ,CAAC,CAAC;QAChB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,aAAa,CACxB,UAA8B,EAC9B,IAAuB,EACvB,QAAgC;QAEhC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,UAAU,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IACjE,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,UAA8B,EAAE,QAAgC;QAC1F,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;IAC5D,CAAC;IAED;;;;;OAKG;IACK,YAAY,CAAC,QAAgC;QACnD,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;YACjC,2BAA2B;YAC3B,MAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;YACtF,uBAAuB;YACvB,QAAQ,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;SACrC;IACH,CAAC;CACF;AA1CD,gEA0CC","sourcesContent":["import type { Readable } from 'stream';\nimport type { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { Guarded } from '../../util/GuardedStream';\nimport type { FilterPattern } from '../../util/QuadUtil';\nimport type { DataAccessor } from './DataAccessor';\nimport { PassthroughDataAccessor } from './PassthroughDataAccessor';\n\n/**\n * A FilterMetadataDataAccessor wraps a DataAccessor such that specific metadata properties\n * can be filtered before passing on the call to the wrapped DataAccessor.\n */\nexport class FilterMetadataDataAccessor extends PassthroughDataAccessor {\n  private readonly filters: FilterPattern[];\n\n  /**\n   * Construct an instance of FilterMetadataDataAccessor.\n   *\n   * @param accessor - The DataAccessor to wrap.\n   * @param filters - Filter patterns to be used for metadata removal.\n   */\n  public constructor(accessor: DataAccessor, filters: FilterPattern[]) {\n    super(accessor);\n    this.filters = filters;\n  }\n\n  public async writeDocument(\n    identifier: ResourceIdentifier,\n    data: Guarded<Readable>,\n    metadata: RepresentationMetadata,\n  ): Promise<void> {\n    this.applyFilters(metadata);\n    return this.accessor.writeDocument(identifier, data, metadata);\n  }\n\n  public async writeContainer(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    this.applyFilters(metadata);\n    return this.accessor.writeContainer(identifier, metadata);\n  }\n\n  /**\n   * Utility function that removes metadata entries,\n   * based on the configured filter patterns.\n   *\n   * @param metadata - Metadata for the request.\n   */\n  private applyFilters(metadata: RepresentationMetadata): void {\n    for (const filter of this.filters) {\n      // Find the matching quads.\n      const matchingQuads = metadata.quads(filter.subject, filter.predicate, filter.object);\n      // Remove the resulset.\n      metadata.removeQuads(matchingQuads);\n    }\n  }\n}\n"]}