{"version":3,"file":"DataAccessorBasedStore.js","sourceRoot":"","sources":["../../src/storage/DataAccessorBasedStore.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayifyStream from 'arrayify-stream';\nimport { DataFactory } from 'n3';\nimport type { NamedNode, Term } from 'rdf-js';\nimport { v4 as uuid } from 'uuid';\nimport type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport { BasicRepresentation } from '../http/representation/BasicRepresentation';\nimport type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport { RepresentationMetadata } from '../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { INTERNAL_QUADS } from '../util/ContentTypes';\nimport { BadRequestHttpError } from '../util/errors/BadRequestHttpError';\nimport { ConflictHttpError } from '../util/errors/ConflictHttpError';\nimport { createErrorMessage } from '../util/errors/ErrorUtil';\nimport { ForbiddenHttpError } from '../util/errors/ForbiddenHttpError';\nimport { MethodNotAllowedHttpError } from '../util/errors/MethodNotAllowedHttpError';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../util/errors/NotImplementedHttpError';\nimport { PreconditionFailedHttpError } from '../util/errors/PreconditionFailedHttpError';\nimport type { IdentifierStrategy } from '../util/identifiers/IdentifierStrategy';\nimport { concat } from '../util/IterableUtil';\nimport { IdentifierMap } from '../util/map/IdentifierMap';\nimport {\n  ensureTrailingSlash,\n  isContainerIdentifier,\n  isContainerPath,\n  trimTrailingSlashes,\n  toCanonicalUriPath,\n} from '../util/PathUtil';\nimport { addResourceMetadata, updateModifiedDate } from '../util/ResourceUtil';\nimport {\n  DC,\n  SOLID_HTTP,\n  LDP,\n  POSIX,\n  PIM,\n  RDF,\n  XSD,\n  SOLID_META,\n  PREFERRED_PREFIX_TERM,\n  CONTENT_TYPE_TERM,\n  SOLID_AS,\n  AS,\n} from '../util/Vocabularies';\nimport type { DataAccessor } from './accessors/DataAccessor';\nimport type { Conditions } from './Conditions';\nimport type { ResourceStore, ChangeMap } from './ResourceStore';\nimport namedNode = DataFactory.namedNode;\n\n/**\n * ResourceStore which uses a DataAccessor for backend access.\n *\n * The DataAccessor interface provides elementary store operations such as read and write.\n * This DataAccessorBasedStore uses those elementary store operations\n * to implement the more high-level ResourceStore contact, abstracting all common functionality\n * such that new stores can be added by implementing the more simple DataAccessor contract.\n * DataAccessorBasedStore thereby provides behaviours for reuse across different stores, such as:\n *  * Converting container metadata to data\n *  * Converting slug to URI\n *  * Checking if addResource target is a container\n *  * Checking if no containment triples are written to a container\n *  * etc.\n *\n * Currently \"metadata\" is seen as something that is not directly accessible.\n * That means that a consumer can't write directly to the metadata of a resource, only indirectly through headers.\n * (Except for containers where data and metadata overlap).\n *\n * The one thing this store does not take care of (yet?) are containment triples for containers\n *\n * Work has been done to minimize the number of required calls to the DataAccessor,\n * but the main disadvantage is that sometimes multiple calls are required where a specific store might only need one.\n */\nexport class DataAccessorBasedStore implements ResourceStore {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly accessor: DataAccessor;\n  private readonly identifierStrategy: IdentifierStrategy;\n  private readonly auxiliaryStrategy: AuxiliaryStrategy;\n  private readonly metadataStrategy: AuxiliaryStrategy;\n\n  public constructor(accessor: DataAccessor, identifierStrategy: IdentifierStrategy,\n    auxiliaryStrategy: AuxiliaryStrategy, metadataStrategy: AuxiliaryStrategy) {\n    this.accessor = accessor;\n    this.identifierStrategy = identifierStrategy;\n    this.auxiliaryStrategy = auxiliaryStrategy;\n    this.metadataStrategy = metadataStrategy;\n  }\n\n  public async hasResource(identifier: ResourceIdentifier): Promise<boolean> {\n    try {\n      this.validateIdentifier(identifier);\n      if (this.metadataStrategy.isAuxiliaryIdentifier(identifier)) {\n        identifier = this.metadataStrategy.getSubjectIdentifier(identifier);\n      }\n      await this.accessor.getMetadata(identifier);\n      return true;\n    } catch (error: unknown) {\n      if (NotFoundHttpError.isInstance(error)) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  public async getRepresentation(identifier: ResourceIdentifier): Promise<Representation> {\n    this.validateIdentifier(identifier);\n    let isMetadata = false;\n\n    if (this.metadataStrategy.isAuxiliaryIdentifier(identifier)) {\n      identifier = this.metadataStrategy.getSubjectIdentifier(identifier);\n      isMetadata = true;\n    }\n\n    // In the future we want to use getNormalizedMetadata and redirect in case the identifier differs\n    let metadata = await this.accessor.getMetadata(identifier);\n    let representation: Representation;\n\n    // Potentially add auxiliary related metadata\n    // Solid, §4.3: \"Clients can discover auxiliary resources associated with a subject resource by making an HTTP HEAD\n    // or GET request on the target URL, and checking the HTTP Link header with the rel parameter\"\n    // https://solid.github.io/specification/protocol#auxiliary-resources\n    await this.auxiliaryStrategy.addMetadata(metadata);\n\n    const isContainer = isContainerPath(metadata.identifier.value);\n    let data = metadata.quads();\n    if (isContainer || isMetadata) {\n      if (isContainer) {\n        // Add containment triples of non-auxiliary resources\n        for await (const child of this.accessor.getChildren(identifier)) {\n          if (!this.auxiliaryStrategy.isAuxiliaryIdentifier({ path: child.identifier.value })) {\n            if (!isMetadata) {\n              metadata.addQuads(child.quads());\n            }\n            metadata.add(LDP.terms.contains, child.identifier as NamedNode, SOLID_META.terms.ResponseMetadata);\n          }\n        }\n        data = metadata.quads();\n\n        if (isMetadata) {\n          metadata = new RepresentationMetadata(this.metadataStrategy.getAuxiliaryIdentifier(identifier));\n        }\n      }\n      metadata.addQuad(DC.terms.namespace, PREFERRED_PREFIX_TERM, 'dc', SOLID_META.terms.ResponseMetadata);\n      metadata.addQuad(LDP.terms.namespace, PREFERRED_PREFIX_TERM, 'ldp', SOLID_META.terms.ResponseMetadata);\n      metadata.addQuad(POSIX.terms.namespace, PREFERRED_PREFIX_TERM, 'posix', SOLID_META.terms.ResponseMetadata);\n      metadata.addQuad(XSD.terms.namespace, PREFERRED_PREFIX_TERM, 'xsd', SOLID_META.terms.ResponseMetadata);\n    }\n\n    if (isContainer) {\n      representation = new BasicRepresentation(data, metadata, INTERNAL_QUADS);\n    } else if (isMetadata) {\n      representation = new BasicRepresentation(\n        metadata.quads(), this.metadataStrategy.getAuxiliaryIdentifier(identifier), INTERNAL_QUADS,\n      );\n    } else {\n      representation = new BasicRepresentation(await this.accessor.getData(identifier), metadata);\n    }\n\n    return representation;\n  }\n\n  public async addResource(container: ResourceIdentifier, representation: Representation, conditions?: Conditions):\n  Promise<ChangeMap> {\n    this.validateIdentifier(container);\n\n    const parentMetadata = await this.getSafeNormalizedMetadata(container);\n\n    // Solid, §5.3: \"When a POST method request targets a resource without an existing representation,\n    // the server MUST respond with the 404 status code.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    if (!parentMetadata) {\n      throw new NotFoundHttpError();\n    }\n\n    // Not using `container` since `getSafeNormalizedMetadata` might return metadata for a different identifier.\n    // Solid, §5: \"Servers MUST respond with the 405 status code to requests using HTTP methods\n    // that are not supported by the target resource.\"\n    // https://solid.github.io/specification/protocol#reading-writing-resources\n    if (!isContainerPath(parentMetadata.identifier.value)) {\n      throw new MethodNotAllowedHttpError([ 'POST' ], 'The given path is not a container.');\n    }\n\n    this.validateConditions(conditions, parentMetadata);\n\n    // Solid, §5.1: \"Servers MAY allow clients to suggest the URI of a resource created through POST,\n    // using the HTTP Slug header as defined in [RFC5023].\n    // Clients who want the server to assign a URI of a resource, MUST use the POST request.\"\n    // https://solid.github.io/specification/protocol#resource-type-heuristics\n    const newID = await this.createSafeUri(container, representation.metadata);\n    const isContainer = isContainerIdentifier(newID);\n\n    // Ensure the representation is supported by the accessor\n    // Containers are not checked because uploaded representations are treated as metadata\n    if (!isContainer) {\n      await this.accessor.canHandle(representation);\n    }\n\n    // Write the data. New containers should never be made for a POST request.\n    return this.writeData(newID, representation, isContainer, false, false);\n  }\n\n  public async setRepresentation(identifier: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ChangeMap> {\n    this.validateIdentifier(identifier);\n\n    // Check if the resource already exists\n    const oldMetadata = await this.getSafeNormalizedMetadata(identifier);\n    // We do not allow PUT on an already existing Container\n    // See https://github.com/CommunitySolidServer/CommunitySolidServer/issues/1027#issuecomment-1023371546\n    if (oldMetadata && isContainerIdentifier(identifier)) {\n      throw new ConflictHttpError('Existing containers cannot be updated via PUT.');\n    }\n\n    // Preserve the old metadata\n    if (oldMetadata && representation.metadata.has(\n      SOLID_META.terms.preserve,\n      namedNode(this.metadataStrategy.getAuxiliaryIdentifier(identifier).path),\n    )) {\n      // Preserve all the quads from the old metadata apart from the ContentType\n      oldMetadata.contentType = undefined;\n      const quads = oldMetadata.quads();\n      representation.metadata.addQuads(quads);\n    }\n\n    // Might want to redirect in the future.\n    // See #480\n    // Solid, §3.1: \"If two URIs differ only in the trailing slash, and the server has associated a resource with\n    // one of them, then the other URI MUST NOT correspond to another resource. Instead, the server MAY respond to\n    // requests for the latter URI with a 301 redirect to the former.\"\n    // https://solid.github.io/specification/protocol#uri-slash-semantics\n    if (oldMetadata && oldMetadata.identifier.value !== identifier.path) {\n      throw new ConflictHttpError(`${identifier.path} conflicts with existing path ${oldMetadata.identifier.value}`);\n    }\n\n    // Solid, §3.1: \"Paths ending with a slash denote a container resource.\"\n    // https://solid.github.io/specification/protocol#uri-slash-semantics\n    const isContainer = isContainerIdentifier(identifier);\n    if (!isContainer && this.isContainerType(representation.metadata)) {\n      throw new BadRequestHttpError('Containers should have a `/` at the end of their path, resources should not.');\n    }\n\n    // Ensure the representation is supported by the accessor\n    // Metadata and containers are not checked since they get converted to RepresentationMetadata objects.\n    if (!isContainer && !this.metadataStrategy.isAuxiliaryIdentifier(identifier)) {\n      await this.accessor.canHandle(representation);\n    }\n\n    this.validateConditions(conditions, oldMetadata);\n\n    if (this.metadataStrategy.isAuxiliaryIdentifier(identifier)) {\n      return await this.writeMetadata(identifier, representation);\n    }\n\n    // Potentially have to create containers if it didn't exist yet\n    return this.writeData(identifier, representation, isContainer, !oldMetadata, Boolean(oldMetadata));\n  }\n\n  public async modifyResource(identifier: ResourceIdentifier, patch: Patch,\n    conditions?: Conditions): Promise<never> {\n    if (conditions) {\n      let metadata: RepresentationMetadata | undefined;\n      try {\n        metadata = await this.accessor.getMetadata(identifier);\n      } catch (error: unknown) {\n        if (!NotFoundHttpError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      this.validateConditions(conditions, metadata);\n    }\n\n    throw new NotImplementedHttpError('Patches are not supported by the default store.');\n  }\n\n  public async deleteResource(identifier: ResourceIdentifier, conditions?: Conditions): Promise<ChangeMap> {\n    this.validateIdentifier(identifier);\n\n    // https://github.com/CommunitySolidServer/CommunitySolidServer/issues/1027#issuecomment-988664970\n    // DELETE is not allowed on metadata\n    if (this.metadataStrategy.isAuxiliaryIdentifier(identifier)) {\n      throw new ConflictHttpError('Not allowed to delete metadata resources directly.');\n    }\n\n    const metadata = await this.accessor.getMetadata(identifier);\n    // Solid, §5.4: \"When a DELETE request targets storage’s root container or its associated ACL resource,\n    // the server MUST respond with the 405 status code.\"\n    // https://solid.github.io/specification/protocol#deleting-resources\n    if (this.isRootStorage(metadata)) {\n      throw new MethodNotAllowedHttpError([ 'DELETE' ], 'Cannot delete a root storage container.');\n    }\n    if (this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier) &&\n      this.auxiliaryStrategy.isRequiredInRoot(identifier)) {\n      const subjectIdentifier = this.auxiliaryStrategy.getSubjectIdentifier(identifier);\n      const parentMetadata = await this.accessor.getMetadata(subjectIdentifier);\n      if (this.isRootStorage(parentMetadata)) {\n        throw new MethodNotAllowedHttpError([ 'DELETE' ],\n          `Cannot delete ${identifier.path} from a root storage container.`);\n      }\n    }\n\n    // Solid, §5.4: \"When a DELETE request is made to a container, the server MUST delete the container\n    // if it contains no resources. If the container contains resources,\n    // the server MUST respond with the 409 status code and response body describing the error.\"\n    // https://solid.github.io/specification/protocol#deleting-resources\n    // Auxiliary resources are not counted when deleting a container since they will also be deleted.\n    if (isContainerIdentifier(identifier) && await this.hasProperChildren(identifier)) {\n      throw new ConflictHttpError('Can only delete empty containers.');\n    }\n\n    this.validateConditions(conditions, metadata);\n\n    // Solid, §5.4: \"When a contained resource is deleted,\n    // the server MUST also delete the associated auxiliary resources\"\n    // https://solid.github.io/specification/protocol#deleting-resources\n    const changes: ChangeMap = new IdentifierMap();\n    if (!this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier)) {\n      const auxiliaries = this.auxiliaryStrategy.getAuxiliaryIdentifiers(identifier);\n      for (const deletedId of await this.safelyDeleteAuxiliaryResources(auxiliaries)) {\n        this.addActivityMetadata(changes, deletedId, AS.terms.Delete);\n      }\n    }\n\n    if (!this.identifierStrategy.isRootContainer(identifier)) {\n      const container = this.identifierStrategy.getParentContainer(identifier);\n      this.addActivityMetadata(changes, container, AS.terms.Update);\n\n      // Update modified date of parent\n      await this.updateContainerModifiedDate(container);\n    }\n\n    await this.accessor.deleteResource(identifier);\n    this.addActivityMetadata(changes, identifier, AS.terms.Delete);\n    return changes;\n  }\n\n  /**\n   * Verify if the given identifier matches the stored base.\n   */\n  protected validateIdentifier(identifier: ResourceIdentifier): void {\n    if (!this.identifierStrategy.supportsIdentifier(identifier)) {\n      throw new NotFoundHttpError();\n    }\n  }\n\n  /**\n   * Verify if the given metadata matches the conditions.\n   */\n  protected validateConditions(conditions?: Conditions, metadata?: RepresentationMetadata): void {\n    // The 412 (Precondition Failed) status code indicates\n    // that one or more conditions given in the request header fields evaluated to false when tested on the server.\n    if (conditions && !conditions.matchesMetadata(metadata)) {\n      throw new PreconditionFailedHttpError();\n    }\n  }\n\n  /**\n   * Returns the metadata matching the identifier, ignoring the presence of a trailing slash or not.\n   *\n   * Solid, §3.1: \"If two URIs differ only in the trailing slash,\n   * and the server has associated a resource with one of them,\n   * then the other URI MUST NOT correspond to another resource.\"\n   * https://solid.github.io/specification/protocol#uri-slash-semantics\n   *\n   * First the identifier gets requested and if no result is found\n   * the identifier with differing trailing slash is requested.\n   * @param identifier - Identifier that needs to be checked.\n   */\n  protected async getNormalizedMetadata(identifier: ResourceIdentifier): Promise<RepresentationMetadata> {\n    const hasSlash = isContainerIdentifier(identifier);\n    try {\n      return await this.accessor.getMetadata(identifier);\n    } catch (error: unknown) {\n      if (NotFoundHttpError.isInstance(error)) {\n        const otherIdentifier =\n          { path: hasSlash ? trimTrailingSlashes(identifier.path) : ensureTrailingSlash(identifier.path) };\n\n        // Only try to access other identifier if it is valid in the scope of the DataAccessor\n        this.validateIdentifier(otherIdentifier);\n        return this.accessor.getMetadata(otherIdentifier);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Returns the result of `getNormalizedMetadata` or undefined if a 404 error is thrown.\n   */\n  protected async getSafeNormalizedMetadata(identifier: ResourceIdentifier):\n  Promise<RepresentationMetadata | undefined> {\n    try {\n      return await this.getNormalizedMetadata(identifier);\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Write the given metadata resource to the DataAccessor.\n   * @param identifier - Identifier of the metadata.\n   * @param representation - Corresponding Representation.\n   *\n   * @returns Identifiers of resources that were possibly modified.\n   */\n  protected async writeMetadata(identifier: ResourceIdentifier, representation: Representation):\n  Promise<ChangeMap> {\n    const subjectIdentifier = this.metadataStrategy.getSubjectIdentifier(identifier);\n\n    // Cannot create metadata without a corresponding resource\n    if (!await this.hasResource(subjectIdentifier)) {\n      throw new ConflictHttpError('Metadata resources can not be created directly.');\n    }\n\n    // https://github.com/CommunitySolidServer/CommunitySolidServer/issues/1027#issuecomment-988664970\n    // It must not be possible to create .meta.meta resources\n    if (this.metadataStrategy.isAuxiliaryIdentifier(subjectIdentifier)) {\n      throw new ConflictHttpError(\n        'Not allowed to create metadata resources on a metadata resource.',\n      );\n    }\n\n    const changes: ChangeMap = new IdentifierMap();\n\n    // Tranform representation data to quads and add them to the metadata object\n    const metadata = new RepresentationMetadata(subjectIdentifier);\n    const quads = await arrayifyStream(representation.data);\n    metadata.addQuads(quads);\n\n    // Remove the response metadata as this must not be stored\n    this.removeResponseMetadata(metadata);\n    await this.accessor.writeMetadata(subjectIdentifier, metadata);\n\n    this.addActivityMetadata(changes, subjectIdentifier, AS.terms.Update);\n    return changes;\n  }\n\n  /**\n   * Write the given resource to the DataAccessor. Metadata will be updated with necessary triples.\n   * In case of containers `handleContainerData` will be used to verify the data.\n   * @param identifier - Identifier of the resource.\n   * @param representation - Corresponding Representation.\n   * @param isContainer - Is the incoming resource a container?\n   * @param createContainers - Should parent containers (potentially) be created?\n   * @param exists - If the resource already exists.\n   *\n   * @returns Identifiers of resources that were possibly modified.\n   */\n  protected async writeData(identifier: ResourceIdentifier, representation: Representation, isContainer: boolean,\n    createContainers: boolean, exists: boolean): Promise<ChangeMap> {\n    // Make sure the metadata has the correct identifier and correct type quads\n    // Need to do this before handling container data to have the correct identifier\n    representation.metadata.identifier = DataFactory.namedNode(identifier.path);\n    addResourceMetadata(representation.metadata, isContainer);\n\n    // Validate container data\n    if (isContainer) {\n      await this.handleContainerData(representation);\n    }\n\n    // Validate auxiliary data\n    if (this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier)) {\n      await this.auxiliaryStrategy.validate(representation);\n    }\n\n    // Add date modified metadata\n    updateModifiedDate(representation.metadata);\n\n    // Root container should not have a parent container\n    // Solid, §5.3: \"Servers MUST create intermediate containers and include corresponding containment triples\n    // in container representations derived from the URI path component of PUT and PATCH requests.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    let changes: ChangeMap = new IdentifierMap();\n    if (!this.identifierStrategy.isRootContainer(identifier) && !exists) {\n      const parent = this.identifierStrategy.getParentContainer(identifier);\n\n      if (createContainers) {\n        changes = await this.createRecursiveContainers(parent);\n      }\n\n      // No changes means the parent container exists and will be updated\n      if (changes.size === 0) {\n        this.addActivityMetadata(changes, parent, AS.terms.Update);\n      }\n\n      // Parent container is also modified\n      await this.updateContainerModifiedDate(parent);\n    }\n\n    // Remove all generated metadata to prevent it from being stored permanently\n    this.removeResponseMetadata(representation.metadata);\n\n    await (isContainer ?\n      this.accessor.writeContainer(identifier, representation.metadata) :\n      this.accessor.writeDocument(identifier, representation.data, representation.metadata));\n\n    this.addActivityMetadata(changes, identifier, exists ? AS.terms.Update : AS.terms.Create);\n    return changes;\n  }\n\n  /**\n   * Warns when the representation has data and removes the content-type from the metadata.\n   *\n   * @param representation - Container representation.\n   */\n  protected async handleContainerData(representation: Representation): Promise<void> {\n    // https://github.com/CommunitySolidServer/CommunitySolidServer/issues/1027#issuecomment-1022214820\n    // Make it not possible via PUT to add metadata during the creation of a container\n    // Thus the contents are ignored and a warning is sent\n    if (!representation.isEmpty) {\n      this.logger.warn('The contents of the body are ignored when creating a container.');\n    }\n\n    // Input content type doesn't matter anymore\n    representation.metadata.removeAll(CONTENT_TYPE_TERM);\n  }\n\n  /**\n   * Removes all generated data from metadata to prevent it from being stored permanently.\n   */\n  protected removeResponseMetadata(metadata: RepresentationMetadata): void {\n    metadata.removeQuads(\n      metadata.quads(null, null, null, SOLID_META.terms.ResponseMetadata),\n    );\n  }\n\n  /**\n   * Updates the last modified date of the given container\n   */\n  protected async updateContainerModifiedDate(container: ResourceIdentifier): Promise<void> {\n    const parentMetadata = await this.accessor.getMetadata(container);\n    updateModifiedDate(parentMetadata);\n    this.removeResponseMetadata(parentMetadata);\n    await this.accessor.writeContainer(container, parentMetadata);\n  }\n\n  /**\n   * Generates a new URI for a resource in the given container, potentially using the given slug.\n   *\n   * Solid, §5.3: \"Servers MUST allow creating new resources with a POST request to URI path ending `/`.\n   * Servers MUST create a resource with URI path ending `/{id}` in container `/`.\n   * Servers MUST create a container with URI path ending `/{id}/` in container `/` for requests\n   * including the HTTP Link header with rel=\"type\" targeting a valid LDP container type.\"\n   * https://solid.github.io/specification/protocol#writing-resources\n   *\n   * @param container - Parent container of the new URI.\n   * @param isContainer - Does the new URI represent a container?\n   * @param slug - Slug to use for the new URI.\n   */\n  protected createURI(container: ResourceIdentifier, isContainer: boolean, slug?: string): ResourceIdentifier {\n    this.validateSlug(isContainer, slug);\n    const base = ensureTrailingSlash(container.path);\n    const name = (slug && this.cleanSlug(slug)) ?? uuid();\n    const suffix = isContainer ? '/' : '';\n    return { path: `${base}${name}${suffix}` };\n  }\n\n  /**\n   * Validates if the slug and headers are valid.\n   * Errors if slug exists, ends on slash, but ContainerType Link header is NOT present\n   * @param isContainer - Is the slug supposed to represent a container?\n   * @param slug - Is the requested slug (if any).\n   */\n  protected validateSlug(isContainer: boolean, slug?: string): void {\n    if (slug && isContainerPath(slug) && !isContainer) {\n      throw new BadRequestHttpError('Only slugs used to create containers can end with a `/`.');\n    }\n  }\n\n  /**\n   * Clean http Slug to be compatible with the server. Makes sure there are no unwanted characters\n   * e.g.: cleanslug('&%26') returns '%26%26'\n   * @param slug - the slug to clean\n   */\n  protected cleanSlug(slug: string): string {\n    if (/\\/[^/]/u.test(slug)) {\n      throw new BadRequestHttpError('Slugs should not contain slashes');\n    }\n    return toCanonicalUriPath(trimTrailingSlashes(slug));\n  }\n\n  /**\n   * Generate a valid URI to store a new Resource in the given container.\n   * URI will be based on the slug header if there is one and is guaranteed to not exist yet.\n   *\n   * @param container - Identifier of the target container.\n   * @param metadata - Metadata of the new resource.\n   */\n  protected async createSafeUri(container: ResourceIdentifier, metadata: RepresentationMetadata):\n  Promise<ResourceIdentifier> {\n    // Get all values needed for naming the resource\n    const isContainer = this.isContainerType(metadata);\n    const slug = metadata.get(SOLID_HTTP.terms.slug)?.value;\n    metadata.removeAll(SOLID_HTTP.terms.slug);\n\n    let newID: ResourceIdentifier = this.createURI(container, isContainer, slug);\n\n    // Solid, §5.3: \"When a POST method request with the Slug header targets an auxiliary resource,\n    // the server MUST respond with the 403 status code and response body describing the error.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    if (this.auxiliaryStrategy.isAuxiliaryIdentifier(newID)) {\n      throw new ForbiddenHttpError('Slug bodies that would result in an auxiliary resource are forbidden');\n    }\n\n    // Make sure we don't already have a resource with this exact name (or with differing trailing slash)\n    const withSlash = { path: ensureTrailingSlash(newID.path) };\n    const withoutSlash = { path: trimTrailingSlashes(newID.path) };\n    if (await this.hasResource(withSlash) || await this.hasResource(withoutSlash)) {\n      newID = this.createURI(container, isContainer);\n    }\n\n    return newID;\n  }\n\n  /**\n   * Checks if the given metadata represents a (potential) container,\n   * based on the metadata.\n   * @param metadata - Metadata of the (new) resource.\n   */\n  protected isContainerType(metadata: RepresentationMetadata): boolean {\n    return this.hasContainerType(metadata.getAll(RDF.terms.type));\n  }\n\n  /**\n   * Checks in a list of types if any of them match a Container type.\n   */\n  protected hasContainerType(rdfTypes: Term[]): boolean {\n    return rdfTypes.some((type): boolean => type.value === LDP.Container || type.value === LDP.BasicContainer);\n  }\n\n  /**\n   * Verifies if this is the metadata of a root storage container.\n   */\n  protected isRootStorage(metadata: RepresentationMetadata): boolean {\n    return metadata.getAll(RDF.terms.type).some((term): boolean => term.value === PIM.Storage);\n  }\n\n  /**\n   * Checks if the given container has any non-auxiliary resources.\n   */\n  protected async hasProperChildren(container: ResourceIdentifier): Promise<boolean> {\n    for await (const child of this.accessor.getChildren(container)) {\n      if (!this.auxiliaryStrategy.isAuxiliaryIdentifier({ path: child.identifier.value })) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Deletes the given array of auxiliary identifiers.\n   * Does not throw an error if something goes wrong.\n   */\n  protected async safelyDeleteAuxiliaryResources(identifiers: ResourceIdentifier[]): Promise<ResourceIdentifier[]> {\n    const deleted: ResourceIdentifier[] = [];\n    await Promise.all(identifiers.map(async(identifier): Promise<void> => {\n      try {\n        await this.accessor.deleteResource(identifier);\n        deleted.push(identifier);\n      } catch (error: unknown) {\n        if (!NotFoundHttpError.isInstance(error)) {\n          this.logger.error(`Error deleting auxiliary resource ${identifier.path}: ${createErrorMessage(error)}`);\n        }\n      }\n    }));\n    return deleted;\n  }\n\n  /**\n   * Create containers starting from the root until the given identifier corresponds to an existing container.\n   * Will throw errors if the identifier of the last existing \"container\" corresponds to an existing document.\n   * @param container - Identifier of the container which will need to exist.\n   */\n  protected async createRecursiveContainers(container: ResourceIdentifier): Promise<ChangeMap> {\n    // Verify whether the container already exists\n    try {\n      const metadata = await this.getNormalizedMetadata(container);\n      // See https://github.com/CommunitySolidServer/CommunitySolidServer/issues/480\n      // Solid, §3.1: \"If two URIs differ only in the trailing slash, and the server has associated a resource with\n      // one of them, then the other URI MUST NOT correspond to another resource. Instead, the server MAY respond to\n      // requests for the latter URI with a 301 redirect to the former.\"\n      // https://solid.github.io/specification/protocol#uri-slash-semantics\n      if (!isContainerPath(metadata.identifier.value)) {\n        throw new ForbiddenHttpError(`Creating container ${container.path} conflicts with an existing resource.`);\n      }\n      return new IdentifierMap();\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n    }\n\n    // Create the container, starting with its parent\n    const ancestors: ChangeMap = this.identifierStrategy.isRootContainer(container) ?\n      new IdentifierMap() :\n      await this.createRecursiveContainers(this.identifierStrategy.getParentContainer(container));\n    const changes = await this.writeData(container, new BasicRepresentation([], container), true, false, false);\n\n    return new IdentifierMap(concat([ changes, ancestors ]));\n  }\n\n  /**\n   * Generates activity metadata for a resource and adds it to the {@link ChangeMap}\n   * @param map - ChangeMap to update.\n   * @param id - Identifier of the resource being changed.\n   * @param activity - Which activity is taking place.\n   */\n  private addActivityMetadata(map: ChangeMap, id: ResourceIdentifier, activity: NamedNode): void {\n    map.set(id, new RepresentationMetadata(id, { [SOLID_AS.Activity]: activity }));\n  }\n}\n"]}