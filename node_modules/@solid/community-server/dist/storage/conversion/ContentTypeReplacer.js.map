{"version":3,"file":"ContentTypeReplacer.js","sourceRoot":"","sources":["../../../src/storage/conversion/ContentTypeReplacer.ts"],"names":[],"mappings":";;;AACA,6FAA0F;AAE1F,uFAAoF;AACpF,qDAAyE;AAEzE,iFAA8E;AAE9E;;;;;;GAMG;AACH,MAAa,mBAAoB,SAAQ,2DAA4B;IAQnE,YAAmB,YAAiC;QAClD,KAAK,EAAE,CAAC;QARO,mBAAc,GAAqC,EAAE,CAAC;QASrE,+CAA+C;QAC/C,8DAA8D;QAC9D,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;YACjD,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;YACpC,CAAC,SAAS,eAAe,CAAC,MAAM,EAAE,QAAQ;gBACxC,MAAM,OAAO,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;gBAC3C,MAAM,QAAQ,GAAG,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAE,OAAO,CAAE,CAAC,CAAC,CAAC,OAAO,CAAC;gBACrE,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;oBAC9B,IAAI,CAAC,CAAC,OAAO,IAAI,QAAQ,CAAC,EAAE;wBAC1B,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;wBACtB,eAAe,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;qBACpC;iBACF;YACH,CAAC,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC;SAC/C;IACH,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,WAAmB;QAC7C,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;aAC/C,MAAM,CAAC,CAAC,IAAI,EAAW,EAAE,CAAC,IAAA,iCAAgB,EAAC,WAAW,EAAE,IAAI,CAAC,CAAC;aAC9D,GAAG,CAAC,CAAC,IAAI,EAAoB,EAAE,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;QAC9D,OAAO,MAAM,CAAC,MAAM,CAAC,EAAsB,EAAE,GAAG,SAAS,CAAC,CAAC;IAC7D,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,EAAE,cAAc,EAAE,WAAW,EAA+B;QACjF,MAAM,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC,QAAQ,CAAC,WAAW,EAAE,WAAW,CAAC,IAAI,CAAC,CAAC;IACvF,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,WAAW,EAA+B;QAC9E,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC,QAAQ,CAAC,WAAW,EAAE,WAAW,CAAC,IAAI,CAAC,CAAC;QACzG,MAAM,QAAQ,GAAG,IAAI,+CAAsB,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QAClF,OAAO,EAAE,GAAG,cAAc,EAAE,QAAQ,EAAE,CAAC;IACzC,CAAC;IAEM,KAAK,CAAC,UAAU,CAAC,IAAiC;QACvD,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,kBAAkB,CAAC,WAAW,GAAG,SAAS,EAAE,YAA8B,EAAE;QACxF,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QACzD,MAAM,KAAK,GAAG,IAAA,oCAAmB,EAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QACxD,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,iDAAuB,CAAC,uBAAuB,WAAW,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;SACtG;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AA/DD,kDA+DC","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { matchesMediaType, getConversionTarget } from './ConversionUtil';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\nimport { TypedRepresentationConverter } from './TypedRepresentationConverter';\n\n/**\n * A {@link RepresentationConverter} that changes the content type\n * but does not alter the representation.\n *\n * Useful for when a content type is binary-compatible with another one;\n * for instance, all JSON-LD files are valid JSON files.\n */\nexport class ContentTypeReplacer extends TypedRepresentationConverter {\n  private readonly contentTypeMap: Record<string, ValuePreferences> = {};\n\n  /**\n   * @param replacements - Map of content type patterns and content types to replace them by.\n   */\n  public constructor(replacements: Record<string, string>);\n  public constructor(replacements: Record<string, Iterable<string>>);\n  public constructor(replacements: Record<string, any>) {\n    super();\n    // Store the replacements as value preferences,\n    // completing any transitive chains (A:B, B:C, C:D => A:B,C,D)\n    for (const inputType of Object.keys(replacements)) {\n      this.contentTypeMap[inputType] = {};\n      (function addReplacements(inType, outTypes): void {\n        const replace = replacements[inType] ?? [];\n        const newTypes = typeof replace === 'string' ? [ replace ] : replace;\n        for (const newType of newTypes) {\n          if (!(newType in outTypes)) {\n            outTypes[newType] = 1;\n            addReplacements(newType, outTypes);\n          }\n        }\n      })(inputType, this.contentTypeMap[inputType]);\n    }\n  }\n\n  public async getOutputTypes(contentType: string): Promise<ValuePreferences> {\n    const supported = Object.keys(this.contentTypeMap)\n      .filter((type): boolean => matchesMediaType(contentType, type))\n      .map((type): ValuePreferences => this.contentTypeMap[type]);\n    return Object.assign({} as ValuePreferences, ...supported);\n  }\n\n  public async canHandle({ representation, preferences }: RepresentationConverterArgs): Promise<void> {\n    await this.getReplacementType(representation.metadata.contentType, preferences.type);\n  }\n\n  /**\n   * Changes the content type on the representation.\n   */\n  public async handle({ representation, preferences }: RepresentationConverterArgs): Promise<Representation> {\n    const contentType = await this.getReplacementType(representation.metadata.contentType, preferences.type);\n    const metadata = new RepresentationMetadata(representation.metadata, contentType);\n    return { ...representation, metadata };\n  }\n\n  public async handleSafe(args: RepresentationConverterArgs): Promise<Representation> {\n    return this.handle(args);\n  }\n\n  /**\n   * Find a replacement content type that matches the preferences,\n   * or throws an error if none was found.\n   */\n  private async getReplacementType(contentType = 'unknown', preferred: ValuePreferences = {}): Promise<string> {\n    const supported = await this.getOutputTypes(contentType);\n    const match = getConversionTarget(supported, preferred);\n    if (!match) {\n      throw new NotImplementedHttpError(`Cannot convert from ${contentType} to ${Object.keys(preferred)}`);\n    }\n    return match;\n  }\n}\n"]}