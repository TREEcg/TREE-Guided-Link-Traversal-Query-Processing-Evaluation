{"version":3,"file":"ChainedConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/ChainedConverter.ts"],"names":[],"mappings":"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","sourcesContent":["import { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { cleanPreferences, getBestPreference, getTypeWeight, preferencesToString } from './ConversionUtil';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\nimport { RepresentationConverter } from './RepresentationConverter';\nimport type { TypedRepresentationConverter } from './TypedRepresentationConverter';\n\ntype ConverterPreference = {\n  converter: TypedRepresentationConverter;\n  inType: string;\n  outTypes: ValuePreferences;\n};\n\ntype ConversionPath = {\n  /**\n   * List of converters used in the path.\n   */\n  converters: TypedRepresentationConverter[];\n  /**\n   * The intermediate conversion types when going from converter i to i+1.\n   * Length is one less than the list of converters.\n   */\n  intermediateTypes: string[];\n  /**\n   * The type on which this conversion path starts.\n   */\n  inType: string;\n  /**\n   * The types this path can generate.\n   * Weights indicate the quality of transforming to that specific type.\n   */\n  outTypes: ValuePreferences;\n  /**\n   * The weight of the path matched against the output preferences.\n   * Will be 0 if the path does not match any of those preferences.\n   */\n  weight: number;\n  /**\n   * The output type for which this path has the highest weight.\n   * Value is irrelevant if weight is 0.\n   */\n  outType: string;\n};\n\n/**\n * A meta converter that takes an array of other converters as input.\n * It chains these converters by finding a path of converters\n * that can go from the given content-type to the given type preferences.\n * In case there are multiple paths, the one with the highest weight gets found.\n * Will error in case no path can be found.\n *\n * This is not a TypedRepresentationConverter since the supported output types\n * might depend on what is the input content-type.\n *\n * This converter should be the last in a WaterfallHandler if there are multiple,\n * since it will try to convert any representation with a content-type.\n *\n * Some suggestions on how this class can be even more optimized should this ever be needed in the future.\n * Most of these decrease computation time at the cost of more memory.\n *  - The algorithm could start on both ends of a possible path and work towards the middle.\n *  - When creating a path, store the list of unused converters instead of checking every step.\n *  - Caching: https://github.com/CommunitySolidServer/CommunitySolidServer/issues/832\n *  - Making sure each intermediate type is only used once.\n *  - The TypedRepresentationConverter interface could potentially be updated\n *    so paths only differing in intermediate types can be combined.\n */\nexport class ChainedConverter extends RepresentationConverter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly converters: TypedRepresentationConverter[];\n\n  public constructor(converters: TypedRepresentationConverter[]) {\n    super();\n    if (converters.length === 0) {\n      throw new Error('At least 1 converter is required.');\n    }\n    this.converters = [ ...converters ];\n  }\n\n  public async canHandle(input: RepresentationConverterArgs): Promise<void> {\n    const type = input.representation.metadata.contentType;\n    if (!type) {\n      throw new BadRequestHttpError('Missing Content-Type header.');\n    }\n  }\n\n  public async handle(input: RepresentationConverterArgs): Promise<Representation> {\n    const match = await this.findPath(input);\n\n    this.logger.debug(`Converting ${match.inType} -> ${[ ...match.intermediateTypes, match.outType ].join(' -> ')}.`);\n\n    const args = { ...input };\n    const outTypes = [ ...match.intermediateTypes, match.outType ];\n    for (let i = 0; i < match.converters.length; ++i) {\n      args.preferences = { type: { [outTypes[i]]: 1 }};\n      args.representation = await match.converters[i].handle(args);\n    }\n    return args.representation;\n  }\n\n  /**\n   * Finds a conversion path that can handle the given input.\n   */\n  private async findPath(input: RepresentationConverterArgs): Promise<ConversionPath> {\n    const type = input.representation.metadata.contentType!;\n    const preferences = cleanPreferences(input.preferences.type);\n\n    return this.generatePath(type, preferences, input.representation.metadata);\n  }\n\n  /**\n   * Tries to generate the optimal `ConversionPath` that supports the given parameters,\n   * which will then be used to instantiate a specific `MatchedPath` for those parameters.\n   *\n   * Errors if such a path does not exist.\n   */\n  private async generatePath(inType: string, outPreferences: ValuePreferences, metadata: RepresentationMetadata):\n  Promise<ConversionPath> {\n    //\n    const weight = getTypeWeight(inType, outPreferences);\n    let paths: ConversionPath[] = [{\n      converters: [],\n      intermediateTypes: [],\n      inType,\n      outTypes: { [inType]: 1 },\n      weight,\n      outType: inType,\n    }];\n\n    // It's impossible for a path to have a higher weight than this value\n    const maxWeight = Math.max(...Object.values(outPreferences));\n\n    // This metadata will be used to simulate canHandle checks\n    const metadataPlaceholder = new RepresentationMetadata(metadata);\n\n    let bestPath = this.findBest(paths);\n    // This will always stop at some point since paths can't have the same converter twice\n    while (paths.length > 0) {\n      // For every path, find all the paths that can be made by adding 1 more converter\n      const promises = paths.map(async(path): Promise<ConversionPath[]> => this.takeStep(path, metadataPlaceholder));\n      paths = (await Promise.all(promises)).flat();\n      this.updatePathWeights(paths, outPreferences);\n      const newBest = this.findBest(paths);\n      if (newBest && (!bestPath || newBest.weight > bestPath.weight)) {\n        bestPath = newBest;\n      }\n      paths = this.removeBadPaths(paths, maxWeight, bestPath);\n    }\n\n    if (!bestPath) {\n      this.logger.warn(`No conversion path could be made from ${inType} to ${preferencesToString(outPreferences)}.`);\n      throw new NotImplementedHttpError(\n        `No conversion path could be made from ${inType} to ${preferencesToString(outPreferences)}.`,\n      );\n    }\n    return bestPath;\n  }\n\n  /**\n   * Checks if a path can match the requested preferences and updates the type and weight if it can.\n   */\n  private updatePathWeights(paths: ConversionPath[], outPreferences: ValuePreferences): void {\n    for (const path of paths) {\n      const outMatch = getBestPreference(path.outTypes, outPreferences);\n      if (outMatch && outMatch.weight > 0) {\n        path.weight = outMatch.weight;\n        path.outType = outMatch.value;\n      }\n    }\n  }\n\n  /**\n   * Finds the path from the given list that can convert to the given preferences.\n   * If there are multiple matches the one with the highest result weight gets chosen.\n   * Will return undefined if there are no matches.\n   */\n  private findBest(paths: ConversionPath[]): ConversionPath | undefined {\n    // Need to use null instead of undefined so `reduce` doesn't take the first element of the array as `best`\n    return paths.reduce((best: ConversionPath | null, path): ConversionPath | null => {\n      if (path.weight > 0 && !(best && best.weight >= path.weight)) {\n        return path;\n      }\n      return best;\n    }, null) ?? undefined;\n  }\n\n  /**\n   * Filter out paths that can no longer be better than the current best solution.\n   * This depends on a valid path already being found, if not all the input paths will be returned.\n   *\n   * @param paths - Paths to filter.\n   * @param maxWeight - The maximum weight in the output preferences.\n   * @param bestMatch - The current best path.\n   */\n  private removeBadPaths(paths: ConversionPath[], maxWeight: number, bestMatch?: ConversionPath): ConversionPath[] {\n    // All paths are still good if there is no best match yet\n    if (!bestMatch) {\n      return paths;\n    }\n    // Do not improve if the maximum weight has been achieved (accounting for floating point errors)\n    if (bestMatch.weight >= maxWeight - 0.01) {\n      return [];\n    }\n\n    // Only return paths that can potentially improve upon bestPath\n    return paths.filter((path): boolean => {\n      const optimisticWeight = Math.max(...Object.values(path.outTypes)) * maxWeight;\n      return optimisticWeight > bestMatch.weight;\n    });\n  }\n\n  /**\n   * Finds all converters that could take the output of the given path as input.\n   * For each of these converters a new path gets created which is the input path appended by the converter.\n   */\n  private async takeStep(path: ConversionPath, metadata: RepresentationMetadata): Promise<ConversionPath[]> {\n    const unusedConverters = this.converters.filter((converter): boolean => !path.converters.includes(converter));\n    const nextConverters = await this.supportedConverters(path.outTypes, metadata, unusedConverters);\n\n    // Create a new path for every converter that can be appended\n    return Promise.all(nextConverters.map(async(pref): Promise<ConversionPath> => ({\n      converters: [ ...path.converters, pref.converter ],\n      intermediateTypes: path.converters.length > 0 ? [ ...path.intermediateTypes, pref.inType ] : [],\n      inType: path.inType,\n      outTypes: pref.outTypes,\n      // These will be updated later\n      weight: 0,\n      outType: 'invalid',\n    })));\n  }\n\n  /**\n   * Creates a new ValuePreferences object, which is equal to the input object\n   * with all values multiplied by the given weight.\n   */\n  private modifyTypeWeights(weight: number, types: ValuePreferences): ValuePreferences {\n    return Object.fromEntries(Object.entries(types).map(([ type, pref ]): [string, number] => [ type, weight * pref ]));\n  }\n\n  /**\n   * Finds all converters in the given list that support taking any of the given types as input.\n   * Filters out converters that would produce an already seen type.\n   */\n  private async supportedConverters(types: ValuePreferences, metadata: RepresentationMetadata,\n    converters: TypedRepresentationConverter[]): Promise<ConverterPreference[]> {\n    const typeEntries = Object.entries(types);\n    const results: ConverterPreference[] = [];\n    for (const converter of converters) {\n      for (const [ inType, weight ] of typeEntries) {\n        // This metadata object is only used internally so changing the content-type is fine\n        metadata.contentType = inType;\n        const preference = await this.findConverterPreference(inType, weight, metadata, converter);\n        if (preference) {\n          results.push(preference);\n        }\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Returns a ConverterPreference if the given converter supports the given type.\n   * All types that have already been used will be removed from the output types.\n   */\n  private async findConverterPreference(inType: string, weight: number, metadata: RepresentationMetadata,\n    converter: TypedRepresentationConverter): Promise<ConverterPreference | undefined> {\n    const representation = new BasicRepresentation([], metadata);\n    try {\n      const identifier = { path: representation.metadata.identifier.value };\n      // Internal types get ignored when trying to match everything, so they need to be specified to also match.\n      await converter.canHandle({ representation, identifier, preferences: { type: { '*/*': 1, 'internal/*': 1 }}});\n    } catch {\n      // Skip converters that fail the canHandle test\n      return;\n    }\n\n    let outTypes = await converter.getOutputTypes(inType);\n    outTypes = this.modifyTypeWeights(weight, outTypes);\n    return { converter, inType, outTypes };\n  }\n}\n"]}