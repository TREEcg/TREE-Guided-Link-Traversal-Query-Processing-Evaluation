{"version":3,"file":"QuadToRdfConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/QuadToRdfConverter.ts"],"names":[],"mappings":";;;;;;AACA,2BAA+C;AAE/C,kEAA0C;AAC1C,uFAAoF;AAGpF,0DAAyD;AACzD,sDAAoE;AACpE,0DAA4E;AAC5E,yFAAsF;AACtF,qDAAuD;AAGvD;;GAEG;AACH,MAAa,kBAAmB,SAAQ,mEAAgC;IAGtE,YAAmB,UAA0D,EAAE;QAC7E,KAAK,CACH,6BAAc,EACd,OAAO,CAAC,iBAAiB,IAAI,uBAAa,CAAC,0BAA0B,EAAE,CACxE,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,UAAU,EAAE,cAAc,EAAE,KAAK,EAAE,WAAW,EAA+B;QAEjG,sDAAsD;QACtD,MAAM,WAAW,GAAG,IAAA,oCAAmB,EAAC,MAAM,IAAI,CAAC,cAAc,CAAC,6BAAc,CAAC,EAAE,WAAW,CAAC,IAAI,CAAE,CAAC;QACtG,IAAI,IAAc,CAAC;QAEnB,kFAAkF;QAClF,4EAA4E;QAC5E,+FAA+F;QAC/F,KAAK,CAAC,IAAI,GAAG,IAAA,4BAAe,EAAO,KAAK,CAAC,IAAI,EAAE;YAC7C,UAAU,EAAE,IAAI;YAChB,SAAS,CAAC,IAAU;gBAClB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,yBAAU,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE;oBACxD,IAAI,CAAC,IAAI,CAAC,gBAAW,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;iBACxE;qBAAM;oBACL,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACjB;YACH,CAAC;SACF,CAAC,CAAC;QAEH,0FAA0F;QAC1F,IAAI,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;YACzC,MAAM,QAAQ,GAAG,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,oCAAqB,EAAE,IAAI,CAAC;iBACxF,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,EAAoB,EAAE,CAAC,CAAE,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAE,CAAC,CAAC,CAAC;YACpF,MAAM,OAAO,GAAG,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC;YAC5E,IAAI,GAAG,IAAA,uBAAU,EAAC,KAAK,CAAC,IAAI,EAAE,IAAI,iBAAY,CAAC,OAAO,CAAC,CAAC,CAAC;YACzD,oCAAoC;SACrC;aAAM;YACL,IAAI,GAAG,uBAAa,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,WAAW,EAAE,CAAa,CAAC;SACzE;QAED,OAAO,IAAI,yCAAmB,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;IACpE,CAAC;CACF;AA3CD,gDA2CC","sourcesContent":["import type { Readable } from 'stream';\nimport { DataFactory, StreamWriter } from 'n3';\nimport type { Quad } from 'rdf-js';\nimport rdfSerializer from 'rdf-serialize';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport type { ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { pipeSafely, transformSafely } from '../../util/StreamUtil';\nimport { PREFERRED_PREFIX_TERM, SOLID_META } from '../../util/Vocabularies';\nimport { BaseTypedRepresentationConverter } from './BaseTypedRepresentationConverter';\nimport { getConversionTarget } from './ConversionUtil';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\n\n/**\n * Converts `internal/quads` to most major RDF serializations.\n */\nexport class QuadToRdfConverter extends BaseTypedRepresentationConverter {\n  private readonly outputPreferences?: ValuePreferences;\n\n  public constructor(options: { outputPreferences?: Record<string, number> } = {}) {\n    super(\n      INTERNAL_QUADS,\n      options.outputPreferences ?? rdfSerializer.getContentTypesPrioritized(),\n    );\n  }\n\n  public async handle({ identifier, representation: quads, preferences }: RepresentationConverterArgs):\n  Promise<Representation> {\n    // Can not be undefined if the `canHandle` call passed\n    const contentType = getConversionTarget(await this.getOutputTypes(INTERNAL_QUADS), preferences.type)!;\n    let data: Readable;\n\n    // Remove the ResponseMetadata graph as we never want to see it in a serialization\n    // Note that this is a temporary solution as indicated in following comment:\n    // https://github.com/CommunitySolidServer/CommunitySolidServer/pull/1188#discussion_r853830903\n    quads.data = transformSafely<Quad>(quads.data, {\n      objectMode: true,\n      transform(quad: Quad): void {\n        if (quad.graph.equals(SOLID_META.terms.ResponseMetadata)) {\n          this.push(DataFactory.quad(quad.subject, quad.predicate, quad.object));\n        } else {\n          this.push(quad);\n        }\n      },\n    });\n\n    // Use prefixes if possible (see https://github.com/rubensworks/rdf-serialize.js/issues/1)\n    if (/(?:turtle|trig)$/u.test(contentType)) {\n      const prefixes = Object.fromEntries(quads.metadata.quads(null, PREFERRED_PREFIX_TERM, null)\n        .map(({ subject, object }): [string, string] => [ object.value, subject.value ]));\n      const options = { format: contentType, baseIRI: identifier.path, prefixes };\n      data = pipeSafely(quads.data, new StreamWriter(options));\n      // Otherwise, write without prefixes\n    } else {\n      data = rdfSerializer.serialize(quads.data, { contentType }) as Readable;\n    }\n\n    return new BasicRepresentation(data, quads.metadata, contentType);\n  }\n}\n"]}