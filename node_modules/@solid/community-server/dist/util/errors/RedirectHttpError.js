"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRedirectHttpErrorClass = exports.RedirectHttpError = void 0;
const HttpError_1 = require("./HttpError");
/**
 * An error corresponding to a 3xx status code.
 * Includes the location it redirects to.
 */
class RedirectHttpError extends HttpError_1.HttpError {
    constructor(statusCode, name, location, message, options) {
        super(statusCode, name, message, options);
        this.location = location;
    }
    static isInstance(error) {
        return HttpError_1.HttpError.isInstance(error) && typeof error.location === 'string';
    }
}
exports.RedirectHttpError = RedirectHttpError;
/**
 * Generates a {@link RedirectHttpErrorClass}, similar to how {@link generateHttpErrorClass} works.
 * The difference is that here a `location` field also gets set and the `getInstance` method
 * also uses the {@link RedirectHttpError.isInstance} function.
 */
function generateRedirectHttpErrorClass(code, name) {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const BaseClass = (0, HttpError_1.generateHttpErrorClass)(code, name);
    // Need to extend `BaseClass` instead of `RedirectHttpError` to have the required static methods
    return class SpecificRedirectHttpError extends BaseClass {
        constructor(location, message, options) {
            super(message, options);
            this.location = location;
        }
        static isInstance(error) {
            return RedirectHttpError.isInstance(error) && error.statusCode === code;
        }
    };
}
exports.generateRedirectHttpErrorClass = generateRedirectHttpErrorClass;
//# sourceMappingURL=RedirectHttpError.js.map