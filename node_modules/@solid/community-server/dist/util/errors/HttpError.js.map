{"version":3,"file":"HttpError.js","sourceRoot":"","sources":["../../../src/util/errors/HttpError.ts"],"names":[],"mappings":";;;AAAA,2BAAiC;AAEjC,0CAA0C;AAC1C,kDAA8C;AAC9C,2CAAsC;AACtC,IAAO,IAAI,GAAG,gBAAW,CAAC,IAAI,CAAC;AAQ/B;;GAEG;AACH,SAAgB,oBAAoB,CAAC,UAAkB;IACrD,OAAO,IAAA,sBAAW,EAAC,GAAG,0BAAW,CAAC,SAAS,IAAI,UAAU,EAAE,CAAC,CAAC;AAC/D,CAAC;AAFD,oDAEC;AAED;;;GAGG;AACH,MAAa,SAAqC,SAAQ,KAAK;IAM7D;;;;;;OAMG;IACH,YAAmB,UAAa,EAAE,IAAY,EAAE,OAAgB,EAAE,UAA4B,EAAE;QAC9F,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,IAAI,UAAU,EAAE,CAAC;QACvD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IACjC,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,KAAU;QACjC,OAAO,IAAA,mBAAO,EAAC,KAAK,CAAC,IAAI,OAAQ,KAAa,CAAC,UAAU,KAAK,QAAQ,CAAC;IACzE,CAAC;IAED;;OAEG;IACI,gBAAgB,CAAC,OAA8B;QACpD,sEAAsE;QACtE,uFAAuF;QACvF,wGAAwG;QACxG,OAAO;YACL,IAAI,CAAC,IAAA,sBAAW,EAAC,OAAO,CAAC,EAAE,0BAAW,CAAC,KAAK,CAAC,aAAa,EAAE,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SACnG,CAAC;IACJ,CAAC;CACF;AArCD,8BAqCC;AAuBD;;;;;;;;;GASG;AACH,SAAgB,sBAAsB,CAAuB,UAAiB,EAAE,IAAY;;IAC1F,YAAO,MAAM,iBAAkB,SAAQ,SAAgB;YAIrD,YAAmB,OAAgB,EAAE,OAA0B;gBAC7D,KAAK,CAAC,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;YAC5C,CAAC;YAEM,MAAM,CAAC,UAAU,CAAC,KAAU;gBACjC,OAAO,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,UAAU,KAAK,UAAU,CAAC;YACxE,CAAC;SACF;QAVwB,aAAU,GAAG,UAAW;QACxB,MAAG,GAAG,oBAAoB,CAAC,UAAU,CAAE;WAS9D;AACJ,CAAC;AAbD,wDAaC","sourcesContent":["import { DataFactory } from 'n3';\nimport type { NamedNode, Quad, Quad_Subject } from 'rdf-js';\nimport { toNamedTerm } from '../TermUtil';\nimport { SOLID_ERROR } from '../Vocabularies';\nimport { isError } from './ErrorUtil';\nimport quad = DataFactory.quad;\n\nexport interface HttpErrorOptions {\n  cause?: unknown;\n  errorCode?: string;\n  details?: NodeJS.Dict<unknown>;\n}\n\n/**\n * Returns a URI that is unique for the given status code.\n */\nexport function generateHttpErrorUri(statusCode: number): NamedNode {\n  return toNamedTerm(`${SOLID_ERROR.namespace}H${statusCode}`);\n}\n\n/**\n * A class for all errors that could be thrown by Solid.\n * All errors inheriting from this should fix the status code thereby hiding the HTTP internals from other components.\n */\nexport class HttpError<T extends number = number> extends Error implements HttpErrorOptions {\n  public readonly statusCode: T;\n  public readonly cause?: unknown;\n  public readonly errorCode: string;\n  public readonly details?: NodeJS.Dict<unknown>;\n\n  /**\n   * Creates a new HTTP error. Subclasses should call this with their fixed status code.\n   * @param statusCode - HTTP status code needed for the HTTP response.\n   * @param name - Error name. Useful for logging and stack tracing.\n   * @param message - Error message.\n   * @param options - Optional options.\n   */\n  public constructor(statusCode: T, name: string, message?: string, options: HttpErrorOptions = {}) {\n    super(message);\n    this.statusCode = statusCode;\n    this.name = name;\n    this.cause = options.cause;\n    this.errorCode = options.errorCode ?? `H${statusCode}`;\n    this.details = options.details;\n  }\n\n  public static isInstance(error: any): error is HttpError {\n    return isError(error) && typeof (error as any).statusCode === 'number';\n  }\n\n  /**\n   * Returns quads representing metadata relevant to this error.\n   */\n  public generateMetadata(subject: Quad_Subject | string): Quad[] {\n    // The reason we have this here instead of the generate function below\n    // is because we still want errors created with `new HttpError` to be treated identical\n    // as errors created with the constructor of the error class corresponding to that specific status code.\n    return [\n      quad(toNamedTerm(subject), SOLID_ERROR.terms.errorResponse, generateHttpErrorUri(this.statusCode)),\n    ];\n  }\n}\n\n/**\n * Interface describing what an HttpError class should look like.\n * This helps us make sure all HttpError classes have the same utility static functions.\n */\nexport interface HttpErrorClass<TCode extends number = number> {\n  new(message?: string, options?: HttpErrorOptions): HttpError<TCode>;\n\n  /**\n   * The status code corresponding to this error class.\n   */\n  readonly statusCode: TCode;\n  /**\n   * A unique URI identifying this error class.\n   */\n  readonly uri: NamedNode;\n  /**\n   * Checks if the given error is an instance of this class.\n   */\n  readonly isInstance: (error: any) => error is HttpError<TCode>;\n}\n\n/**\n * Generates a new HttpError class with the given status code and name.\n * In general, status codes are used to uniquely identify error types,\n * so there should be no 2 classes with the same value there.\n *\n * To make sure Components.js can work with these newly generated classes,\n * the generated class should be called `BaseHttpError` as that name is an entry in `.componentsignore`.\n * The actual class should then extend `BaseHttpError` and have a correct constructor,\n * so the Components.js generator can generate the correct components JSON-LD file during build.\n */\nexport function generateHttpErrorClass<TCode extends number>(statusCode: TCode, name: string): HttpErrorClass<TCode> {\n  return class SpecificHttpError extends HttpError<TCode> {\n    public static readonly statusCode = statusCode;\n    public static readonly uri = generateHttpErrorUri(statusCode);\n\n    public constructor(message?: string, options?: HttpErrorOptions) {\n      super(statusCode, name, message, options);\n    }\n\n    public static isInstance(error: any): error is SpecificHttpError {\n      return HttpError.isInstance(error) && error.statusCode === statusCode;\n    }\n  };\n}\n"]}