{"version":3,"file":"WrappedSetMultiMap.js","sourceRoot":"","sources":["../../../src/util/map/WrappedSetMultiMap.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SetMultiMap } from './SetMultiMap';\n\n/**\n * A {@link SetMultiMap} that uses an internal Map based on the provided constructor.\n *\n * In case no input constructor is provided, the default Map implementation will be used.\n *\n * It is required that the value type of this map is not Set or any extension of Set,\n * otherwise the `set` and `add` functions wil break.\n */\nexport class WrappedSetMultiMap<TKey, TVal> implements SetMultiMap<TKey, TVal> {\n  private count: number;\n  private readonly map: Map<TKey, Set<TVal>>;\n\n  /**\n   * @param mapConstructor - Will be used to instantiate the internal Map.\n   * @param iterable - Entries to add to the map.\n   */\n  public constructor(mapConstructor: new() => Map<any, any> = Map,\n    iterable?: Iterable<readonly [TKey, TVal | ReadonlySet<TVal>]>) {\n    this.map = new mapConstructor();\n    this.count = 0;\n\n    if (iterable) {\n      for (const [ key, val ] of iterable) {\n        this.add(key, val);\n      }\n    }\n  }\n\n  public has(key: TKey): boolean {\n    return this.map.has(key);\n  }\n\n  public hasEntry(key: TKey, value: TVal): boolean {\n    return Boolean(this.map.get(key)?.has(value));\n  }\n\n  public get(key: TKey): ReadonlySet<TVal> | undefined {\n    return this.map.get(key);\n  }\n\n  public set(key: TKey, value: ReadonlySet<TVal> | TVal): this {\n    const setCount = this.get(key)?.size ?? 0;\n    const set = value instanceof Set ? new Set(value) : new Set([ value ]);\n    this.count += set.size - setCount;\n    if (set.size > 0) {\n      this.map.set(key, set);\n    } else {\n      this.map.delete(key);\n    }\n\n    return this;\n  }\n\n  public add(key: TKey, value: TVal | ReadonlySet<TVal>): this {\n    const it = value instanceof Set ? value : [ value ];\n    let set = this.map.get(key);\n    if (set) {\n      const originalCount = set.size;\n      for (const entry of it) {\n        set.add(entry);\n      }\n      this.count += set.size - originalCount;\n    } else {\n      set = new Set(it);\n      this.count += set.size;\n      this.map.set(key, set);\n    }\n\n    return this;\n  }\n\n  public delete(key: TKey): boolean {\n    const setCount = this.get(key)?.size ?? 0;\n    const existed = this.map.delete(key);\n    this.count -= setCount;\n    return existed;\n  }\n\n  public deleteEntry(key: TKey, value: TVal): boolean {\n    const set = this.map.get(key);\n    if (set?.delete(value)) {\n      this.count -= 1;\n      if (set.size === 0) {\n        this.map.delete(key);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public clear(): void {\n    this.map.clear();\n    this.count = 0;\n  }\n\n  public asMap(): ReadonlyMap<TKey, ReadonlySet<TVal>> {\n    return this.map;\n  }\n\n  public [Symbol.iterator](): IterableIterator<[TKey, TVal]> {\n    return this.entries();\n  }\n\n  public* entries(): IterableIterator<[TKey, TVal]> {\n    for (const [ key, set ] of this.map) {\n      for (const value of set) {\n        yield [ key, value ];\n      }\n    }\n  }\n\n  public* entrySets(): IterableIterator<[TKey, ReadonlySet<TVal>]> {\n    yield* this.map.entries();\n  }\n\n  public* keys(): IterableIterator<TKey> {\n    for (const [ key ] of this.entries()) {\n      yield key;\n    }\n  }\n\n  public distinctKeys(): IterableIterator<TKey> {\n    return this.map.keys();\n  }\n\n  public* values(): IterableIterator<TVal> {\n    for (const [ , value ] of this.entries()) {\n      yield value;\n    }\n  }\n\n  public valueSets(): IterableIterator<ReadonlySet<TVal>> {\n    return this.map.values();\n  }\n\n  public forEach(callbackfn: (value: TVal, key: TKey, map: SetMultiMap<TKey, TVal>) => void, thisArg?: any): void {\n    for (const [ key, value ] of this) {\n      callbackfn.bind(thisArg)(value, key, this);\n    }\n  }\n\n  public get size(): number {\n    return this.count;\n  }\n\n  public readonly [Symbol.toStringTag] = 'WrappedSetMultiMap';\n}\n"]}