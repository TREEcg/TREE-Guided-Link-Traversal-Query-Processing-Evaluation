"use strict";
// Utility functions for iterables that avoid array conversion
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduce = exports.find = exports.concat = exports.filter = exports.map = void 0;
/**
 * Creates a new iterable with the results of calling a provided function on every element in the calling array.
 * Similar to the {@link Array.prototype.map} function.
 * See the documentation of the above function for more details.
 *
 * @param iterable - Iterable on which to call the map function.
 * @param callbackFn - Function that is called for every element.
 * @param thisArg - Value to use as `this` when executing `callbackFn`.
 */
function* map(iterable, callbackFn, thisArg) {
    const boundMapFn = callbackFn.bind(thisArg);
    let count = 0;
    for (const value of iterable) {
        yield boundMapFn(value, count);
        count += 1;
    }
}
exports.map = map;
/**
 * Creates a new iterable with all elements that pass the test implemented by the provided function.
 * Similar to the {@link Array.prototype.filter} function.
 * See the documentation of the above function for more details.
 *
 * @param iterable - Iterable on which to call the map function.
 * @param callbackFn - Function that is called to test every element.
 * @param thisArg - Value to use as `this` when executing `callbackFn`.
 */
function* filter(iterable, callbackFn, thisArg) {
    const boundFilterFn = callbackFn.bind(thisArg);
    let count = 0;
    for (const value of iterable) {
        if (boundFilterFn(value, count)) {
            yield value;
        }
        count += 1;
    }
}
exports.filter = filter;
/**
 * Creates a new iterable that is a concatenation of all the iterables in the input.
 * @param iterables - An iterable of which the contents will be concatenated into a new iterable.
 */
function* concat(iterables) {
    for (const iterable of iterables) {
        yield* iterable;
    }
}
exports.concat = concat;
/**
 * Returns the first element in the provided iterable that satisfies the provided testing function.
 * If no values satisfy the testing function, `undefined` is returned.
 * Similar to the {@link Array.prototype.find} function.
 * See the documentation of the above function for more details.
 *
 * @param iterable - Iterable on which to call the map function.
 * @param callbackFn - Function that is called to test every element.
 * @param thisArg - Value to use as `this` when executing `callbackFn`.
 */
function find(iterable, callbackFn, thisArg) {
    const boundMapFn = callbackFn.bind(thisArg);
    const count = 0;
    for (const value of iterable) {
        if (boundMapFn(value, count)) {
            return value;
        }
    }
}
exports.find = find;
function reduce(iterable, callbackFn, initialValue) {
    const iterator = iterable[Symbol.iterator]();
    let count = 0;
    if (!initialValue) {
        const next = iterator.next();
        if (next.done) {
            throw new TypeError('Iterable is empty and no initial value was provided.');
        }
        // `initialValue` being undefined means the first signature was used where TIn === TOut
        initialValue = next.value;
        count += 1;
    }
    let previousValue = initialValue;
    let next = iterator.next();
    while (!next.done) {
        previousValue = callbackFn(previousValue, next.value, count);
        next = iterator.next();
        count += 1;
    }
    return previousValue;
}
exports.reduce = reduce;
//# sourceMappingURL=IterableUtil.js.map