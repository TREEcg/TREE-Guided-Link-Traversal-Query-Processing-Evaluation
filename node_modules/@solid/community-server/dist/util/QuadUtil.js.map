{"version":3,"file":"QuadUtil.js","sourceRoot":"","sources":["../../src/util/QuadUtil.ts"],"names":[],"mappings":";;;;;;AAEA,sEAA6C;AAE7C,2BAAgD;AAGhD,6CAA6D;AAC7D,yCAAyC;AAEzC;;;;;;GAMG;AACH,SAAgB,cAAc,CAAC,KAAa,EAAE,WAAoB;IAChE,OAAO,IAAA,uBAAU,EAAC,IAAA,8BAAiB,EAAC,KAAK,CAAC,EAAE,IAAI,iBAAY,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,CAAC,CAAC,CAAC;AACzF,CAAC;AAFD,wCAEC;AAED;;;;;;GAMG;AACI,KAAK,UAAU,UAAU,CAAC,QAA2B,EAAE,UAAyB,EAAE;IACvF,OAAO,IAAA,yBAAc,EAAC,IAAA,uBAAU,EAAC,QAAQ,EAAE,IAAI,iBAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACzE,CAAC;AAFD,gCAEC;AAED;;;;;GAKG;AACH,SAAgB,WAAW,CAAC,KAAa;IACvC,OAAO,KAAK,CAAC,MAAM,CAAS,CAAC,MAAM,EAAE,IAAI,EAAU,EAAE;QACnD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,EAAW,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;YACtD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACnB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC;AAPD,kCAOC;AAED;;GAEG;AACH,MAAa,aAAa;IAKxB;;;;OAIG;IACH,YAAmB,OAAgB,EAAE,SAAkB,EAAE,MAAe;QACtE,IAAI,CAAC,OAAO,GAAG,OAAO,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC,IAAA,sBAAW,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC5E,IAAI,CAAC,SAAS,GAAG,OAAO,SAAS,KAAK,WAAW,CAAC,CAAC,CAAC,IAAA,sBAAW,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAClF,IAAI,CAAC,MAAM,GAAG,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,IAAA,sBAAW,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC3E,CAAC;CACF;AAfD,sCAeC","sourcesContent":["import type { Readable } from 'stream';\nimport type { NamedNode } from '@rdfjs/types';\nimport arrayifyStream from 'arrayify-stream';\nimport type { ParserOptions } from 'n3';\nimport { StreamParser, StreamWriter } from 'n3';\nimport type { Quad } from 'rdf-js';\nimport type { Guarded } from './GuardedStream';\nimport { guardedStreamFrom, pipeSafely } from './StreamUtil';\nimport { toNamedTerm } from './TermUtil';\n\n/**\n * Helper function for serializing an array of quads, with as result a Readable object.\n * @param quads - The array of quads.\n * @param contentType - The content-type to serialize to.\n *\n * @returns The Readable object.\n */\nexport function serializeQuads(quads: Quad[], contentType?: string): Guarded<Readable> {\n  return pipeSafely(guardedStreamFrom(quads), new StreamWriter({ format: contentType }));\n}\n\n/**\n * Helper function to convert a Readable into an array of quads.\n * @param readable - The readable object.\n * @param options - Options for the parser.\n *\n * @returns A promise containing the array of quads.\n */\nexport async function parseQuads(readable: Guarded<Readable>, options: ParserOptions = {}): Promise<Quad[]> {\n  return arrayifyStream(pipeSafely(readable, new StreamParser(options)));\n}\n\n/**\n * Filter out duplicate quads from an array.\n * @param quads - Quads to filter.\n *\n * @returns A new array containing the unique quads.\n */\nexport function uniqueQuads(quads: Quad[]): Quad[] {\n  return quads.reduce<Quad[]>((result, quad): Quad[] => {\n    if (!result.some((item): boolean => quad.equals(item))) {\n      result.push(quad);\n    }\n    return result;\n  }, []);\n}\n\n/**\n * Represents a triple pattern to be used as a filter.\n */\nexport class FilterPattern {\n  public readonly subject: NamedNode | null;\n  public readonly predicate: NamedNode | null;\n  public readonly object: NamedNode | null;\n\n  /**\n   * @param subject - Optionally filter based on a specific subject.\n   * @param predicate - Optionally filter based on a predicate.\n   * @param object - Optionally filter based on a specific object.\n   */\n  public constructor(subject?: string, predicate?: string, object?: string) {\n    this.subject = typeof subject !== 'undefined' ? toNamedTerm(subject) : null;\n    this.predicate = typeof predicate !== 'undefined' ? toNamedTerm(predicate) : null;\n    this.object = typeof object !== 'undefined' ? toNamedTerm(object) : null;\n  }\n}\n"]}