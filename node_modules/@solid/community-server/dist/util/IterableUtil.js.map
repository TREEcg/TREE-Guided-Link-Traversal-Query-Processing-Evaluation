{"version":3,"file":"IterableUtil.js","sourceRoot":"","sources":["../../src/util/IterableUtil.ts"],"names":[],"mappings":";AAAA,8DAA8D;;;AAE9D;;;;;;;;GAQG;AACH,QAAe,CAAC,CAAC,GAAG,CAAY,QAAuB,EAAE,UAAiD,EACxG,OAAa;IACb,MAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC5C,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;QAC5B,MAAM,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC/B,KAAK,IAAI,CAAC,CAAC;KACZ;AACH,CAAC;AARD,kBAQC;AAED;;;;;;;;GAQG;AACH,QAAe,CAAC,CAAC,MAAM,CAAI,QAAqB,EAAE,UAAkD,EAClG,OAAa;IACb,MAAM,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;QAC5B,IAAI,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;YAC/B,MAAM,KAAK,CAAC;SACb;QACD,KAAK,IAAI,CAAC,CAAC;KACZ;AACH,CAAC;AAVD,wBAUC;AAED;;;GAGG;AACH,QAAe,CAAC,CAAC,MAAM,CAAI,SAAgC;IACzD,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;QAChC,KAAK,CAAC,CAAC,QAAQ,CAAC;KACjB;AACH,CAAC;AAJD,wBAIC;AAED;;;;;;;;;GASG;AACH,SAAgB,IAAI,CAAI,QAAqB,EAAE,UAAkD,EAAE,OAAa;IAE9G,MAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC5C,MAAM,KAAK,GAAG,CAAC,CAAC;IAChB,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;QAC5B,IAAI,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;YAC5B,OAAO,KAAK,CAAC;SACd;KACF;AACH,CAAC;AATD,oBASC;AAsBD,SAAgB,MAAM,CAAY,QAAuB,EACvD,UAAkF,EAAE,YAAmB;IACvG,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IAC7C,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;SAC7E;QACD,uFAAuF;QACvF,YAAY,GAAG,IAAI,CAAC,KAAwB,CAAC;QAC7C,KAAK,IAAI,CAAC,CAAC;KACZ;IACD,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;IAC3B,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE;QACjB,aAAa,GAAG,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC7D,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,CAAC;KACZ;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AArBD,wBAqBC","sourcesContent":["// Utility functions for iterables that avoid array conversion\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element in the calling array.\n * Similar to the {@link Array.prototype.map} function.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable on which to call the map function.\n * @param callbackFn - Function that is called for every element.\n * @param thisArg - Value to use as `this` when executing `callbackFn`.\n */\nexport function* map<TIn, TOut>(iterable: Iterable<TIn>, callbackFn: (element: TIn, index: number) => TOut,\n  thisArg?: any): Iterable<TOut> {\n  const boundMapFn = callbackFn.bind(thisArg);\n  let count = 0;\n  for (const value of iterable) {\n    yield boundMapFn(value, count);\n    count += 1;\n  }\n}\n\n/**\n * Creates a new iterable with all elements that pass the test implemented by the provided function.\n * Similar to the {@link Array.prototype.filter} function.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable on which to call the map function.\n * @param callbackFn - Function that is called to test every element.\n * @param thisArg - Value to use as `this` when executing `callbackFn`.\n */\nexport function* filter<T>(iterable: Iterable<T>, callbackFn: (element: T, index: number) => boolean,\n  thisArg?: any): Iterable<T> {\n  const boundFilterFn = callbackFn.bind(thisArg);\n  let count = 0;\n  for (const value of iterable) {\n    if (boundFilterFn(value, count)) {\n      yield value;\n    }\n    count += 1;\n  }\n}\n\n/**\n * Creates a new iterable that is a concatenation of all the iterables in the input.\n * @param iterables - An iterable of which the contents will be concatenated into a new iterable.\n */\nexport function* concat<T>(iterables: Iterable<Iterable<T>>): Iterable<T> {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\n/**\n * Returns the first element in the provided iterable that satisfies the provided testing function.\n * If no values satisfy the testing function, `undefined` is returned.\n * Similar to the {@link Array.prototype.find} function.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable on which to call the map function.\n * @param callbackFn - Function that is called to test every element.\n * @param thisArg - Value to use as `this` when executing `callbackFn`.\n */\nexport function find<T>(iterable: Iterable<T>, callbackFn: (element: T, index: number) => boolean, thisArg?: any):\nT | undefined {\n  const boundMapFn = callbackFn.bind(thisArg);\n  const count = 0;\n  for (const value of iterable) {\n    if (boundMapFn(value, count)) {\n      return value;\n    }\n  }\n}\n\n/**\n * Similar to the {@link Array.prototype.reduce} function, but for an iterable.\n * See the documentation of the above function for more details.\n * The first element will be used as the initial value.\n *\n * @param iterable - Iterable of which to reduce the elements.\n * @param callbackFn - A reducer function.\n */\nexport function reduce<TIn>(iterable: Iterable<TIn>,\n  callbackFn: (previousValue: TIn, currentValue: TIn, currentIndex: number) => TIn): TIn;\n/**\n * Similar to the {@link Array.prototype.reduce} function, but for an iterable.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable of which to reduce the elements.\n * @param callbackFn - A reducer function.\n * @param initialValue - The value to start from.\n */\nexport function reduce<TIn, TOut>(iterable: Iterable<TIn>,\n  callbackFn: (previousValue: TOut, currentValue: TIn, currentIndex: number) => TOut, initialValue: TOut): TOut;\nexport function reduce<TIn, TOut>(iterable: Iterable<TIn>,\n  callbackFn: (previousValue: TOut, currentValue: TIn, currentIndex: number) => TOut, initialValue?: TOut): TOut {\n  const iterator = iterable[Symbol.iterator]();\n  let count = 0;\n  if (!initialValue) {\n    const next = iterator.next();\n    if (next.done) {\n      throw new TypeError('Iterable is empty and no initial value was provided.');\n    }\n    // `initialValue` being undefined means the first signature was used where TIn === TOut\n    initialValue = next.value as unknown as TOut;\n    count += 1;\n  }\n  let previousValue = initialValue;\n  let next = iterator.next();\n  while (!next.done) {\n    previousValue = callbackFn(previousValue, next.value, count);\n    next = iterator.next();\n    count += 1;\n  }\n  return previousValue;\n}\n"]}