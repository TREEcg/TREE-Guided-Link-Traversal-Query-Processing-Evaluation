{"version":3,"file":"EjsTemplateEngine.js","sourceRoot":"","sources":["../../../src/util/templates/EjsTemplateEngine.ts"],"names":[],"mappings":";;;AAGA,6BAAsC;AAEtC,qDAAqE;AAGrE;;GAEG;AACH,MAAa,iBAAiB;IAI5B;;;OAGG;IACH,YAAmB,OAAe,EAAE,QAAmB;QACrD,gFAAgF;QAChF,MAAM,QAAQ,GAAG,IAAA,oCAAmB,EAAC,QAAQ,CAAC,CAAC;QAC/C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,IAAI,CAAC,aAAa,GAAG,IAAA,6BAAY,EAAC,QAAQ,CAAC;aACxC,IAAI,CAAC,CAAC,cAAsB,EAAoB,EAAE,CAAC,IAAA,aAAO,EAAC,cAAc,EAAE,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;IAC/F,CAAC;IAIM,KAAK,CAAC,MAAM,CAAc,QAAiB,EAAE,QAAmB;QACrE,MAAM,OAAO,GAAG,EAAE,GAAG,QAAQ,EAAE,QAAQ,EAAE,IAAA,oCAAmB,EAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;QAChG,OAAO,QAAQ,CAAC,CAAC,CAAC,IAAA,YAAM,EAAC,MAAM,IAAA,6BAAY,EAAC,QAAQ,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,CAAC;IACxG,CAAC;CACF;AAvBD,8CAuBC","sourcesContent":["/* eslint-disable tsdoc/syntax */\n// tsdoc/syntax cannot handle `@range`\nimport type { TemplateFunction } from 'ejs';\nimport { compile, render } from 'ejs';\nimport type { TemplateEngine, Template } from './TemplateEngine';\nimport { getTemplateFilePath, readTemplate } from './TemplateEngine';\nimport Dict = NodeJS.Dict;\n\n/**\n * Fills in EJS templates.\n */\nexport class EjsTemplateEngine<T extends Dict<any> = Dict<any>> implements TemplateEngine<T> {\n  private readonly applyTemplate: Promise<TemplateFunction>;\n  private readonly baseUrl: string;\n\n  /**\n   * @param baseUrl - Base URL of the server.\n   * @param template - The default template @range {json}\n   */\n  public constructor(baseUrl: string, template?: Template) {\n    // EJS requires the `filename` parameter to be able to include partial templates\n    const filename = getTemplateFilePath(template);\n    this.baseUrl = baseUrl;\n\n    this.applyTemplate = readTemplate(template)\n      .then((templateString: string): TemplateFunction => compile(templateString, { filename }));\n  }\n\n  public async render(contents: T): Promise<string>;\n  public async render<TCustom = T>(contents: TCustom, template: Template): Promise<string>;\n  public async render<TCustom = T>(contents: TCustom, template?: Template): Promise<string> {\n    const options = { ...contents, filename: getTemplateFilePath(template), baseUrl: this.baseUrl };\n    return template ? render(await readTemplate(template), options) : (await this.applyTemplate)(options);\n  }\n}\n"]}