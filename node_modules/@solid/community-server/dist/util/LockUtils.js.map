{"version":3,"file":"LockUtils.js","sourceRoot":"","sources":["../../src/util/LockUtils.ts"],"names":[],"mappings":";;;AAAA,gDAAkD;AAClD,sEAAmE;AAEnE,MAAM,MAAM,GAAG,IAAA,sBAAY,EAAC,UAAU,CAAC,CAAC;AAExC;;;;;GAKG;AACI,KAAK,UAAU,gBAAgB,CAAC,KAAa,EAAE,MAAM,GAAG,CAAC;IAC9D,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC;IACzD,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,GAAG,MAAM,CAAC,CAAC;IACpC,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAO,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;AACzE,CAAC;AAJD,4CAIC;AAWD;;;;;;;;GAQG;AACI,KAAK,UAAU,aAAa,CAAI,EAAoB,EAAE,QAAmC;IAC9F,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG,QAAQ,CAAC;IACzD,MAAM,QAAQ,GAAG,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC;IAC/E,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,MAAM,GAAG,MAAM,EAAE,EAAE,CAAC;IAExB,OAAO,OAAO,MAAM,KAAK,WAAW,IAAI,KAAK,GAAG,QAAQ,EAAE;QACxD,MAAM,gBAAgB,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;QAChD,MAAM,GAAG,MAAM,EAAE,EAAE,CAAC;QACpB,KAAK,IAAI,CAAC,CAAC;KACZ;IAED,sCAAsC;IACtC,IAAI,KAAK,IAAI,QAAQ,EAAE;QACrB,MAAM,GAAG,GAAG,iEAAiE,QAAQ,IAAI,CAAC;QAC1F,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjB,MAAM,IAAI,yCAAmB,CAAC,GAAG,CAAC,CAAC;KACpC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AApBD,sCAoBC","sourcesContent":["import { getLoggerFor } from '../logging/LogUtil';\nimport { InternalServerError } from './errors/InternalServerError';\n\nconst logger = getLoggerFor('LockUtil');\n\n/**\n * Waits a set amount of time, without consuming cpu, with a set amount of jitter.\n * @param delay - How long to wait.\n * @param jitter - A fraction of this jitter will be added to the delay.\n * @returns A promise that resolves after the specified amount of time.\n */\nexport async function setJitterTimeout(delay: number, jitter = 0): Promise<void> {\n  jitter = Math.max(0, Math.floor(Math.random() * jitter));\n  delay = Math.max(0, delay + jitter);\n  return new Promise<void>((resolve): any => setTimeout(resolve, delay));\n}\n\nexport interface AttemptSettings {\n  /** How many times should an operation be retried. (-1 is indefinitely). */\n  retryCount?: number;\n  /** The how long should the next retry be delayed (+ some retryJitter) (in ms). */\n  retryDelay?: number;\n  /** Add a fraction of jitter to the original delay each attempt (in ms). */\n  retryJitter?: number;\n}\n\n/**\n * Will execute the given function until one of the following cases occurs:\n * * The function resolves to a value: the value is returned.\n * * The function errors: the rejected error is thrown.\n * * The function did not resolve after the set amount of retries:\n *   the rejected error is returned.\n * @param fn - The function to retry. **This function must return a value!**\n * @param settings - The options on how to retry the function\n */\nexport async function retryFunction<T>(fn: () => Promise<T>, settings: Required<AttemptSettings>): Promise<T> {\n  const { retryCount, retryDelay, retryJitter } = settings;\n  const maxTries = retryCount === -1 ? Number.POSITIVE_INFINITY : retryCount + 1;\n  let tries = 1;\n  let result = await fn();\n\n  while (typeof result === 'undefined' && tries < maxTries) {\n    await setJitterTimeout(retryDelay, retryJitter);\n    result = await fn();\n    tries += 1;\n  }\n\n  // Max tries was reached: throw first!\n  if (tries >= maxTries) {\n    const err = `The operation did not succeed after the set maximum of tries (${maxTries}).`;\n    logger.warn(err);\n    throw new InternalServerError(err);\n  }\n\n  return result;\n}\n"]}