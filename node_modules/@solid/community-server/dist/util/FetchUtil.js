"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.responseToDataset = exports.fetchDataset = void 0;
const arrayify_stream_1 = __importDefault(require("arrayify-stream"));
const rdf_dereference_1 = __importDefault(require("rdf-dereference"));
const BasicRepresentation_1 = require("../http/representation/BasicRepresentation");
const LogUtil_1 = require("../logging/LogUtil");
const ContentTypes_1 = require("./ContentTypes");
const BadRequestHttpError_1 = require("./errors/BadRequestHttpError");
const ErrorUtil_1 = require("./errors/ErrorUtil");
const logger = (0, LogUtil_1.getLoggerFor)('FetchUtil');
/**
 * Fetches an RDF dataset from the given URL.
 *
 * Response will be a Representation with content-type internal/quads.
 */
async function fetchDataset(url) {
    // Try content negotiation to parse quads from the URL
    return (async () => {
        try {
            const quadStream = (await rdf_dereference_1.default.dereference(url)).data;
            const quadArray = await (0, arrayify_stream_1.default)(quadStream);
            return new BasicRepresentation_1.BasicRepresentation(quadArray, { path: url }, ContentTypes_1.INTERNAL_QUADS, false);
        }
        catch (error) {
            throw new BadRequestHttpError_1.BadRequestHttpError(`Could not parse resource at URL (${url})! ${(0, ErrorUtil_1.createErrorMessage)(error)}`);
        }
    })();
}
exports.fetchDataset = fetchDataset;
/**
 * Converts a given Response (from a request that was already made) to  an RDF dataset.
 * In case the given Response object was already parsed its body can be passed along as a string.
 *
 * The converter will be used to convert the response body to RDF.
 *
 * Response will be a Representation with content-type internal/quads.
 */
async function responseToDataset(response, converter, body) {
    if (!body) {
        body = await response.text();
    }
    // Keeping the error message the same everywhere to prevent leaking possible information about intranet.
    const error = new BadRequestHttpError_1.BadRequestHttpError(`Unable to access data at ${response.url}`);
    if (response.status !== 200) {
        logger.warn(`Cannot fetch ${response.url}: ${body}`);
        throw error;
    }
    const contentType = response.headers.get('content-type');
    if (!contentType) {
        logger.warn(`Missing content-type header from ${response.url}`);
        throw error;
    }
    // Try to convert to quads
    const representation = new BasicRepresentation_1.BasicRepresentation(body, contentType);
    const preferences = { type: { [ContentTypes_1.INTERNAL_QUADS]: 1 } };
    return converter.handleSafe({ representation, identifier: { path: response.url }, preferences });
}
exports.responseToDataset = responseToDataset;
//# sourceMappingURL=FetchUtil.js.map