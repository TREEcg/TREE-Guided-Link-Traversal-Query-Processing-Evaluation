{"version":3,"file":"RedisLocker.js","sourceRoot":"","sources":["../../../src/util/locking/RedisLocker.ts"],"names":[],"mappings":"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","sourcesContent":["import Redis from 'ioredis';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { Finalizable } from '../../init/final/Finalizable';\nimport type { Initializable } from '../../init/Initializable';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { AttemptSettings } from '../LockUtils';\nimport { retryFunction } from '../LockUtils';\nimport type { ReadWriteLocker } from './ReadWriteLocker';\nimport type { ResourceLocker } from './ResourceLocker';\nimport type { RedisResourceLock, RedisReadWriteLock, RedisAnswer } from './scripts/RedisLuaScripts';\nimport { fromResp2ToBool, REDIS_LUA_SCRIPTS } from './scripts/RedisLuaScripts';\n\nconst attemptDefaults: Required<AttemptSettings> = { retryCount: -1, retryDelay: 50, retryJitter: 30 };\n\n// Internal prefix for Redis keys;\nconst PREFIX_RW = '__RW__';\nconst PREFIX_LOCK = '__L__';\n\nexport interface RedisSettings {\n  /* Override default namespacePrefixes (used to prefix keys in Redis) */\n  namespacePrefix: string;\n  /* Username used for AUTH on the Redis server */\n  username?: string;\n  /* Password used for AUTH on the Redis server */\n  password?: string;\n  /* The number of the database to use */\n  db?: number;\n}\n\n/**\n * A Redis Locker that can be used as both:\n *  *  a Read Write Locker that uses a (single) Redis server to store the locks and counts.\n *  *  a Resource Locker that uses a (single) Redis server to store the lock.\n * This solution should be process-safe. The only references to locks are string keys\n * derived from identifier paths.\n *\n * The Read Write algorithm roughly goes as follows:\n *  * Acquire a read lock: allowed as long as there is no write lock. On acquiring the read counter goes up.\n *  * Acquire a write lock: allowed as long as there is no other write lock AND the read counter is 0.\n *  * Release a read lock: decreases the read counter with 1\n *  * Release a write lock: unlocks the write lock\n *\n * The Resource locking algorithm uses a single mutex/lock.\n *\n * All operations, such as checking for a write lock AND read count, are executed in a single Lua script.\n * These scripts are used by Redis as a single new command.\n * Redis executes its operations in a single thread, as such, each such operation can be considered atomic.\n *\n * The operation to (un)lock will always resolve with either 1/OK/true if succeeded or 0/false if not succeeded.\n * Rejection with errors will be happen on actual failures. Retrying the (un)lock operations will be done by making\n * use of the LockUtils' {@link retryFunctionUntil} function.\n *\n * * @see [Redis Commands documentation](https://redis.io/commands/)\n * * @see [Redis Lua scripting documentation](https://redis.io/docs/manual/programmability/)\n * * @see [ioredis Lua scripting API](https://github.com/luin/ioredis#lua-scripting)\n */\nexport class RedisLocker implements ReadWriteLocker, ResourceLocker, Initializable, Finalizable {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly redis: Redis;\n  private readonly redisRw: RedisReadWriteLock;\n  private readonly redisLock: RedisResourceLock;\n  private readonly attemptSettings: Required<AttemptSettings>;\n  private readonly namespacePrefix: string;\n  private finalized = false;\n\n  /**\n   * Creates a new RedisClient\n   * @param redisClient - Redis connection string of a standalone Redis node\n   * @param attemptSettings - Override default AttemptSettings\n   * @param redisSettings - Addition settings used to create the Redis client or to interact with the Redis server\n   */\n  public constructor(\n    redisClient = '127.0.0.1:6379',\n    attemptSettings: AttemptSettings = {},\n    redisSettings: RedisSettings = { namespacePrefix: '' },\n  ) {\n    const { namespacePrefix, ...options } = redisSettings;\n    this.redis = this.createRedisClient(redisClient, options);\n    this.attemptSettings = { ...attemptDefaults, ...attemptSettings };\n    this.namespacePrefix = namespacePrefix;\n\n    // Register lua scripts\n    for (const [ name, script ] of Object.entries(REDIS_LUA_SCRIPTS)) {\n      this.redis.defineCommand(name, { numberOfKeys: 1, lua: script });\n    }\n\n    this.redisRw = this.redis as RedisReadWriteLock;\n    this.redisLock = this.redis as RedisResourceLock;\n  }\n\n  /**\n   * Generate and return a RedisClient based on the provided string\n   * @param redisClientString - A string that contains either a host address and a\n   *                            port number like '127.0.0.1:6379' or just a port number like '6379'.\n   */\n  private createRedisClient(redisClientString: string, options: Omit<RedisSettings, 'namespacePrefix'>): Redis {\n    if (redisClientString.length > 0) {\n      // Check if port number or ip with port number\n      // Definitely not perfect, but configuring this is only for experienced users\n      const match = /^(?:([^:]+):)?(\\d{4,5})$/u.exec(redisClientString);\n      if (!match || !match[2]) {\n        // At least a port number should be provided\n        throw new Error(`Invalid data provided to create a Redis client: ${redisClientString}\\n\n            Please provide a port number like '6379' or a host address and a port number like '127.0.0.1:6379'`);\n      }\n      const port = Number(match[2]);\n      const host = match[1];\n      return new Redis(port, host, options);\n    }\n    throw new Error(`Empty redisClientString provided!\\n\n            Please provide a port number like '6379' or a host address and a port number like '127.0.0.1:6379'`);\n  }\n\n  /**\n   * Create a scoped Redis key for Read-Write locking.\n   * @param identifier - The identifier object to create a Redis key for\n   * @returns A scoped Redis key that allows cleanup afterwards without affecting other keys.\n   */\n  private getReadWriteKey(identifier: ResourceIdentifier): string {\n    return `${this.namespacePrefix}${PREFIX_RW}${identifier.path}`;\n  }\n\n  /**\n   * Create a scoped Redis key for Resource locking.\n   * @param identifier - The identifier object to create a Redis key for\n   * @returns A scoped Redis key that allows cleanup afterwards without affecting other keys.\n   */\n  private getResourceKey(identifier: ResourceIdentifier): string {\n    return `${this.namespacePrefix}${PREFIX_LOCK}${identifier.path}`;\n  }\n\n  /* ReadWriteLocker methods */\n\n  /**\n   * Wrapper function for all (un)lock operations. If the `fn()` resolves to false (after applying\n   * {@link fromResp2ToBool}, the result will be swallowed. When `fn()` resolves to true, this wrapper\n   * will return true. Any error coming from `fn()` will be thrown.\n   * @param fn - The function reference to swallow false from.\n   */\n  private swallowFalse(fn: () => Promise<RedisAnswer>): () => Promise<unknown> {\n    if (this.finalized) {\n      throw new Error('Invalid state: cannot execute Redis operation once finalize() has been called.');\n    }\n    return async(): Promise<unknown> => {\n      const result = await fromResp2ToBool(fn());\n      // Swallow any result resolving to `false`\n      if (result) {\n        return true;\n      }\n    };\n  }\n\n  public async withReadLock<T>(identifier: ResourceIdentifier, whileLocked: () => (Promise<T> | T)): Promise<T> {\n    const key = this.getReadWriteKey(identifier);\n    await retryFunction(\n      this.swallowFalse(this.redisRw.acquireReadLock.bind(this.redisRw, key)),\n      this.attemptSettings,\n    );\n    try {\n      return await whileLocked();\n    } finally {\n      await retryFunction(\n        this.swallowFalse(this.redisRw.releaseReadLock.bind(this.redisRw, key)),\n        this.attemptSettings,\n      );\n    }\n  }\n\n  public async withWriteLock<T>(identifier: ResourceIdentifier, whileLocked: () => (Promise<T> | T)): Promise<T> {\n    const key = this.getReadWriteKey(identifier);\n    await retryFunction(\n      this.swallowFalse(this.redisRw.acquireWriteLock.bind(this.redisRw, key)),\n      this.attemptSettings,\n    );\n    try {\n      return await whileLocked();\n    } finally {\n      await retryFunction(\n        this.swallowFalse(this.redisRw.releaseWriteLock.bind(this.redisRw, key)),\n        this.attemptSettings,\n      );\n    }\n  }\n\n  /* ResourceLocker methods */\n\n  public async acquire(identifier: ResourceIdentifier): Promise<void> {\n    const key = this.getResourceKey(identifier);\n    await retryFunction(\n      this.swallowFalse(this.redisLock.acquireLock.bind(this.redisLock, key)),\n      this.attemptSettings,\n    );\n  }\n\n  public async release(identifier: ResourceIdentifier): Promise<void> {\n    const key = this.getResourceKey(identifier);\n    await retryFunction(\n      this.swallowFalse(this.redisLock.releaseLock.bind(this.redisLock, key)),\n      this.attemptSettings,\n    );\n  }\n\n  /* Initializer & Finalizer methods */\n\n  public async initialize(): Promise<void> {\n    // On server start: remove all existing (dangling) locks, so new requests are not blocked.\n    return this.clearLocks();\n  }\n\n  public async finalize(): Promise<void> {\n    this.finalized = true;\n    try {\n      // On controlled server shutdown: clean up all existing locks.\n      return await this.clearLocks();\n    } finally {\n      // Always quit the redis client\n      await this.redis.quit();\n    }\n  }\n\n  /**\n   * Remove any lock still open\n   */\n  private async clearLocks(): Promise<void> {\n    const keysRw = await this.redisRw.keys(`${this.namespacePrefix}${PREFIX_RW}*`);\n    if (keysRw.length > 0) {\n      await this.redisRw.del(...keysRw);\n    }\n\n    const keysLock = await this.redisLock.keys(`${this.namespacePrefix}${PREFIX_LOCK}*`);\n    if (keysLock.length > 0) {\n      await this.redisLock.del(...keysLock);\n    }\n  }\n}\n"]}