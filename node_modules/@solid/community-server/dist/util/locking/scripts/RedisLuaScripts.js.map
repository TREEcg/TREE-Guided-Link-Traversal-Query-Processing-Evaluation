{"version":3,"file":"RedisLuaScripts.js","sourceRoot":"","sources":["../../../../src/util/locking/scripts/RedisLuaScripts.ts"],"names":[],"mappings":";;;AACA,0EAAuE;AAEvE,MAAM,YAAY,GAAG,QAAQ,CAAC;AAC9B,MAAM,WAAW,GAAG,OAAO,CAAC;AAC5B,MAAM,YAAY,GAAG,QAAQ,CAAC;AAC9B,MAAM,MAAM,GAAG,QAAQ,CAAC;AAExB;;GAEG;AACU,QAAA,iBAAiB,GAAG;IAC/B,eAAe,EAAE;;gCAEa,YAAY;;;;;;iCAMX,YAAY;;KAExC;IACH,gBAAgB,EAAE;;gCAEY,YAAY;iCACX,YAAY;;;;;;;yCAOJ,MAAM;KAC1C;IACH,eAAe,EAAE;;mCAEgB,YAAY;;;;;;;KAO1C;IACH,gBAAgB,EAAE;;kCAEc,YAAY;;;;;;;KAOzC;IACH,WAAW,EAAE;;8BAEe,WAAW;;;;;;uCAMF,MAAM;OACtC;IACL,WAAW,EAAE;;8BAEe,WAAW;;;;;;;KAOpC;CACK,CAAC;AAIX;;;;;;;GAOG;AACI,KAAK,UAAU,eAAe,CAAC,MAA4B;IAChE,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC;IACzB,QAAQ,GAAG,EAAE;QACX,KAAK,CAAC,CAAC;QACP,KAAK,IAAI;YACP,OAAO,IAAI,CAAC;QACd,KAAK,CAAC;YACJ,OAAO,KAAK,CAAC;QACf,KAAK,IAAI;YACP,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;QACtE;YACE,IAAI,GAAG,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;gBACrC,MAAM,IAAI,yCAAmB,CAAC,gBAAgB,GAAG,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;aAC1E;iBAAM;gBACL,MAAM,IAAI,yCAAmB,CAAC,sCAAsC,GAAG,GAAG,CAAC,CAAC;aAC7E;KACJ;AACH,CAAC;AAjBD,0CAiBC","sourcesContent":["import type { Callback, Redis } from 'ioredis';\nimport { InternalServerError } from '../../errors/InternalServerError';\n\nconst SUFFIX_WLOCK = '.wlock';\nconst SUFFIX_LOCK = '.lock';\nconst SUFFIX_COUNT = '.count';\nconst LOCKED = 'locked';\n\n/**\n * Lua scripts to be used as Redis operations.\n */\nexport const REDIS_LUA_SCRIPTS = {\n  acquireReadLock: `\n    -- Return 0 if an entry already exists.\n    local lockKey = KEYS[1]..\"${SUFFIX_WLOCK}\"\n    if redis.call(\"exists\", lockKey) == 1 then\n      return 0\n    end\n    \n    -- Return true if succeeded (and counter is incremented)\n    local countKey = KEYS[1]..\"${SUFFIX_COUNT}\"\n    return redis.call(\"incr\", countKey) > 0\n    `,\n  acquireWriteLock: `\n    -- Return 0 if a lock entry already exists or read count is > 0\n    local lockKey = KEYS[1]..\"${SUFFIX_WLOCK}\"\n    local countKey = KEYS[1]..\"${SUFFIX_COUNT}\"\n    local count = tonumber(redis.call(\"get\", countKey))\n    if ((redis.call(\"exists\", lockKey) == 1) or (count ~= nil and count > 0)) then\n      return 0\n    end\n    \n    -- Set lock and respond with 'OK' if succeeded (otherwise null)\n    return redis.call(\"set\", lockKey, \"${LOCKED}\");\n    `,\n  releaseReadLock: `\n      -- Return 1 after decreasing the counter, if counter is < 0 now: return '-ERR'\n      local countKey = KEYS[1]..\"${SUFFIX_COUNT}\"\n      local result = redis.call(\"decr\", countKey)\n      if result >= 0 then\n        return 1\n      else \n        return redis.error_reply(\"Error trying to release readlock when read count was 0.\")\n      end\n    `,\n  releaseWriteLock: `\n      -- Release the lock and reply with 1 if succeeded (otherwise return '-ERR')\n      local lockKey = KEYS[1]..\"${SUFFIX_WLOCK}\"\n      local result = redis.call(\"del\", lockKey)\n      if (result > 0) then\n        return 1\n      else\n        return redis.error_reply(\"Error trying to release writelock that did not exist.\")\n      end\n    `,\n  acquireLock: `\n      -- Return 0 if lock entry already exists, or 'OK' if it succeeds in setting the lock entry.\n      local key = KEYS[1]..\"${SUFFIX_LOCK}\"\n      if redis.call(\"exists\", key) == 1 then\n        return 0\n      end\n      \n      -- Return 'OK' if succeeded setting entry\n      return redis.call(\"set\", key, \"${LOCKED}\");\n      `,\n  releaseLock: `\n      -- Release the lock and reply with 1 if succeeded (otherwise return '-ERR')\n      local key = KEYS[1]..\"${SUFFIX_LOCK}\"\n      local result = redis.call(\"del\", key)\n      if result > 0 then\n        return 1\n      else\n        return redis.error_reply(\"Error trying to release lock that did not exist.\")\n      end\n    `,\n} as const;\n\nexport type RedisAnswer = 0 | 1 | null | 'OK' | string;\n\n/**\n * Convert a RESP2 response to a boolean.\n * @param result - The Promise-wrapped result of a RESP2 Redis function.\n * @returns * `1`, `'OK'`: return `true`\n *          * `0`: returns `false`\n *          * `-ERR`: throw error\n * @throws On `-ERR*` `null` or any other value\n */\nexport async function fromResp2ToBool(result: Promise<RedisAnswer>): Promise<boolean> {\n  const res = await result;\n  switch (res) {\n    case 1:\n    case 'OK':\n      return true;\n    case 0:\n      return false;\n    case null:\n      throw new Error('Redis operation error detected (value was null).');\n    default:\n      if (res.toString().startsWith('-ERR')) {\n        throw new InternalServerError(`Redis error: ${res.toString().slice(5)}`);\n      } else {\n        throw new InternalServerError(`Unexpected Redis answer received! (${res})`);\n      }\n  }\n}\n\nexport interface RedisReadWriteLock extends Redis {\n  /**\n   * Try to acquire a readLock on `resourceIdentifierPath`.\n   * Will succeed if there are no write locks.\n   *\n   * @returns 1 if succeeded. 0 if not possible.\n   */\n  acquireReadLock: (resourceIdentifierPath: string, callback?: Callback<string>) => Promise<RedisAnswer>;\n\n  /**\n   * Try to acquire a writeLock on `resourceIdentifierPath`.\n   * Only works if no other write lock is present and the read counter is 0.\n   *\n   * @returns 'OK' if succeeded, 0 if not possible.\n   */\n  acquireWriteLock: (resourceIdentifierPath: string, callback?: Callback<string>) => Promise<RedisAnswer>;\n\n  /**\n   * Release readLock. This means decrementing the read counter with 1.\n   * @returns 1 if succeeded. '-ERR' if read count goes below 0\n   */\n  releaseReadLock: (resourceIdentifierPath: string, callback?: Callback<string>) => Promise<RedisAnswer>;\n\n  /**\n   * Release writeLock. This means deleting the write lock.\n   * @returns 1 if succeeded. '-ERR' if write lock was non-existing.\n   */\n  releaseWriteLock: (resourceIdentifierPath: string, callback?: Callback<string>) => Promise<RedisAnswer>;\n}\n\nexport interface RedisResourceLock extends Redis {\n  /**\n   * Try to acquire a lock  on `resourceIdentifierPath`.\n   * Only works if no other lock is present.\n   *\n   * @returns 'OK' if succeeded, 0 if not possible.\n   */\n  acquireLock: (resourceIdentifierPath: string, callback?: Callback<string>) => Promise<RedisAnswer>;\n\n  /**\n   * Release lock. This means deleting the lock.\n   * @returns 1 if succeeded. '-ERR' if lock was non-existing.\n   */\n  releaseLock: (resourceIdentifierPath: string, callback?: Callback<string>) => Promise<RedisAnswer>;\n}\n"]}