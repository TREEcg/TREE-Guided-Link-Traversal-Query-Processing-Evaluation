{"version":3,"file":"VoidLocker.js","sourceRoot":"","sources":["../../../src/util/locking/VoidLocker.ts"],"names":[],"mappings":";;;AACA,mDAAqD;AAGrD;;;;GAIG;AAEH,gEAAgE;AAChE,SAAS,IAAI,KAAU,CAAC;AAExB,MAAa,UAAU;IAGrB;QAFmB,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAG7C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,qFAAqF,CAAC,CAAC;IAC1G,CAAC;IAEM,KAAK,CAAC,YAAY,CACvB,UAA8B,EAC9B,WAAyD;QAEzD,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAEM,KAAK,CAAC,aAAa,CACxB,UAA8B,EAC9B,WAAyD;QAEzD,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;CACF;AApBD,gCAoBC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { ExpiringReadWriteLocker } from './ExpiringReadWriteLocker';\n\n/**\n * This locker will execute the whileLocked function without any locking mechanism\n *\n * Do not use this locker in combination with storages that doesn't handle concurrent read/writes gracefully\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop(): void {}\n\nexport class VoidLocker implements ExpiringReadWriteLocker {\n  protected readonly logger = getLoggerFor(this);\n\n  public constructor() {\n    this.logger.warn('Locking mechanism disabled; data integrity during parallel requests not guaranteed.');\n  }\n\n  public async withReadLock<T>(\n    identifier: ResourceIdentifier,\n    whileLocked: (maintainLock: () => void) => T | Promise<T>,\n  ): Promise<T> {\n    return whileLocked(noop);\n  }\n\n  public async withWriteLock<T>(\n    identifier: ResourceIdentifier,\n    whileLocked: (maintainLock: () => void) => T | Promise<T>,\n  ): Promise<T> {\n    return whileLocked(noop);\n  }\n}\n"]}