{"version":3,"file":"MethodFilterHandler.js","sourceRoot":"","sources":["../../../src/util/handlers/MethodFilterHandler.ts"],"names":[],"mappings":";;;AAAA,+EAA4E;AAC5E,iDAA8C;AAK9C;;;;GAIG;AACH,MAAa,mBAA8C,SAAQ,2BAAuB;IAIxF,YAAmB,OAAiB,EAAE,MAA+B;QACnE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAU;QAC/B,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;YAClC,MAAM,IAAI,iDAAuB,CAC/B,mCAAmC,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAC7E,CAAC;SACH;QACD,MAAM,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACrC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAU;QAC5B,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,KAAa;QAC9B,IAAI,QAAQ,IAAI,KAAK,EAAE;YACrB,OAAO,KAAK,CAAC,MAAM,CAAC;SACrB;QACD,IAAI,SAAS,IAAI,KAAK,EAAE;YACtB,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;SACvC;QACD,IAAI,WAAW,IAAI,KAAK,EAAE;YACxB,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SACzC;QACD,MAAM,IAAI,iDAAuB,CAAC,wCAAwC,CAAC,CAAC;IAC9E,CAAC;CACF;AAvCD,kDAuCC","sourcesContent":["import { NotImplementedHttpError } from '../errors/NotImplementedHttpError';\nimport { AsyncHandler } from './AsyncHandler';\n\n// The formats from which we can detect the method\ntype InType = { method: string } | { request: { method: string }} | { operation: { method: string }};\n\n/**\n * Only accepts requests where the input has a (possibly nested) `method` field\n * that matches any one of the given methods.\n * In case of a match, the input will be sent to the source handler.\n */\nexport class MethodFilterHandler<TIn extends InType, TOut> extends AsyncHandler<TIn, TOut> {\n  private readonly methods: string[];\n  private readonly source: AsyncHandler<TIn, TOut>;\n\n  public constructor(methods: string[], source: AsyncHandler<TIn, TOut>) {\n    super();\n    this.methods = methods;\n    this.source = source;\n  }\n\n  public async canHandle(input: TIn): Promise<void> {\n    const method = this.findMethod(input);\n    if (!this.methods.includes(method)) {\n      throw new NotImplementedHttpError(\n        `Cannot determine permissions of ${method}, only ${this.methods.join(',')}.`,\n      );\n    }\n    await this.source.canHandle(input);\n  }\n\n  public async handle(input: TIn): Promise<TOut> {\n    return this.source.handle(input);\n  }\n\n  /**\n   * Finds the correct method in the input object.\n   */\n  private findMethod(input: InType): string {\n    if ('method' in input) {\n      return input.method;\n    }\n    if ('request' in input) {\n      return this.findMethod(input.request);\n    }\n    if ('operation' in input) {\n      return this.findMethod(input.operation);\n    }\n    throw new NotImplementedHttpError('Could not find method in input object.');\n  }\n}\n"]}