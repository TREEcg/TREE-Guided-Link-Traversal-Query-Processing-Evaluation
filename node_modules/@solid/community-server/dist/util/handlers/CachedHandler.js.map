{"version":3,"file":"CachedHandler.js","sourceRoot":"","sources":["../../../src/util/handlers/CachedHandler.ts"],"names":[],"mappings":";;;AAAA,iDAA8C;AAE9C;;;;;;;;;GASG;AACH,MAAa,aAAgC,SAAQ,2BAAuB;IAM1E,YAAmB,MAA+B,EAAE,KAAc;QAChE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,GAAG,IAAI,OAAO,EAAE,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAU;QAC/B,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAE/B,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACvB,OAAO;SACR;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAU;QAC5B,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAE/B,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,MAAM,EAAE;YACV,OAAO,MAAM,CAAC;SACf;QAED,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACzC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAE5B,OAAO,MAAM,CAAC;IAChB,CAAC;IAES,MAAM,CAAC,KAAU;QACzB,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAkB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IAC7D,CAAC;CACF;AAvCD,sCAuCC","sourcesContent":["import { AsyncHandler } from './AsyncHandler';\n\n/**\n * Caches output data from the source handler based on the input object.\n * The `field` parameter can be used to instead use a specific entry from the input object as cache key,\n * so has as actual required typing `keyof TIn`.\n *\n * A {@link WeakMap} is used internally so strict object equality determines cache hits,\n * and data will be removed once the key stops existing.\n * This also means that the cache key needs to be an object.\n * Errors will be thrown in case a primitve is used.\n */\nexport class CachedHandler<TIn, TOut = void> extends AsyncHandler<TIn, TOut> {\n  private readonly source: AsyncHandler<TIn, TOut>;\n  private readonly field?: string;\n\n  private readonly cache: WeakMap<any, TOut>;\n\n  public constructor(source: AsyncHandler<TIn, TOut>, field?: string) {\n    super();\n    this.source = source;\n    this.field = field;\n    this.cache = new WeakMap();\n  }\n\n  public async canHandle(input: TIn): Promise<void> {\n    const key = this.getKey(input);\n\n    if (this.cache.has(key)) {\n      return;\n    }\n    return this.source.canHandle(input);\n  }\n\n  public async handle(input: TIn): Promise<TOut> {\n    const key = this.getKey(input);\n\n    let result = this.cache.get(key);\n    if (result) {\n      return result;\n    }\n\n    result = await this.source.handle(input);\n    this.cache.set(key, result);\n\n    return result;\n  }\n\n  protected getKey(input: TIn): any {\n    return this.field ? input[this.field as keyof TIn] : input;\n  }\n}\n"]}