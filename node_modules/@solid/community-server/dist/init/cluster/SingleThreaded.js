"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listSingleThreadedComponents = exports.toComponentsJsType = void 0;
const componentsjs_1 = require("componentsjs");
const jsonld_context_parser_1 = require("jsonld-context-parser");
const InternalServerError_1 = require("../../util/errors/InternalServerError");
const PathUtil_1 = require("../../util/PathUtil");
/**
 * Convert an exported interface name to the properly expected Components.js type URI.
 * @param componentsManager - The currently used ComponentsManager
 * @param interfaceName - An interface name
 * @returns A Components.js type URI
 */
async function toComponentsJsType(componentsManager, interfaceName) {
    const pkg = await (0, PathUtil_1.readPackageJson)();
    const contextParser = new jsonld_context_parser_1.ContextParser({
        documentLoader: new componentsjs_1.PrefetchedDocumentLoader({ contexts: componentsManager.moduleState.contexts }),
        skipValidation: true,
    });
    // The keys of the package.json `lsd:contexts` array contains all the IRIs of the relevant contexts;
    const lsdContexts = Object.keys(pkg['lsd:contexts']);
    // Feed the lsd:context IRIs to the ContextParser
    const cssContext = await contextParser.parse(lsdContexts);
    // We can now expand a simple interface name, to its full Components.js type identifier.
    const interfaceIRI = cssContext.expandTerm(interfaceName, true);
    if (!interfaceIRI) {
        throw new InternalServerError_1.InternalServerError(`Could not expand ${interfaceName} to IRI!`);
    }
    return interfaceIRI;
}
exports.toComponentsJsType = toComponentsJsType;
/**
 * Will list class names of components instantiated implementing the {@link SingleThreaded}
 * interface while the application is being run in multithreaded mode.
 * @param componentsManager - The componentsManager being used to set up the application
 */
async function listSingleThreadedComponents(componentsManager) {
    const interfaceType = await toComponentsJsType(componentsManager, 'SingleThreaded');
    const violatingClasses = [];
    // Loop through all instantiated Resources
    for (const resource of componentsManager.getInstantiatedResources()) {
        // If implementing interfaceType, while not being the interfaceType itself.
        if (resource?.isA(interfaceType) && resource.value !== interfaceType) {
            // Part after the # in an IRI is the actual class name
            const name = resource.property?.type?.value?.split('#')?.[1];
            violatingClasses.push(name);
        }
    }
    return violatingClasses;
}
exports.listSingleThreadedComponents = listSingleThreadedComponents;
//# sourceMappingURL=SingleThreaded.js.map