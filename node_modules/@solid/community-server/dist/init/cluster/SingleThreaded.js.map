{"version":3,"file":"SingleThreaded.js","sourceRoot":"","sources":["../../../src/init/cluster/SingleThreaded.ts"],"names":[],"mappings":";;;AACA,+CAAwD;AACxD,iEAAsD;AACtD,+EAA4E;AAC5E,kDAAsD;AAOtD;;;;;GAKG;AACI,KAAK,UAAU,kBAAkB,CAAI,iBAAuC,EAAE,aAAqB;IAExG,MAAM,GAAG,GAAG,MAAM,IAAA,0BAAe,GAAE,CAAC;IACpC,MAAM,aAAa,GAAG,IAAI,qCAAa,CAAC;QACtC,cAAc,EAAE,IAAI,uCAAwB,CAAC,EAAE,QAAQ,EAAE,iBAAiB,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC;QAClG,cAAc,EAAE,IAAI;KACrB,CAAC,CAAC;IACH,oGAAoG;IACpG,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;IACrD,iDAAiD;IACjD,MAAM,UAAU,GAAG,MAAM,aAAa,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IAC1D,wFAAwF;IACxF,MAAM,YAAY,GAAG,UAAU,CAAC,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;IAEhE,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,yCAAmB,CAAC,oBAAoB,aAAa,UAAU,CAAC,CAAC;KAC5E;IACD,OAAO,YAAY,CAAC;AACtB,CAAC;AAlBD,gDAkBC;AAED;;;;GAIG;AACI,KAAK,UAAU,4BAA4B,CAAI,iBAAuC;IAC3F,MAAM,aAAa,GAAG,MAAM,kBAAkB,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,CAAC;IACpF,MAAM,gBAAgB,GAAa,EAAE,CAAC;IAEtC,0CAA0C;IAC1C,KAAK,MAAM,QAAQ,IAAI,iBAAiB,CAAC,wBAAwB,EAAE,EAAE;QACnE,2EAA2E;QAC3E,IAAI,QAAQ,EAAE,GAAG,CAAC,aAAa,CAAC,IAAI,QAAQ,CAAC,KAAK,KAAK,aAAa,EAAE;YACpE,sDAAsD;YACtD,MAAM,IAAI,GAAG,QAAQ,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC7D,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC7B;KACF;IACD,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAdD,oEAcC","sourcesContent":["import type { ComponentsManager } from 'componentsjs';\nimport { PrefetchedDocumentLoader } from 'componentsjs';\nimport { ContextParser } from 'jsonld-context-parser';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { readPackageJson } from '../../util/PathUtil';\n\n/**\n * Indicates a class is only meant to work in singlethreaded setups and is thus not threadsafe.\n */\nexport interface SingleThreaded {}\n\n/**\n * Convert an exported interface name to the properly expected Components.js type URI.\n * @param componentsManager - The currently used ComponentsManager\n * @param interfaceName - An interface name\n * @returns A Components.js type URI\n */\nexport async function toComponentsJsType<T>(componentsManager: ComponentsManager<T>, interfaceName: string):\nPromise<string> {\n  const pkg = await readPackageJson();\n  const contextParser = new ContextParser({\n    documentLoader: new PrefetchedDocumentLoader({ contexts: componentsManager.moduleState.contexts }),\n    skipValidation: true,\n  });\n  // The keys of the package.json `lsd:contexts` array contains all the IRIs of the relevant contexts;\n  const lsdContexts = Object.keys(pkg['lsd:contexts']);\n  // Feed the lsd:context IRIs to the ContextParser\n  const cssContext = await contextParser.parse(lsdContexts);\n  // We can now expand a simple interface name, to its full Components.js type identifier.\n  const interfaceIRI = cssContext.expandTerm(interfaceName, true);\n\n  if (!interfaceIRI) {\n    throw new InternalServerError(`Could not expand ${interfaceName} to IRI!`);\n  }\n  return interfaceIRI;\n}\n\n/**\n * Will list class names of components instantiated implementing the {@link SingleThreaded}\n * interface while the application is being run in multithreaded mode.\n * @param componentsManager - The componentsManager being used to set up the application\n */\nexport async function listSingleThreadedComponents<T>(componentsManager: ComponentsManager<T>): Promise<string[]> {\n  const interfaceType = await toComponentsJsType(componentsManager, 'SingleThreaded');\n  const violatingClasses: string[] = [];\n\n  // Loop through all instantiated Resources\n  for (const resource of componentsManager.getInstantiatedResources()) {\n    // If implementing interfaceType, while not being the interfaceType itself.\n    if (resource?.isA(interfaceType) && resource.value !== interfaceType) {\n      // Part after the # in an IRI is the actual class name\n      const name = resource.property?.type?.value?.split('#')?.[1];\n      violatingClasses.push(name);\n    }\n  }\n  return violatingClasses;\n}\n"]}