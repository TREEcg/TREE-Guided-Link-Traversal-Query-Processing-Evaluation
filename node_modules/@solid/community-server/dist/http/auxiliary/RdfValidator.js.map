{"version":3,"file":"RdfValidator.js","sourceRoot":"","sources":["../../../src/http/auxiliary/RdfValidator.ts"],"names":[],"mappings":";;;;;;AAAA,sEAA6C;AAE7C,0DAAyD;AACzD,0DAA8D;AAG9D,2CAAwC;AAExC;;;GAGG;AACH,MAAa,YAAa,SAAQ,qBAAS;IAGzC,YAAmB,SAAkC;QACnD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,UAAU,EAAkB;QAChE,uDAAuD;QACvD,IAAI,cAAc,CAAC,QAAQ,CAAC,WAAW,KAAK,6BAAc,EAAE;YAC1D,OAAO,cAAc,CAAC;SACvB;QACD,MAAM,WAAW,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,6BAAc,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC;QACrD,IAAI,MAAM,CAAC;QACX,IAAI;YACF,kEAAkE;YAClE,MAAM,kBAAkB,GAAG,MAAM,IAAA,kCAAmB,EAAC,cAAc,CAAC,CAAC;YACrE,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;gBACvC,UAAU;gBACV,cAAc,EAAE,kBAAkB;gBAClC,WAAW;aACZ,CAAC,CAAC;SACJ;QAAC,OAAO,KAAc,EAAE;YACvB,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YAC9B,MAAM,KAAK,CAAC;SACb;QACD,sDAAsD;QACtD,MAAM,IAAA,yBAAc,EAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAElC,OAAO,cAAc,CAAC;IACxB,CAAC;CACF;AAhCD,oCAgCC","sourcesContent":["import arrayifyStream from 'arrayify-stream';\nimport type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';\nimport { INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { cloneRepresentation } from '../../util/ResourceUtil';\nimport type { Representation } from '../representation/Representation';\nimport type { ValidatorInput } from './Validator';\nimport { Validator } from './Validator';\n\n/**\n * Validates a Representation by verifying if the data stream contains valid RDF data.\n * It does this by letting the stored RepresentationConverter convert the data.\n */\nexport class RdfValidator extends Validator {\n  protected readonly converter: RepresentationConverter;\n\n  public constructor(converter: RepresentationConverter) {\n    super();\n    this.converter = converter;\n  }\n\n  public async handle({ representation, identifier }: ValidatorInput): Promise<Representation> {\n    // If the data already is quads format we know it's RDF\n    if (representation.metadata.contentType === INTERNAL_QUADS) {\n      return representation;\n    }\n    const preferences = { type: { [INTERNAL_QUADS]: 1 }};\n    let result;\n    try {\n      // Creating new representation since converter might edit metadata\n      const tempRepresentation = await cloneRepresentation(representation);\n      result = await this.converter.handleSafe({\n        identifier,\n        representation: tempRepresentation,\n        preferences,\n      });\n    } catch (error: unknown) {\n      representation.data.destroy();\n      throw error;\n    }\n    // Drain stream to make sure data was parsed correctly\n    await arrayifyStream(result.data);\n\n    return representation;\n  }\n}\n"]}