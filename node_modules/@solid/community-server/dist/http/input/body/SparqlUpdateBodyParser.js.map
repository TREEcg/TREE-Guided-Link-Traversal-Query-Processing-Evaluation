{"version":3,"file":"SparqlUpdateBodyParser.js","sourceRoot":"","sources":["../../../../src/http/input/body/SparqlUpdateBodyParser.ts"],"names":[],"mappings":";;;AACA,qDAA4C;AAC5C,sDAAwD;AACxD,6DAAuE;AACvE,kFAA+E;AAC/E,8DAAoE;AACpE,sGAAmG;AACnG,yDAA+E;AAG/E,6CAA0C;AAC1C;;;GAGG;AACH,MAAa,sBAAuB,SAAQ,uBAAU;IAAtD;;QACqB,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IA4BjD,CAAC;IA1BQ,KAAK,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAkB;QACjD,IAAI,QAAQ,CAAC,WAAW,KAAK,wCAAyB,EAAE;YACtD,MAAM,IAAI,6DAA6B,CAAC,+CAA+C,CAAC,CAAC;SAC1F;IACH,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAkB;QACvD,MAAM,MAAM,GAAG,MAAM,IAAA,6BAAgB,EAAC,OAAO,CAAC,CAAC;QAC/C,IAAI,OAA0B,CAAC;QAC/B,IAAI;YACF,OAAO,GAAG,IAAA,2BAAS,EAAC,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAmB,CAAC;SACpG;QAAC,OAAO,KAAc,EAAE;YACvB,MAAM,OAAO,GAAG,IAAA,8BAAkB,EAAC,KAAK,CAAC,CAAC;YAC1C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,uDAAuD,OAAO,EAAE,CAAC,CAAC;YACnF,MAAM,IAAI,yCAAmB,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;SAC1D;QAED,0CAA0C;QAC1C,OAAO;YACL,OAAO;YACP,MAAM,EAAE,IAAI;YACZ,IAAI,EAAE,IAAA,8BAAiB,EAAC,MAAM,CAAC;YAC/B,QAAQ;YACR,OAAO,EAAE,KAAK;SACf,CAAC;IACJ,CAAC;CACF;AA7BD,wDA6BC","sourcesContent":["import type { Algebra } from 'sparqlalgebrajs';\nimport { translate } from 'sparqlalgebrajs';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport { APPLICATION_SPARQL_UPDATE } from '../../../util/ContentTypes';\nimport { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport { UnsupportedMediaTypeHttpError } from '../../../util/errors/UnsupportedMediaTypeHttpError';\nimport { guardedStreamFrom, readableToString } from '../../../util/StreamUtil';\nimport type { SparqlUpdatePatch } from '../../representation/SparqlUpdatePatch';\nimport type { BodyParserArgs } from './BodyParser';\nimport { BodyParser } from './BodyParser';\n/**\n * {@link BodyParser} that supports `application/sparql-update` content.\n * Will convert the incoming update string to algebra in a {@link SparqlUpdatePatch}.\n */\nexport class SparqlUpdateBodyParser extends BodyParser {\n  protected readonly logger = getLoggerFor(this);\n\n  public async canHandle({ metadata }: BodyParserArgs): Promise<void> {\n    if (metadata.contentType !== APPLICATION_SPARQL_UPDATE) {\n      throw new UnsupportedMediaTypeHttpError('This parser only supports SPARQL UPDATE data.');\n    }\n  }\n\n  public async handle({ request, metadata }: BodyParserArgs): Promise<SparqlUpdatePatch> {\n    const sparql = await readableToString(request);\n    let algebra: Algebra.Operation;\n    try {\n      algebra = translate(sparql, { quads: true, baseIRI: metadata.identifier.value }) as Algebra.Update;\n    } catch (error: unknown) {\n      const message = createErrorMessage(error);\n      this.logger.warn(`Could not translate SPARQL query to SPARQL algebra: ${message}`);\n      throw new BadRequestHttpError(message, { cause: error });\n    }\n\n    // Prevent body from being requested again\n    return {\n      algebra,\n      binary: true,\n      data: guardedStreamFrom(sparql),\n      metadata,\n      isEmpty: false,\n    };\n  }\n}\n"]}