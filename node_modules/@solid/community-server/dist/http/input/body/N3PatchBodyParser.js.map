{"version":3,"file":"N3PatchBodyParser.js","sourceRoot":"","sources":["../../../../src/http/input/body/N3PatchBodyParser.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NamedNode, Quad, Quad_Subject, Variable } from '@rdfjs/types';\nimport { DataFactory, Parser, Store } from 'n3';\nimport { getBlankNodes, getTerms, getVariables } from 'rdf-terms';\nimport { TEXT_N3 } from '../../../util/ContentTypes';\nimport { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport { UnprocessableEntityHttpError } from '../../../util/errors/UnprocessableEntityHttpError';\nimport { UnsupportedMediaTypeHttpError } from '../../../util/errors/UnsupportedMediaTypeHttpError';\nimport { guardedStreamFrom, readableToString } from '../../../util/StreamUtil';\nimport { RDF, SOLID } from '../../../util/Vocabularies';\nimport type { N3Patch } from '../../representation/N3Patch';\nimport type { BodyParserArgs } from './BodyParser';\nimport { BodyParser } from './BodyParser';\n\nconst defaultGraph = DataFactory.defaultGraph();\n\n/**\n * Parses an N3 Patch document and makes sure it conforms to the specification requirements.\n * Requirements can be found at Solid Protocol, §5.3.1: https://solid.github.io/specification/protocol#n3-patch\n */\nexport class N3PatchBodyParser extends BodyParser {\n  public async canHandle({ metadata }: BodyParserArgs): Promise<void> {\n    if (metadata.contentType !== TEXT_N3) {\n      throw new UnsupportedMediaTypeHttpError('This parser only supports N3 Patch documents.');\n    }\n  }\n\n  public async handle({ request, metadata }: BodyParserArgs): Promise<N3Patch> {\n    const n3 = await readableToString(request);\n    const parser = new Parser({ format: TEXT_N3, baseIRI: metadata.identifier.value });\n    let store: Store;\n    try {\n      store = new Store(parser.parse(n3));\n    } catch (error: unknown) {\n      throw new BadRequestHttpError(`Invalid N3: ${createErrorMessage(error)}`);\n    }\n\n    // Solid, §5.3.1: \"A patch resource MUST contain a triple ?patch rdf:type solid:InsertDeletePatch.\"\n    // \"The patch document MUST contain exactly one patch resource,\n    // identified by one or more of the triple patterns described above, which all share the same ?patch subject.\"\n    const patches = store.getSubjects(RDF.terms.type, SOLID.terms.InsertDeletePatch, defaultGraph);\n    if (patches.length !== 1) {\n      throw new UnprocessableEntityHttpError(\n        `This patcher only supports N3 Patch documents with exactly 1 solid:InsertDeletePatch entry, but received ${\n          patches.length}.`,\n      );\n    }\n    return {\n      ...this.parsePatch(patches[0], store),\n      binary: true,\n      data: guardedStreamFrom(n3),\n      metadata,\n      isEmpty: false,\n    };\n  }\n\n  /**\n   * Extracts the deletes/inserts/conditions from a solid:InsertDeletePatch entry.\n   */\n  private parsePatch(patch: Quad_Subject, store: Store): { deletes: Quad[]; inserts: Quad[]; conditions: Quad[] } {\n    // Solid, §5.3.1: \"A patch resource MUST be identified by a URI or blank node, which we refer to as ?patch\n    // in the remainder of this section.\"\n    if (patch.termType !== 'NamedNode' && patch.termType !== 'BlankNode') {\n      throw new UnprocessableEntityHttpError('An N3 Patch subject needs to be a blank or named node.');\n    }\n\n    // Extract all quads from the corresponding formulae\n    const deletes = this.findQuads(store, patch, SOLID.terms.deletes);\n    const inserts = this.findQuads(store, patch, SOLID.terms.inserts);\n    const conditions = this.findQuads(store, patch, SOLID.terms.where);\n\n    // Make sure there are no forbidden combinations\n    const conditionVars = this.findVariables(conditions);\n    this.verifyQuads(deletes, conditionVars);\n    this.verifyQuads(inserts, conditionVars);\n\n    return { deletes, inserts, conditions };\n  }\n\n  /**\n   * Finds all quads in a where/deletes/inserts formula.\n   * The returned quads will be updated so their graph is the default graph instead of the N3 reference to the formula.\n   * Will error in case there are multiple instances of the subject/predicate combination.\n   */\n  private findQuads(store: Store, subject: Quad_Subject, predicate: NamedNode): Quad[] {\n    const graphs = store.getObjects(subject, predicate, defaultGraph);\n    if (graphs.length > 1) {\n      throw new UnprocessableEntityHttpError(`An N3 Patch can have at most 1 ${predicate.value}.`);\n    }\n    if (graphs.length === 0) {\n      return [];\n    }\n    // This might not return all quads in case of nested formulae,\n    // but these are not allowed and will throw an error later when checking for blank nodes.\n    // Another check would be needed in case blank nodes are allowed in the future.\n    const quads: Quad[] = store.getQuads(null, null, null, graphs[0]);\n\n    // Remove the graph references so they can be interpreted as standard triples\n    // independent of the formula they were in.\n    return quads.map((quad): Quad => DataFactory.quad(quad.subject, quad.predicate, quad.object, defaultGraph));\n  }\n\n  /**\n   * Finds all variables in a set of quads.\n   */\n  private findVariables(quads: Quad[]): Set<string> {\n    return new Set(\n      quads.flatMap((quad): Variable[] => getVariables(getTerms(quad)))\n        .map((variable): string => variable.value),\n    );\n  }\n\n  /**\n   * Verifies if the delete/insert triples conform to the specification requirements:\n   *  - They should not contain blank nodes.\n   *  - They should not contain variables that do not occur in the conditions.\n   */\n  private verifyQuads(otherQuads: Quad[], conditionVars: Set<string>): void {\n    for (const quad of otherQuads) {\n      const terms = getTerms(quad);\n      const blankNodes = getBlankNodes(terms);\n      // Solid, §5.3.1: \"The ?insertions and ?deletions formulae MUST NOT contain blank nodes.\"\n      if (blankNodes.length > 0) {\n        throw new UnprocessableEntityHttpError(`An N3 Patch delete/insert formula can not contain blank nodes.`);\n      }\n      const variables = getVariables(terms);\n      for (const variable of variables) {\n        // Solid, §5.3.1: \"The ?insertions and ?deletions formulae\n        // MUST NOT contain variables that do not occur in the ?conditions formula.\"\n        if (!conditionVars.has(variable.value)) {\n          throw new UnprocessableEntityHttpError(\n            `An N3 Patch delete/insert formula can only contain variables found in the conditions formula.`,\n          );\n        }\n      }\n    }\n  }\n}\n"]}