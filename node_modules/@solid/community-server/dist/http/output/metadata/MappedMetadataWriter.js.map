{"version":3,"file":"MappedMetadataWriter.js","sourceRoot":"","sources":["../../../../src/http/output/metadata/MappedMetadataWriter.ts"],"names":[],"mappings":";;;AACA,2BAAiC;AAEjC,yDAAqD;AAErD,qDAAkD;AAElD;;;GAGG;AACH,MAAa,oBAAqB,SAAQ,+BAAc;IAGtD,YAAmB,SAAiC;QAClD,KAAK,EAAE,CAAC;QAER,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAqB,CAAC;QAC9C,KAAK,MAAM,CAAE,GAAG,EAAE,KAAK,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;YACtD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,gBAAW,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;SACvD;IACH,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAmE;QACrF,KAAK,MAAM,CAAE,SAAS,EAAE,MAAM,CAAE,IAAI,IAAI,CAAC,SAAS,EAAE;YAClD,MAAM,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YAC/C,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBACpB,IAAA,sBAAS,EAAC,KAAK,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAU,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;aAC5E;SACF;IACH,CAAC;CACF;AApBD,oDAoBC","sourcesContent":["import type { NamedNode } from 'n3';\nimport { DataFactory } from 'n3';\nimport type { HttpResponse } from '../../../server/HttpResponse';\nimport { addHeader } from '../../../util/HeaderUtil';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataWriter } from './MetadataWriter';\n\n/**\n * A {@link MetadataWriter} that takes a map directly converting metadata predicates to headers.\n * The header value(s) will be the same as the corresponding object value(s).\n */\nexport class MappedMetadataWriter extends MetadataWriter {\n  private readonly headerMap: Map<NamedNode, string>;\n\n  public constructor(headerMap: Record<string, string>) {\n    super();\n\n    this.headerMap = new Map<NamedNode, string>();\n    for (const [ key, value ] of Object.entries(headerMap)) {\n      this.headerMap.set(DataFactory.namedNode(key), value);\n    }\n  }\n\n  public async handle(input: { response: HttpResponse; metadata: RepresentationMetadata }): Promise<void> {\n    for (const [ predicate, header ] of this.headerMap) {\n      const terms = input.metadata.getAll(predicate);\n      if (terms.length > 0) {\n        addHeader(input.response, header, terms.map((term): string => term.value));\n      }\n    }\n  }\n}\n"]}