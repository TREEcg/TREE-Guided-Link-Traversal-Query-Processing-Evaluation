{"version":3,"file":"AllowAcceptHeaderWriter.js","sourceRoot":"","sources":["../../../../src/http/output/metadata/AllowAcceptHeaderWriter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { HttpResponse } from '../../../server/HttpResponse';\nimport { MethodNotAllowedHttpError } from '../../../util/errors/MethodNotAllowedHttpError';\nimport { NotFoundHttpError } from '../../../util/errors/NotFoundHttpError';\nimport { UnsupportedMediaTypeHttpError } from '../../../util/errors/UnsupportedMediaTypeHttpError';\nimport { addHeader } from '../../../util/HeaderUtil';\nimport { isContainerPath } from '../../../util/PathUtil';\nimport { LDP, PIM, RDF, SOLID_ERROR } from '../../../util/Vocabularies';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataWriter } from './MetadataWriter';\n\n// Only PUT and PATCH can be used to create a new resource\nconst NEW_RESOURCE_ALLOWED_METHODS = new Set([ 'PUT', 'PATCH' ]);\n\n/**\n * Generates Allow, Accept-Patch, Accept-Post, and Accept-Put headers.\n * The resulting values depend on the choses input methods and types.\n * The input metadata also gets used to remove methods from that list\n * if they are not valid in the given situation.\n */\nexport class AllowAcceptHeaderWriter extends MetadataWriter {\n  private readonly supportedMethods: string[];\n  private readonly acceptTypes: { patch: string[]; post: string[]; put: string[] };\n\n  public constructor(supportedMethods: string[], acceptTypes: { patch?: string[]; post?: string[]; put?: string[] }) {\n    super();\n    this.supportedMethods = supportedMethods;\n    this.acceptTypes = { patch: [], post: [], put: [], ...acceptTypes };\n  }\n\n  public async handle(input: { response: HttpResponse; metadata: RepresentationMetadata }): Promise<void> {\n    const { response, metadata } = input;\n\n    // Filter out methods which are not allowed\n    const allowedMethods = this.filterAllowedMethods(metadata);\n\n    // Generate the Allow headers (if required)\n    const generateAllow = this.generateAllow(allowedMethods, response, metadata);\n\n    // Generate Accept-[Method] headers (if required)\n    this.generateAccept(allowedMethods, generateAllow, response, metadata);\n  }\n\n  /**\n   * Starts from the stored set of methods and removes all those that are not allowed based on the metadata.\n   */\n  private filterAllowedMethods(metadata: RepresentationMetadata): Set<string> {\n    const disallowedMethods = new Set(metadata.getAll(SOLID_ERROR.terms.disallowedMethod)\n      .map((term): string => term.value));\n    const allowedMethods = new Set(this.supportedMethods.filter((method): boolean => !disallowedMethods.has(method)));\n\n    // POST is only allowed on containers.\n    // Metadata only has the resource URI in case it has resource metadata.\n    if (this.isPostAllowed(metadata)) {\n      allowedMethods.delete('POST');\n    }\n\n    if (!this.isDeleteAllowed(metadata)) {\n      allowedMethods.delete('DELETE');\n    }\n\n    // If we are sure the resource does not exist: only keep methods that can create a new resource.\n    if (metadata.has(SOLID_ERROR.terms.errorResponse, NotFoundHttpError.uri)) {\n      for (const method of allowedMethods) {\n        if (!NEW_RESOURCE_ALLOWED_METHODS.has(method)) {\n          allowedMethods.delete(method);\n        }\n      }\n    }\n\n    return allowedMethods;\n  }\n\n  /**\n   * POST is only allowed on containers.\n   * The metadata URI is only valid in case there is resource metadata,\n   * otherwise it is just a blank node.\n   */\n  private isPostAllowed(metadata: RepresentationMetadata): boolean {\n    return metadata.has(RDF.terms.type, LDP.terms.Resource) && !isContainerPath(metadata.identifier.value);\n  }\n\n  /**\n   * DELETE is allowed if the target exists,\n   * is not a container,\n   * or is an empty container that isn't a storage.\n   *\n   * Note that the identifier value check only works if the metadata is not about an error.\n   */\n  private isDeleteAllowed(metadata: RepresentationMetadata): boolean {\n    if (!isContainerPath(metadata.identifier.value)) {\n      return true;\n    }\n\n    const isStorage = metadata.has(RDF.terms.type, PIM.terms.Storage);\n    const isEmpty = metadata.has(LDP.terms.contains);\n    return !isStorage && !isEmpty;\n  }\n\n  /**\n   * Generates the Allow header if required.\n   * It only needs to get added for successful GET/HEAD requests, 404s, or 405s.\n   * The spec only requires it for GET/HEAD requests and 405s.\n   * In the case of other error messages we can't deduce what the request method was,\n   * so we do not add the header as we don't have enough information.\n   */\n  private generateAllow(methods: Set<string>, response: HttpResponse, metadata: RepresentationMetadata): boolean {\n    const methodDisallowed = metadata.has(SOLID_ERROR.terms.errorResponse, MethodNotAllowedHttpError.uri);\n    // 405s indicate the target resource exists.\n    // This is a heuristic, but one that should always be correct in our case.\n    const resourceExists = methodDisallowed || metadata.has(RDF.terms.type, LDP.terms.Resource);\n    const generateAllow = resourceExists || metadata.has(SOLID_ERROR.terms.errorResponse, NotFoundHttpError.uri);\n    if (generateAllow) {\n      addHeader(response, 'Allow', [ ...methods ].join(', '));\n    }\n    return generateAllow;\n  }\n\n  /**\n   * Generates the Accept-[Method] headers if required.\n   * Will be added if the Allow header was added, or in case of a 415 error.\n   * Specific Accept-[Method] headers will only be added if the method is in the `methods` set.\n   */\n  private generateAccept(methods: Set<string>, generateAllow: boolean, response: HttpResponse,\n    metadata: RepresentationMetadata): void {\n    const typeWasUnsupported = metadata.has(SOLID_ERROR.terms.errorResponse, UnsupportedMediaTypeHttpError.uri);\n    const generateAccept = generateAllow || typeWasUnsupported;\n    if (generateAccept) {\n      if (methods.has('PATCH')) {\n        addHeader(response, 'Accept-Patch', this.acceptTypes.patch.join(', '));\n      }\n      if (methods.has('POST')) {\n        addHeader(response, 'Accept-Post', this.acceptTypes.post.join(', '));\n      }\n      if (methods.has('PUT')) {\n        addHeader(response, 'Accept-Put', this.acceptTypes.put.join(', '));\n      }\n    }\n  }\n}\n"]}