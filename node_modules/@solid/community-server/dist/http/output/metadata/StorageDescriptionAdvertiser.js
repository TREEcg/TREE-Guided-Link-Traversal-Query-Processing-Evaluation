"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageDescriptionAdvertiser = void 0;
const LogUtil_1 = require("../../../logging/LogUtil");
const ErrorUtil_1 = require("../../../util/errors/ErrorUtil");
const HeaderUtil_1 = require("../../../util/HeaderUtil");
const PathUtil_1 = require("../../../util/PathUtil");
const Vocabularies_1 = require("../../../util/Vocabularies");
const MetadataWriter_1 = require("./MetadataWriter");
/**
 * Adds a link header pointing to the relevant storage description resource.
 * Recursively checks parent containers until a storage container is found,
 * and then appends the provided suffix to determine the storage description resource.
 */
class StorageDescriptionAdvertiser extends MetadataWriter_1.MetadataWriter {
    constructor(targetExtractor, identifierStrategy, store, suffix) {
        super();
        this.logger = (0, LogUtil_1.getLoggerFor)(this);
        this.identifierStrategy = identifierStrategy;
        this.targetExtractor = targetExtractor;
        this.store = store;
        this.suffix = suffix;
    }
    async handle({ response, metadata }) {
        // This indicates this is the response of a successful GET/HEAD request
        if (!metadata.has(Vocabularies_1.RDF.terms.type, Vocabularies_1.LDP.terms.Resource)) {
            return;
        }
        const identifier = { path: metadata.identifier.value };
        let storageRoot;
        try {
            storageRoot = await this.findStorageRoot(identifier);
        }
        catch (error) {
            this.logger.error(`Unable to find storage root: ${(0, ErrorUtil_1.createErrorMessage)(error)}`);
            return;
        }
        const storageDescription = (0, PathUtil_1.joinUrl)(storageRoot.path, this.suffix);
        (0, HeaderUtil_1.addHeader)(response, 'Link', `<${storageDescription}>; rel="${Vocabularies_1.SOLID.storageDescription}"`);
    }
    async findStorageRoot(identifier) {
        const representation = await this.store.getRepresentation(identifier, {});
        // We only need the metadata
        representation.data.destroy();
        if (representation.metadata.has(Vocabularies_1.RDF.terms.type, Vocabularies_1.PIM.terms.Storage)) {
            return identifier;
        }
        return this.findStorageRoot(this.identifierStrategy.getParentContainer(identifier));
    }
}
exports.StorageDescriptionAdvertiser = StorageDescriptionAdvertiser;
//# sourceMappingURL=StorageDescriptionAdvertiser.js.map