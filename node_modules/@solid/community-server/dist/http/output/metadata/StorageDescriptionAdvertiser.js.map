{"version":3,"file":"StorageDescriptionAdvertiser.js","sourceRoot":"","sources":["../../../../src/http/output/metadata/StorageDescriptionAdvertiser.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AAExD,8DAAoE;AACpE,yDAAqD;AAErD,qDAAiD;AACjD,6DAAkE;AAIlE,qDAAkD;AAElD;;;;GAIG;AACH,MAAa,4BAA6B,SAAQ,+BAAc;IAQ9D,YAAmB,eAAgC,EAAE,kBAAsC,EAAE,KAAoB,EAC/G,MAAc;QACd,KAAK,EAAE,CAAC;QATS,WAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;QAU7C,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAuB;QAC7D,uEAAuE;QACvE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,kBAAG,CAAC,KAAK,CAAC,IAAI,EAAE,kBAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE;YACrD,OAAO;SACR;QACD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACvD,IAAI,WAA+B,CAAC;QACpC,IAAI;YACF,WAAW,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;SACtD;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,gCAAgC,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC/E,OAAO;SACR;QACD,MAAM,kBAAkB,GAAG,IAAA,kBAAO,EAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAClE,IAAA,sBAAS,EAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,kBAAkB,WAAW,oBAAK,CAAC,kBAAkB,GAAG,CAAC,CAAC;IAC5F,CAAC;IAEO,KAAK,CAAC,eAAe,CAAC,UAA8B;QAC1D,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QAC1E,4BAA4B;QAC5B,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;QAC9B,IAAI,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,kBAAG,CAAC,KAAK,CAAC,IAAI,EAAE,kBAAG,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;YAClE,OAAO,UAAU,CAAC;SACnB;QACD,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC;IACtF,CAAC;CACF;AA3CD,oEA2CC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport type { ResourceStore } from '../../../storage/ResourceStore';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport { addHeader } from '../../../util/HeaderUtil';\nimport type { IdentifierStrategy } from '../../../util/identifiers/IdentifierStrategy';\nimport { joinUrl } from '../../../util/PathUtil';\nimport { LDP, PIM, RDF, SOLID } from '../../../util/Vocabularies';\nimport type { TargetExtractor } from '../../input/identifier/TargetExtractor';\nimport type { ResourceIdentifier } from '../../representation/ResourceIdentifier';\nimport type { MetadataWriterInput } from './MetadataWriter';\nimport { MetadataWriter } from './MetadataWriter';\n\n/**\n * Adds a link header pointing to the relevant storage description resource.\n * Recursively checks parent containers until a storage container is found,\n * and then appends the provided suffix to determine the storage description resource.\n */\nexport class StorageDescriptionAdvertiser extends MetadataWriter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly targetExtractor: TargetExtractor;\n  private readonly identifierStrategy: IdentifierStrategy;\n  private readonly store: ResourceStore;\n  private readonly suffix: string;\n\n  public constructor(targetExtractor: TargetExtractor, identifierStrategy: IdentifierStrategy, store: ResourceStore,\n    suffix: string) {\n    super();\n    this.identifierStrategy = identifierStrategy;\n    this.targetExtractor = targetExtractor;\n    this.store = store;\n    this.suffix = suffix;\n  }\n\n  public async handle({ response, metadata }: MetadataWriterInput): Promise<void> {\n    // This indicates this is the response of a successful GET/HEAD request\n    if (!metadata.has(RDF.terms.type, LDP.terms.Resource)) {\n      return;\n    }\n    const identifier = { path: metadata.identifier.value };\n    let storageRoot: ResourceIdentifier;\n    try {\n      storageRoot = await this.findStorageRoot(identifier);\n    } catch (error: unknown) {\n      this.logger.error(`Unable to find storage root: ${createErrorMessage(error)}`);\n      return;\n    }\n    const storageDescription = joinUrl(storageRoot.path, this.suffix);\n    addHeader(response, 'Link', `<${storageDescription}>; rel=\"${SOLID.storageDescription}\"`);\n  }\n\n  private async findStorageRoot(identifier: ResourceIdentifier): Promise<ResourceIdentifier> {\n    const representation = await this.store.getRepresentation(identifier, {});\n    // We only need the metadata\n    representation.data.destroy();\n    if (representation.metadata.has(RDF.terms.type, PIM.terms.Storage)) {\n      return identifier;\n    }\n    return this.findStorageRoot(this.identifierStrategy.getParentContainer(identifier));\n  }\n}\n"]}