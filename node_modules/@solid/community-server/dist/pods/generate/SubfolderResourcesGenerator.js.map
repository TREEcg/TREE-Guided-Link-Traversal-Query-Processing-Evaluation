{"version":3,"file":"SubfolderResourcesGenerator.js","sourceRoot":"","sources":["../../../src/pods/generate/SubfolderResourcesGenerator.ts"],"names":[],"mappings":";;;AACA,0DAA2D;AAC3D,kDAAqE;AAKrE,6CAA6C;AAC7C,SAAS,UAAU,CAAC,IAAc,EAAE,KAAe;IACjD,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AACnE,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAa,2BAA2B;IAItC,YAAmB,kBAA+C,EAAE,UAAoB;QACtF,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAA,CAAE,QAAQ,CAAC,cAAsB,EAAE,QAA4B,EAAE,OAAqB;QAEhG,MAAM,IAAI,GAAG,IAAA,2BAAgB,EAAC,cAAc,CAAC,CAAC;QAC9C,MAAM,kBAAkB,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,SAAS,EAAU,EAAE,CAAC,IAAA,uBAAY,EAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;QAErG,uBAAuB;QACvB,MAAM,UAAU,GAA8B,EAAE,CAAC;QACjD,KAAK,MAAM,iBAAiB,IAAI,kBAAkB,EAAE;YAClD,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,iBAAiB,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;SACjH;QAED,IAAI,QAAQ,GAAuB,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;QAChD,IAAI,KAAK,EAAE,MAAM,MAAM,IAAI,IAAA,+BAAgB,EAAC,UAAU,EAAE,UAAU,CAAC,EAAE;YACnE,0BAA0B;YAC1B,oEAAoE;YACpE,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,EAAE;gBAC5C,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;aACtC;iBAAM;gBACL,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC;gBAC7B,MAAM,MAAM,CAAC;aACd;SACF;IACH,CAAC;CACF;AAhCD,kEAgCC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { sortedAsyncMerge } from '../../util/IterableUtil';\nimport { joinFilePath, resolveAssetPath } from '../../util/PathUtil';\nimport type { Resource } from './ResourcesGenerator';\nimport type { TemplatedResourcesGenerator } from './TemplatedResourcesGenerator';\nimport Dict = NodeJS.Dict;\n\n// Sorts Resources based on their identifiers\nfunction comparator(left: Resource, right: Resource): number {\n  return left.identifier.path.localeCompare(right.identifier.path);\n}\n\n/**\n * Generates all resources found in specific subfolders of the given template folder.\n * In case the same resource is defined in several subfolders,\n * the data of the last subfolder in the list will be used.\n *\n * The results of all the subfolders will be merged so the end result is still a sorted stream of identifiers.\n *\n * One of the main use cases for this class is so template resources can be in a separate folder\n * than their corresponding authorization resources,\n * allowing for authorization-independent templates.\n */\nexport class SubfolderResourcesGenerator implements TemplatedResourcesGenerator {\n  private readonly resourcesGenerator: TemplatedResourcesGenerator;\n  private readonly subfolders: string[];\n\n  public constructor(resourcesGenerator: TemplatedResourcesGenerator, subfolders: string[]) {\n    this.resourcesGenerator = resourcesGenerator;\n    this.subfolders = subfolders;\n  }\n\n  public async* generate(templateFolder: string, location: ResourceIdentifier, options: Dict<string>):\n  AsyncIterable<Resource> {\n    const root = resolveAssetPath(templateFolder);\n    const templateSubfolders = this.subfolders.map((subfolder): string => joinFilePath(root, subfolder));\n\n    // Build all generators\n    const generators: AsyncIterator<Resource>[] = [];\n    for (const templateSubfolder of templateSubfolders) {\n      generators.push(this.resourcesGenerator.generate(templateSubfolder, location, options)[Symbol.asyncIterator]());\n    }\n\n    let previous: ResourceIdentifier = { path: '' };\n    for await (const result of sortedAsyncMerge(generators, comparator)) {\n      // Skip duplicate results.\n      // In practice these are just going to be the same empty containers.\n      if (result.identifier.path === previous.path) {\n        result.representation.data.destroy();\n      } else {\n        previous = result.identifier;\n        yield result;\n      }\n    }\n  }\n}\n"]}