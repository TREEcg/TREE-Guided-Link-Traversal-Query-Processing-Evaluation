{"version":3,"file":"TemplatedResourcesGenerator.js","sourceRoot":"","sources":["../../../src/pods/generate/TemplatedResourcesGenerator.ts"],"names":[],"mappings":";;;AAAA,2BAA8D;AAE9D,2BAA4B;AAE5B,uFAAoF;AACpF,6FAA0F;AAQ1F,0DAAyD;AACzD,4DAAuD;AAEvD,kDAA4F;AAC5F,0DAA8D;AAC9D,sDAA4E;AAuC5E;;;;;;;;GAQG;AACH,MAAa,2BAA2B;IAQtC;;;;OAIG;IACH,YAAmB,IAAqC;QACtD,IAAI,CAAC,cAAc,GAAG,IAAA,2BAAgB,EAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC5D,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,IAAI,MAAM,CAAC;QAC1D,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;IAC1B,CAAC;IAEM,KAAK,CAAA,CAAE,QAAQ,CAAC,QAA4B,EAAE,OAAqB;QACxE,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC7E,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;QAC1E,KAAK,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACzD,CAAC;IAED;;OAEG;IACK,KAAK,CAAA,CAAE,aAAa,CAAC,UAAgC,EAAE,MAA4B,EAAE,OAAqB;QAEhH,+DAA+D;QAC/D,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAEjE,oCAAoC;QACpC,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;QACzD,gEAAgE;QAChE,OAAO,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAEzC,KAAK,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAE5D,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;YACjD,IAAI,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,EAAE;gBAC1C,KAAK,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;aAClD;iBAAM;gBACL,KAAK,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;aACnD;SACF;IACH,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,cAAc,CAAC,QAAgB,EAAE,MAA4B;QACzE,MAAM,KAAK,GAAG,MAAM,aAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAE/C,mFAAmF;QACnF,MAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC7D,MAAM,UAAU,GAAG,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;QAC7F,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;QAC5E,+DAA+D;QAC/D,OAAO;YACL,GAAG,IAAI;YACP,QAAQ;YACR,UAAU;SACX,CAAC;IACJ,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,UAAU,CAAC,UAAkB,EAAE,MAA4B;QAEvE,MAAM,KAAK,GAAG,MAAM,aAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACnD,MAAM,KAAK,GAAgF,EAAG,CAAC;QAC/F,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAA,uBAAY,EAAC,UAAU,EAAE,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;YAC/E,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC;YACjC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;SAC7F;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAA,CAAE,gBAAgB,CAAC,IAA0B,EAAE,OAAqB,EAAE,QAA+B;QAEhH,IAAI,IAAmC,CAAC;QACxC,MAAM,QAAQ,GAAG,IAAI,+CAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAE7D,qCAAqC;QACrC,IAAI,CAAC,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC3C,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YAC7C,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;SACzC;QACD,yDAAyD;QACzD,IAAI,CAAC,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC7F,MAAM;gBACJ,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,cAAc,EAAE,IAAI,yCAAmB,CAAC,IAAI,IAAI,EAAE,EAAE,QAAQ,CAAC;aAC9D,CAAC;SACH;QAED,+CAA+C;QAC/C,IAAI,QAAQ,EAAE;YACZ,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACnE,MAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACrF,MAAM,eAAe,GAAG,IAAI,+CAAsB,CAAC,cAAc,CAAC,CAAC;YACnE,IAAA,kCAAmB,EAAC,WAAW,EAAE,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACzE,MAAM;gBACJ,UAAU,EAAE,cAAc;gBAC1B,cAAc,EAAE,IAAI,yCAAmB,CAAC,WAAW,CAAC,KAAK,EAAE,EAAE,eAAe,EAAE,6BAAc,CAAC;aAC9F,CAAC;SACH;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,gBAAgB,CAAC,QAA8B,EAAE,OAAqB;QAElF,MAAM,QAAQ,GAAG,IAAI,+CAAsB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAEjE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACvD,MAAM,MAAM,GAAG,IAAI,WAAM,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;QAC/F,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,IAAA,6BAAgB,EAAC,IAAI,CAAC,CAAC,CAAC;QACzD,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEzB,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,WAAW,CAAC,IAA0B,EAAE,OAAqB;QACzE,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,YAAY,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;YAC5F,OAAO,IAAA,8BAAiB,EAAC,QAAQ,CAAC,CAAC;SACpC;QACD,OAAO,IAAA,2BAAW,EAAC,IAAA,qBAAgB,EAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IACtD,CAAC;CACF;AArJD,kEAqJC","sourcesContent":["import { createReadStream, promises as fsPromises } from 'fs';\nimport type { Readable } from 'stream';\nimport { Parser } from 'n3';\nimport type { AuxiliaryStrategy } from '../../http/auxiliary/AuxiliaryStrategy';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type {\n  FileIdentifierMapper,\n  FileIdentifierMapperFactory,\n  ResourceLink,\n} from '../../storage/mapping/FileIdentifierMapper';\nimport type { ResourceSet } from '../../storage/ResourceSet';\nimport { INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { guardStream } from '../../util/GuardedStream';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { joinFilePath, isContainerIdentifier, resolveAssetPath } from '../../util/PathUtil';\nimport { addResourceMetadata } from '../../util/ResourceUtil';\nimport { guardedStreamFrom, readableToString } from '../../util/StreamUtil';\nimport type { TemplateEngine } from '../../util/templates/TemplateEngine';\nimport type { Resource, ResourcesGenerator } from './ResourcesGenerator';\nimport Dict = NodeJS.Dict;\n\ninterface TemplateResourceLink extends ResourceLink {\n  isTemplate: boolean;\n}\n\n/**\n * Input arguments required for {@link TemplatedResourcesGenerator}\n */\nexport interface TemplatedResourcesGeneratorArgs {\n  /**\n   * Folder where the templates are located.\n   */\n  templateFolder: string;\n  /**\n   * Factory used to generate mapper relative to the base identifier.\n   */\n  factory: FileIdentifierMapperFactory;\n  /**\n   * Template engine for generating the resources.\n   */\n  templateEngine: TemplateEngine;\n  /**\n   * The extension of files that need to be interpreted as templates.\n   * Will be removed to generate the identifier.\n   */\n  templateExtension?: string;\n  /**\n   * The metadataStrategy\n   */\n  metadataStrategy: AuxiliaryStrategy;\n  /**\n   * The default ResourceStore\n   */\n  store: ResourceSet;\n}\n/**\n * Generates resources by making use of a template engine.\n * The template folder structure will be kept.\n * Folders will be interpreted as containers and files as documents.\n * A FileIdentifierMapper will be used to generate identifiers that correspond to the relative structure.\n *\n * A relative `templateFolder` is resolved relative to cwd,\n * unless it's preceded by `@css:`, e.g. `@css:foo/bar`.\n */\nexport class TemplatedResourcesGenerator implements ResourcesGenerator {\n  private readonly templateFolder: string;\n  private readonly factory: FileIdentifierMapperFactory;\n  private readonly templateEngine: TemplateEngine;\n  private readonly templateExtension: string;\n  private readonly metadataStrategy: AuxiliaryStrategy;\n  private readonly store: ResourceSet;\n\n  /**\n   * A mapper is needed to convert the template file paths to identifiers relative to the given base identifier.\n   *\n   * @param args - TemplatedResourcesGeneratorArgs\n   */\n  public constructor(args: TemplatedResourcesGeneratorArgs) {\n    this.templateFolder = resolveAssetPath(args.templateFolder);\n    this.factory = args.factory;\n    this.templateEngine = args.templateEngine;\n    this.templateExtension = args.templateExtension ?? '.hbs';\n    this.metadataStrategy = args.metadataStrategy;\n    this.store = args.store;\n  }\n\n  public async* generate(location: ResourceIdentifier, options: Dict<string>): AsyncIterable<Resource> {\n    const mapper = await this.factory.create(location.path, this.templateFolder);\n    const folderLink = await this.toTemplateLink(this.templateFolder, mapper);\n    yield* this.processFolder(folderLink, mapper, options);\n  }\n\n  /**\n   * Generates results for all entries in the given folder, including the folder itself.\n   */\n  private async* processFolder(folderLink: TemplateResourceLink, mapper: FileIdentifierMapper, options: Dict<string>):\n  AsyncIterable<Resource> {\n    // Group resource links with their corresponding metadata links\n    const links = await this.groupLinks(folderLink.filePath, mapper);\n\n    // Remove root metadata if it exists\n    const metaLink = links[folderLink.identifier.path]?.meta;\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete links[folderLink.identifier.path];\n\n    yield* this.generateResource(folderLink, options, metaLink);\n\n    for (const { link, meta } of Object.values(links)) {\n      if (isContainerIdentifier(link.identifier)) {\n        yield* this.processFolder(link, mapper, options);\n      } else {\n        yield* this.generateResource(link, options, meta);\n      }\n    }\n  }\n\n  /**\n   * Creates a TemplateResourceLink for the given filePath.\n   * The identifier will be based on the file path stripped from the template extension,\n   * but the filePath parameter will still point to the original file.\n   */\n  private async toTemplateLink(filePath: string, mapper: FileIdentifierMapper): Promise<TemplateResourceLink> {\n    const stats = await fsPromises.lstat(filePath);\n\n    // Slice the template extension from the filepath for correct identifier generation\n    const isTemplate = filePath.endsWith(this.templateExtension);\n    const slicedPath = isTemplate ? filePath.slice(0, -this.templateExtension.length) : filePath;\n    const link = await mapper.mapFilePathToUrl(slicedPath, stats.isDirectory());\n    // We still need the original file path for disk reading though\n    return {\n      ...link,\n      filePath,\n      isTemplate,\n    };\n  }\n\n  /**\n   * Generates TemplateResourceLinks for each entry in the given folder\n   * and combines the results so resources and their metadata are grouped together.\n   */\n  private async groupLinks(folderPath: string, mapper: FileIdentifierMapper):\n  Promise<Record<string, { link: TemplateResourceLink; meta?: TemplateResourceLink }>> {\n    const files = await fsPromises.readdir(folderPath);\n    const links: Record<string, { link: TemplateResourceLink; meta?: TemplateResourceLink }> = { };\n    for (const name of files) {\n      const link = await this.toTemplateLink(joinFilePath(folderPath, name), mapper);\n      const { path } = link.identifier;\n      links[path] = Object.assign(links[path] || {}, link.isMetadata ? { meta: link } : { link });\n    }\n    return links;\n  }\n\n  /**\n   * Generates a Resource object for the given ResourceLink.\n   * In the case of documents the corresponding template will be used.\n   * If a ResourceLink of metadata is provided the corresponding data will be added as metadata.\n   */\n  private async* generateResource(link: TemplateResourceLink, options: Dict<string>, metaLink?: TemplateResourceLink):\n  AsyncIterable<Resource> {\n    let data: Guarded<Readable> | undefined;\n    const metadata = new RepresentationMetadata(link.identifier);\n\n    // Read file if it is not a container\n    if (!isContainerIdentifier(link.identifier)) {\n      data = await this.processFile(link, options);\n      metadata.contentType = link.contentType;\n    }\n    // Do not yield a container resource if it already exists\n    if (!isContainerIdentifier(link.identifier) || !await this.store.hasResource(link.identifier)) {\n      yield {\n        identifier: link.identifier,\n        representation: new BasicRepresentation(data ?? [], metadata),\n      };\n    }\n\n    // Add metadata from .meta file if there is one\n    if (metaLink) {\n      const rawMetadata = await this.generateMetadata(metaLink, options);\n      const metaIdentifier = this.metadataStrategy.getAuxiliaryIdentifier(link.identifier);\n      const descriptionMeta = new RepresentationMetadata(metaIdentifier);\n      addResourceMetadata(rawMetadata, isContainerIdentifier(link.identifier));\n      yield {\n        identifier: metaIdentifier,\n        representation: new BasicRepresentation(rawMetadata.quads(), descriptionMeta, INTERNAL_QUADS),\n      };\n    }\n  }\n\n  /**\n   * Generates a RepresentationMetadata using the given template.\n   */\n  private async generateMetadata(metaLink: TemplateResourceLink, options: Dict<string>):\n  Promise<RepresentationMetadata> {\n    const metadata = new RepresentationMetadata(metaLink.identifier);\n\n    const data = await this.processFile(metaLink, options);\n    const parser = new Parser({ format: metaLink.contentType, baseIRI: metaLink.identifier.path });\n    const quads = parser.parse(await readableToString(data));\n    metadata.addQuads(quads);\n\n    return metadata;\n  }\n\n  /**\n   * Creates a read stream from the file and applies the template if necessary.\n   */\n  private async processFile(link: TemplateResourceLink, options: Dict<string>): Promise<Guarded<Readable>> {\n    if (link.isTemplate) {\n      const rendered = await this.templateEngine.render(options, { templateFile: link.filePath });\n      return guardedStreamFrom(rendered);\n    }\n    return guardStream(createReadStream(link.filePath));\n  }\n}\n"]}