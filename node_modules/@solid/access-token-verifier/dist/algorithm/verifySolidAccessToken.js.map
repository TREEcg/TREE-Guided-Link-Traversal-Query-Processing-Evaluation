{"version":3,"file":"verifySolidAccessToken.js","sourceRoot":"","sources":["../../src/algorithm/verifySolidAccessToken.ts"],"names":[],"mappings":";;;AAAA,+BAAiC;AACjC,yCAAoC;AACpC,oEAAoE;AACpE,sCAAgF;AAChF,uGAAoG;AACpG,oEAAiE;AAMjE,6EAA0E;AAC1E,mFAAgF;AAChF,uFAAoF;AACpF,uFAAoF;AACpF,uDAAoD;AACpD,iEAA8D;AAC9D,iFAA8E;AAC9E,iGAA8F;AAE9F;;;;;;GAMG;AACI,KAAK,UAAU,sBAAsB,CAC1C,aAAoC,EACpC,WAAyB;IAEzB,MAAM,QAAQ,GAAG,IAAA,6DAA6B,EAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAErE,oCAAoC;IACpC,MAAM,kBAAkB,GAAY,IAAA,uDAA0B,EAC5D,QAAQ,CAAC,UAAU,CACpB,CAAC;IAEF,6DAA6D;IAC7D,IAAA,2EAAoC,EAAC,kBAAkB,CAAC,CAAC;IAEzD,oCAAoC;IACpC,IAAA,2CAAoB,EAAC,kBAAkB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAExD,qCAAqC;IACrC,IAAA,2CAAoB,EAAC,kBAAkB,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAEpD,2CAA2C;IAC3C,MAAM,OAAO,GAAG,MAAM,IAAA,iEAA+B,EACnD,kBAAkB,CAAC,KAAK,EACxB,aAAa,CAAC,OAAO,CACtB,CAAC;IAEF,oEAAoE;IACpE,IAAA,2DAA4B,EAAC,OAAO,EAAE,kBAAkB,CAAC,GAAG,CAAC,CAAC;IAE9D;;;;;;;;;OASG;IACH,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,GAAG,MAAM,IAAA,gBAAS,EAClD,QAAQ,CAAC,KAAK,EACd,MAAM,IAAA,iEAA+B,EACnC,kBAAkB,CAAC,GAAG,EACtB,aAAa,CAAC,MAAM,CACrB,EACD;QACE,QAAQ,EAAE,OAAO;QACjB,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,uEAAkC,CAAC;QAC1D,WAAW,EAAE,GAAG,mCAA0B,GAAG;QAC7C,cAAc,EAAE,GAAG,gCAAuB,GAAG;KAC9C,CACF,CAAC;IAEF,iDAAiD;IACjD,MAAM,WAAW,GAAG;QAClB,MAAM,EAAE,eAAe;QACvB,OAAO;QACP,SAAS,EAAE,QAAQ,CAAC,YAAY;KACjC,CAAC;IAEF,IAAA,uCAAkB,EAAC,WAAW,CAAC,CAAC;IAEhC,IACE,QAAQ,CAAC,oBAAoB,KAAK,MAAM;QACxC,IAAA,oCAAkB,EAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,EAC9C;QACA,IAAI;YACF,mBAAO,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;SAC3C;QAAC,OAAO,CAAC,EAAE;YACV,+BAA+B;YAC/B,0BAA0B;YAC1B,MAAM,IAAI,KAAK,CACb,sFAAsF,CACvF,CAAC;SACH;QAED,MAAM,IAAA,iCAAe,EACnB,WAAW,CAAC,MAAM,EAClB,WAAW,EACX,QAAQ,CAAC,KAAK,EACd,WAAW,CAAC,MAAM,EAClB,WAAW,CAAC,GAAG,EACf,WAAW,CAAC,cAAc,CAC3B,CAAC;KACH;IAED,OAAO,WAAW,CAAC,OAAO,CAAC;AAC7B,CAAC;AAvFD,wDAuFC","sourcesContent":["import { jwtVerify } from \"jose\";\nimport { asserts } from \"ts-guards\";\nimport { isObjectPropertyOf } from \"ts-guards/dist/standard-object\";\nimport { clockToleranceInSeconds, maxAccessTokenAgeInSeconds } from \"../config\";\nimport { ASYMMETRIC_CRYPTOGRAPHIC_ALGORITHM } from \"../constant/ASYMMETRIC_CRYPTOGRAPHIC_ALGORITHM\";\nimport { isSolidAccessToken } from \"../guard/isSolidAccessToken\";\nimport type {\n  SolidAccessTokenPayload,\n  AuthenticationOptions,\n  DPoPOptions,\n} from \"../type\";\nimport { decodeBase64UrlEncodedJson } from \"./decodeBase64UrlEncodedJson\";\nimport { parseSolidAuthorizationHeader } from \"./parseSolidAuthorizationHeader\";\nimport { retrieveAccessTokenIssuerKeySet } from \"./retrieveAccessTokenIssuerKeySet\";\nimport { retrieveWebidTrustedOidcIssuers } from \"./retrieveWebidTrustedOidcIssuers\";\nimport { verifyDpopProof } from \"./verifyDpopProof\";\nimport { verifySecureUriClaim } from \"./verifySecureUriClaim\";\nimport { verifySolidAccessTokenIssuer } from \"./verifySolidAccessTokenIssuer\";\nimport { verifySolidAccessTokenRequiredClaims } from \"./verifySolidAccessTokenRequiredClaims\";\n\n/**\n * Verify Solid access token\n *\n * @param authorization The authorization header and optional key and trusted issuer retrieval functions\n * @param dpopOptions The DPoP proof header and associated verifiable claims\n * @returns Access token payload\n */\nexport async function verifySolidAccessToken(\n  authorization: AuthenticationOptions,\n  dpopOptions?: DPoPOptions\n): Promise<SolidAccessTokenPayload> {\n  const solidJwt = parseSolidAuthorizationHeader(authorization.header);\n\n  // Decode Solid access token payload\n  const accessTokenPayload: unknown = decodeBase64UrlEncodedJson(\n    solidJwt.jwsPayload\n  );\n\n  // Verify the Solid access token includes all required claims\n  verifySolidAccessTokenRequiredClaims(accessTokenPayload);\n\n  // Check WebID claim is a secure URI\n  verifySecureUriClaim(accessTokenPayload.webid, \"webid\");\n\n  // Check Issuer claim is a secure URI\n  verifySecureUriClaim(accessTokenPayload.iss, \"iss\");\n\n  // Retrieve the issuers listed in the WebID\n  const issuers = await retrieveWebidTrustedOidcIssuers(\n    accessTokenPayload.webid,\n    authorization.issuers\n  );\n\n  // Check the issuer claim matches one of the WebID's trusted issuers\n  verifySolidAccessTokenIssuer(issuers, accessTokenPayload.iss);\n\n  /**\n   * Verify Access Token\n   * - Signature of Access Token JWT/JWS matches a key in the remote jwks\n   * - Access Token max age 1 day\n   * - Claims:\n   *    - audience 'aud' is solid\n   *    - algorithm 'alg' is an asymetric cryptographic algorithm\n   *    - expiration 'exp' is not in the past\n   *    - 'iat' is not in the future\n   */\n  const { payload, protectedHeader } = await jwtVerify(\n    solidJwt.value,\n    await retrieveAccessTokenIssuerKeySet(\n      accessTokenPayload.iss,\n      authorization.keySet\n    ),\n    {\n      audience: \"solid\",\n      algorithms: Array.from(ASYMMETRIC_CRYPTOGRAPHIC_ALGORITHM),\n      maxTokenAge: `${maxAccessTokenAgeInSeconds}s`,\n      clockTolerance: `${clockToleranceInSeconds}s`,\n    }\n  );\n\n  // Get JWT value for either DPoP or Bearer tokens\n  const accessToken = {\n    header: protectedHeader,\n    payload,\n    signature: solidJwt.jwsSignature,\n  };\n\n  isSolidAccessToken(accessToken);\n\n  if (\n    solidJwt.authenticationScheme === \"DPoP\" ||\n    isObjectPropertyOf(accessToken.payload, \"cnf\")\n  ) {\n    try {\n      asserts.isNotNullOrUndefined(dpopOptions);\n    } catch (_) {\n      // TODO: Increase test coverage\n      /* istanbul ignore next */\n      throw new Error(\n        \"SolidIdentityDPoPError DPoP options missing for DPoP bound access token verification\"\n      );\n    }\n\n    await verifyDpopProof(\n      dpopOptions.header,\n      accessToken,\n      solidJwt.value,\n      dpopOptions.method,\n      dpopOptions.url,\n      dpopOptions.isDuplicateJTI\n    );\n  }\n\n  return accessToken.payload;\n}\n"]}