{"version":3,"file":"verifyDpopProof.js","sourceRoot":"","sources":["../../src/algorithm/verifyDpopProof.ts"],"names":[],"mappings":";;;AAAA,+BAA8C;AAC9C,yCAAoC;AACpC,sCAA0E;AAC1E,uGAAoG;AACpG,sDAAmD;AACnD,oGAAiG;AAMjG,qFAAkF;AAClF,2EAAwE;AACxE,qEAAkE;AAClE,iFAA8E;AAC9E,iFAA8E;AAE9E;;;;;;;;;;;;GAYG;AACI,KAAK,UAAU,eAAe,CACnC,UAAkB,EAClB,WAA6B,EAC7B,gBAAwB,EACxB,UAAyB,EACzB,GAAW,EACX,cAAiC;IAEjC,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,GAAG,MAAM,IAAA,gBAAS,EAClD,UAAU,EACV,kBAAW,EACX;QACE,GAAG,EAAE,UAAU;QACf,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,uEAAkC,CAAC;QAC1D,WAAW,EAAE,GAAG,6BAAoB,GAAG,IAAI,GAAG;QAC9C,cAAc,EAAE,GAAG,gCAAuB,GAAG;KAC9C,CACF,CAAC;IAEF,MAAM,IAAI,GAAG;QACX,MAAM,EAAE,eAAe;QACvB,OAAO;QACP,SAAS,EAAE,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;KACpC,CAAC;IAEF,IAAA,yBAAW,EAAC,IAAI,CAAC,CAAC;IAElB,mBAAO,CAAC,kBAAkB,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACvD,IAAA,uEAAkC,EAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IAExD,MAAM,IAAA,2DAA4B,EAChC,IAAI,CAAC,MAAM,CAAC,GAAG,EACf,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAC5B,CAAC;IAEF,IAAA,qDAAyB,EAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAExD,IAAA,+CAAsB,EAAC,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAE9C,IAAA,2DAA4B,EAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;IAE/D,uCAAuC;IACvC,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,KAAK,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE;QAC5D,IAAA,+DAA8B,EAAC,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;KACpE;AACH,CAAC;AA7CD,0CA6CC","sourcesContent":["import { EmbeddedJWK, jwtVerify } from \"jose\";\nimport { asserts } from \"ts-guards\";\nimport { clockToleranceInSeconds, maxAgeInMilliseconds } from \"../config\";\nimport { ASYMMETRIC_CRYPTOGRAPHIC_ALGORITHM } from \"../constant/ASYMMETRIC_CRYPTOGRAPHIC_ALGORITHM\";\nimport { isDPoPToken } from \"../guard/isDPoPToken\";\nimport { isSolidDPoPBoundAccessTokenPayload } from \"../guard/isSolidDPoPBoundAccessTokenPayload\";\nimport type {\n  SolidAccessToken,\n  JTICheckFunction,\n  RequestMethod,\n} from \"../type\";\nimport { verifyDpopProofAccessTokenHash } from \"./verifyDpopProofAccessTokenHash\";\nimport { verifyDpopProofHttpMethod } from \"./verifyDpopProofHttpMethod\";\nimport { verifyDpopProofHttpUri } from \"./verifyDpopProofHttpUri\";\nimport { verifyDpopProofJwkThumbprint } from \"./verifyDpopProofJwkThumbprint\";\nimport { verifyDpopProofJwtIdentifier } from \"./verifyDpopProofJwtIdentifier\";\n\n/**\n * Verify DPoP Proof\n * - Signature of DPoP JWT/JWS matches the key embedded in its header\n * - DPoP max age 60 seconds\n * - Claims:\n *    - algorithm 'alg' is an asymetric cryptographic algorithm\n *    - 'iat' is not too far in the future (clockTolerance) or in the past (maxTokenAge)\n *    - 'typ' is 'dpop+jwt'\n * Note:\n * - The maxTokenAge option makes the iat claim mandatory\n * - DPoP tokens can rely on iat+maxTokenAge to be invalidated since they are specific to a request\n *   (so the exp claim which is not required in DPoP tokens' bodys is also redundant)\n */\nexport async function verifyDpopProof(\n  dpopHeader: string,\n  accessToken: SolidAccessToken,\n  accessTokenValue: string,\n  httpMethod: RequestMethod,\n  uri: string,\n  isDuplicateJTI?: JTICheckFunction\n): Promise<void> {\n  const { payload, protectedHeader } = await jwtVerify(\n    dpopHeader,\n    EmbeddedJWK,\n    {\n      typ: \"dpop+jwt\",\n      algorithms: Array.from(ASYMMETRIC_CRYPTOGRAPHIC_ALGORITHM),\n      maxTokenAge: `${maxAgeInMilliseconds / 1000}s`,\n      clockTolerance: `${clockToleranceInSeconds}s`,\n    }\n  );\n\n  const dpop = {\n    header: protectedHeader,\n    payload,\n    signature: dpopHeader.split(\".\")[2],\n  };\n\n  isDPoPToken(dpop);\n\n  asserts.isObjectPropertyOf(accessToken.payload, \"cnf\");\n  isSolidDPoPBoundAccessTokenPayload(accessToken.payload);\n\n  await verifyDpopProofJwkThumbprint(\n    dpop.header.jwk,\n    accessToken.payload.cnf.jkt\n  );\n\n  verifyDpopProofHttpMethod(httpMethod, dpop.payload.htm);\n\n  verifyDpopProofHttpUri(uri, dpop.payload.htu);\n\n  verifyDpopProofJwtIdentifier(dpop.payload.jti, isDuplicateJTI);\n\n  // TODO: Phased-in ath becomes enforced\n  if (typeof dpop.payload.ath === \"string\" && dpop.payload.ath) {\n    verifyDpopProofAccessTokenHash(accessTokenValue, dpop.payload.ath);\n  }\n}\n"]}