"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLiteralType = exports.isLiteral = exports.areObjectPropertiesOf = exports.isObjectPropertyOf = exports.isArrayOf = exports.isArray = exports.isObject = exports.isNotNullOrUndefined = exports.isSymbol = exports.isBigInt = exports.isNumber = exports.isString = exports.isBoolean = exports.isUndefined = exports.isNull = exports.error = void 0;
const literalType = __importStar(require("./literal-type"));
const primitiveType = __importStar(require("./primitive-type"));
const standardObject = __importStar(require("./standard-object"));
/**
 * Throw Type Error
 */
function error(expected, actual) {
    throw new TypeError(`Expected ${expected}, got:\n${actual}`);
}
exports.error = error;
/**
 * Primitive Type Asserts
 */
// Structural Root Primitive
function isNull(x) {
    if (!primitiveType.isNull(x))
        error('null', x);
}
exports.isNull = isNull;
// Primitive Data Types
function isUndefined(x) {
    if (!primitiveType.isUndefined(x))
        error('undefined', x);
}
exports.isUndefined = isUndefined;
function isBoolean(x) {
    if (!primitiveType.isBoolean(x))
        error('boolean', x);
}
exports.isBoolean = isBoolean;
function isString(x) {
    if (!primitiveType.isString(x))
        error('string', x);
}
exports.isString = isString;
function isNumber(x) {
    if (!primitiveType.isNumber(x))
        error('number', x);
}
exports.isNumber = isNumber;
function isBigInt(x) {
    if (!primitiveType.isBigInt(x))
        error('bigint', x);
}
exports.isBigInt = isBigInt;
function isSymbol(x) {
    if (!primitiveType.isSymbol(x))
        error('symbol', x);
}
exports.isSymbol = isSymbol;
// Convenience Primitive Type
function isNotNullOrUndefined(x) {
    if (primitiveType.isNull(x))
        error('not null', x);
    if (primitiveType.isUndefined(x))
        error('not undefined', x);
}
exports.isNotNullOrUndefined = isNotNullOrUndefined;
// Structural Types
function isObject(x) {
    if (!primitiveType.isObject(x))
        error('object', x);
}
exports.isObject = isObject;
/**
 * Standard Object Asserts
 */
// Array
function isArray(x) {
    if (!standardObject.isArray(x))
        error('array', x);
}
exports.isArray = isArray;
function isArrayOf(x, y) {
    if (!standardObject.isArrayOf(x, y))
        error(`array of ${y.name}`, x);
}
exports.isArrayOf = isArrayOf;
// Object
function isObjectPropertyOf(x, property) {
    if (!standardObject.isObjectPropertyOf(x, property))
        error(`object property ${property}`, x);
}
exports.isObjectPropertyOf = isObjectPropertyOf;
function areObjectPropertiesOf(x, property) {
    property.forEach(p => isObjectPropertyOf(x, p));
}
exports.areObjectPropertiesOf = areObjectPropertiesOf;
/**
 * Literal Type Asserts
 */
function isLiteral(x, value) {
    if (!literalType.isLiteral(x, value))
        error(value, x);
}
exports.isLiteral = isLiteral;
function isLiteralType(x, set) {
    if (!literalType.isLiteralType(x, set))
        error(set, x);
}
exports.isLiteralType = isLiteralType;
//# sourceMappingURL=asserts.js.map